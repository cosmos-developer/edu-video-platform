This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  agents/
    agent-lead.txt
    backend-agent.txt
    database-agent.txt
    devops-agent.txt
    docs-writer-agent.txt
    frontend-agent.txt
    testing-agent.txt
  settings.local.json
.serena/
  memories/
    code_style_and_conventions.md
    multi_agent_architecture.md
    project_overview.md
    suggested_commands.md
    task_completion_checklist.md
    tech_stack_and_dependencies.md
  project.yml
database/
  init-scripts/
    01-init-db.sql
    02-run-migrations.sh
  migrations/
    001_initial_schema.sql
    002_performance_indexes.sql
    add_milestone_type.sql
  prisma/
    migrations/
      0_init/
        migration.sql
    schema.prisma
  seeds/
    001_initial_data.d.ts
    001_initial_data.d.ts.map
    001_initial_data.js
    001_initial_data.js.map
    001_initial_data.ts
  README.md
  SCHEMA_DESIGN.md
  types.d.ts
  types.d.ts.map
  types.js
  types.js.map
  types.ts
docs/
  arch/
    authentication-architecture.md
    video-player-architecture-v2.md
  plans/
    LESSON_SERVICE_REFACTORING_PLAN.md
  COMMON_ERRORS.md
frontend/
  public/
    vite.svg
  src/
    assets/
      react.svg
    components/
      auth/
        AuthErrorBoundary.tsx
        AuthStatusIndicator.tsx
        ProtectedRoute.tsx
      dashboard/
        AdminDashboard.tsx
        StudentDashboard.tsx
        TeacherDashboard.tsx
      layout/
        Layout.tsx
      lessons/
        BaseLessonPage.tsx
        VideoList.tsx
      teacher/
        AIQuestionGenerator.tsx
        MilestoneEditor.tsx
        QuestionEditor.tsx
        VideoUploadForm.tsx
        VideoUploadModal.tsx
      ui/
        __tests__/
          LoadingSpinner.test.tsx
        LoadingSpinner.tsx
      video/
        __tests__/
          VideoPlayer.test.tsx
        MilestoneMarkers.tsx
        QuestionOverlay.tsx
        VideoControls.tsx
        VideoPlayer.tsx
    contexts/
      AuthContext.tsx
      VideoStateContext.tsx
    hooks/
      useAuth.ts
      useVideoState.ts
    pages/
      auth/
        __tests__/
          LoginPage.test.tsx
        LoginPage.tsx
        RegisterPage.tsx
      dashboard/
        DashboardPage.tsx
      lessons/
        LessonDetailPage.tsx
        LessonsPage.tsx
      teacher/
        CreateLessonPage.tsx
        LessonManagementPage.tsx
        TeacherLessonsPage.tsx
      video/
        VideoPlayerPage.tsx
    services/
      ai.ts
      api.ts
      auth.ts
      lesson.ts
      tokenManager.ts
      video.ts
    stores/
      README.md
      VideoStateManager.ts
    test/
      mocks/
        handlers.ts
        server.ts
      setup.ts
      utils.tsx
    types/
      auth.ts
    utils/
      debug.ts
      progressCalculator.ts
      validators.ts
    App.css
    App.tsx
    index.css
    main.tsx
    vite-env.d.ts
  .gitignore
  eslint.config.js
  index.html
  package.json
  postcss.config.js
  README.md
  tailwind.config.js
  tsconfig.app.json
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
  vitest.config.ts
scripts/
  database/
    check-user.js
    seed-video.js
    simple-seed.js
  dev/
    dev.sh
  frontend/
    debug-frontend.sh
    screenshot.ts
  testing/
    check-access.ts
    enroll-student.ts
    run-tests.sh
    test-api.sh
    test-lesson-detail.sh
    test-session.ts
    test-video-player.ts
  video/
    process-video.mjs
    process-video.ts
  README.md
  tsconfig.json
src/
  config/
    database.ts
    environment.ts
  controllers/
    __tests__/
      auth.controller.test.ts
    lessonController.ts
    userController.ts
  middleware/
    auth/
      authMiddleware.ts
      sessionMiddleware.ts
    error/
      errorHandler.ts
      notFoundHandler.ts
    logger/
      requestLogger.ts
    security/
      corsMiddleware.ts
      rateLimitMiddleware.ts
      securityMiddleware.ts
    upload/
      videoUploadMiddleware.ts
    validation/
      validateRequest.ts
  routes/
    aiRoutes.ts
    analyticsRoutes.ts
    authRoutes.ts
    index.ts
    lessonRoutes.ts
    milestoneRoutes.ts
    questionRoutes.ts
    sessionRoutes.ts
    userRoutes.ts
    videoRoutes.ts
  services/
    __tests__/
      user.service.test.ts
    auth/
      authService.ts
      jwtService.ts
    storage/
      gcsService.ts
    AIQuestionService.ts
    AnalyticsService.ts
    MilestoneService.ts
    QuestionService.ts
    VideoProcessingService.ts
    VideoService.ts
    VideoSessionService.ts
  types/
    auth.ts
    index.ts
  utils/
    logger.ts
    validators.ts
  index.ts
tests/
  cases/
    test_answer_submit.sh
    test_api_video.sh
    test_invalid_lesson.json
    test_invalid_lesson2.json
    test_invalid_login.json
    test_lesson.json
    test_lesson2.json
    test_login.json
    test_student_login.json
    test_video_group.json
    test_video_group2.json
  factories/
    index.ts
  utils/
    database.ts
  setup.ts
.env.example
.env.test
.eslintrc.js
.gitignore
CLAUDE.md
dev.sh
docker-compose.dev.yml
INTEGRATION_TESTING.md
jest.config.js
package.json
PRODUCT_ROADMAP.md
QUICK_START.md
README.md
TESTING_SUITE_PLAN.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(mkdir:*)",
      "mcp__serena__list_dir",
      "mcp__serena__get_symbols_overview",
      "Bash(npm install:*)",
      "Bash(npm run build:*)",
      "Bash(npx prisma generate:*)",
      "Bash(chmod:*)",
      "Bash(cp:*)",
      "Bash(npm run:*)",
      "Bash(npm create:*)",
      "Bash(rm:*)",
      "Bash(npx create-vite@latest:*)",
      "Bash(mv:*)",
      "Bash(true)",
      "Bash(npx tailwindcss init:*)",
      "mcp__serena__find_symbol",
      "Bash(docker:*)",
      "Bash(docker-compose:*)",
      "mcp__serena__check_onboarding_performed",
      "mcp__serena__onboarding",
      "mcp__serena__find_file",
      "Bash(find:*)",
      "mcp__serena__write_memory",
      "mcp__serena__think_about_whether_you_are_done",
      "Bash(grep:*)",
      "mcp__serena__replace_regex",
      "Bash(npx tsc:*)",
      "mcp__serena__search_for_pattern",
      "Bash(npx eslint:*)",
      "Bash(timeout 10s npm run dev)",
      "Bash(timeout 12s npm run dev)",
      "Bash(curl:*)",
      "Bash(timeout 15s npm run dev)",
      "Bash(git remote add:*)",
      "Bash(git rev-parse:*)",
      "Bash(git ls-tree:*)",
      "mcp__serena__think_about_collected_information",
      "Bash(npx prisma migrate dev:*)",
      "Bash(npx prisma db push:*)",
      "Bash(npx ts-node:*)",
      "Bash(node:*)",
      "mcp__serena__think_about_task_adherence",
      "mcp__serena__read_memory",
      "mcp__serena__replace_symbol_body",
      "Bash(./test_api_video.sh:*)",
      "Bash(./test_answer_submit.sh:*)",
      "Bash(psql:*)",
      "Bash(open:*)",
      "WebFetch(domain:docs.anthropic.com)",
      "Bash(git worktree:*)",
      "Bash(npm --version)",
      "Bash(echo \"# Creating worktrees for parallel development\n\n# Example 1: Create worktree for a new feature\ngit worktree add ../education-platform-feature -b feature/new-feature\n\n# Example 2: Create worktree for bug fixes  \ngit worktree add ../education-platform-bugfix -b bugfix/issue-123\n\n# Example 3: Create worktree from existing branch\ngit worktree add ../education-platform-testing testing-branch\n\n# List all worktrees\ngit worktree list\")",
      "Bash(pkill:*)",
      "Bash(./dev.sh:*)",
      "Bash(/Users/thevinhnguyen/Documents/ai/education-platform/dev.sh status)",
      "Bash(tree:*)",
      "Bash(git worktree:*)",
      "Bash(for file in src/routes/*.ts)",
      "Bash(do sed -i '' \"s/import { Router }/import { Router, Response }/g\" \"$file\")",
      "Bash(done)",
      "Bash(npx prisma db seed:*)",
      "Bash(./scripts/dev.sh test:auth:*)",
      "Bash(./scripts/dev.sh:*)",
      "Bash(lsof:*)",
      "mcp__serena__insert_after_symbol",
      "Bash(cat:*)",
      "mcp__serena__insert_before_symbol",
      "Bash(npx tsx:*)",
      "Bash(./scripts/test-lesson-detail.sh:*)",
      "Bash(gh:*)",
      "Bash(git add:*)"
    ],
    "deny": []
  }
}
</file>

<file path=".claude/agents/backend-agent.txt">
You are the Back-End Agent in a multi-agent coding system specializing in the Interactive Learning Platform. You focus on Node.js/TypeScript backend development for educational technology.

EXPERTISE:
- Node.js/TypeScript with Express.js framework
- Educational platform APIs (user management, content delivery, progress tracking)
- JWT-based authentication with role-based access control (student/teacher/admin)
- Google Cloud Storage integration for video management
- Multi-AI API integration (OpenAI, Claude, configurable providers)
- Real-time progress tracking and session management
- Video streaming optimization and milestone delivery
- Educational data analytics and reporting APIs

RESPONSIBILITIES:
- Build Node.js/TypeScript APIs for user management (students/teachers/admins)
- Implement video milestone tracking and interactive pause/resume functionality
- Create AI integration layer for question generation with multiple provider support
- Design authentication system with role-based permissions and multi-tenancy
- Build real-time progress tracking and session persistence APIs
- Integrate Google Cloud Storage for video upload and streaming
- Implement grading system with configurable retry limits
- Create analytics APIs for teacher dashboards and admin reporting

WORKFLOW:
1. Analyze requirements and design API specifications
2. Plan database interactions with Database Agent
3. Implement endpoints with proper validation and error handling
4. Integrate authentication and authorization mechanisms
5. Add logging, monitoring, and health check endpoints
6. Optimize for performance and scalability
7. Coordinate with Front-End Agent on API contracts

COMMUNICATION WITH OTHER AGENTS:
- Database Agent: Define data models, queries, and migration strategies
- Front-End Agent: Establish API contracts, data formats, and error responses
- Testing Agent: Create testable endpoints and provide test data fixtures
- DevOps Agent: Provide containerization requirements, environment configurations, and deployment specifications
- Docs Writer: Document API endpoints, authentication flows, and deployment guides

SECURITY FOCUS:
- Input validation and sanitization
- SQL injection and XSS prevention
- Rate limiting and DDoS protection
- Secure session management
- Data encryption at rest and in transit
- CORS and CSP configuration

PLATFORM-SPECIFIC FOCUS:
- Multi-tenant architecture with role-based data access
- Video annotation and milestone management systems
- AI question generation workflow with approval processes
- Student progress tracking across devices and sessions
- Teacher content creation and management tools
- Admin dashboard APIs for system oversight
- Integration with external services (Google Cloud, AI APIs)

DELIVERABLES:
- TypeScript/Node.js REST APIs with Express.js
- JWT authentication with role-based authorization middleware
- Google Cloud Storage integration for video management
- Multi-AI provider abstraction layer for question generation
- Real-time APIs for video progress and milestone tracking
- PostgreSQL integration using Prisma/TypeORM
- Educational analytics and reporting endpoints
- Comprehensive API documentation with OpenAPI/Swagger
</file>

<file path=".claude/agents/devops-agent.txt">
You are the DevOps Agent in a multi-agent coding system specializing in the Interactive Learning Platform. You focus on deployment automation, infrastructure management, containerization, and cloud deployment strategies.

EXPERTISE:
- Docker containerization for educational platform services (Node.js/TypeScript backend, React frontend, PostgreSQL)
- Local development environment setup and automation
- Google Cloud Platform deployment (Cloud Run, Kubernetes Engine, Cloud SQL, Cloud Storage)
- CI/CD pipeline design and implementation (GitHub Actions, Cloud Build)
- Infrastructure as Code with Terraform and Google Cloud Deployment Manager
- Database migration automation and zero-downtime deployments
- Monitoring and observability setup (Cloud Monitoring, Cloud Logging, APM)
- Security hardening and secret management (Cloud Secret Manager, Container Registry)
- Performance optimization for educational video streaming and concurrent user loads
- Cost optimization strategies for educational platforms

RESPONSIBILITIES:
- Create Docker configurations for multi-service educational platform architecture
- Design local development environment with Docker Compose for full-stack development
- Implement Google Cloud Platform deployment strategies for production scalability
- Set up CI/CD pipelines for automated testing and deployment workflows
- Configure monitoring and alerting for educational platform health and performance
- Implement database migration strategies for educational data integrity
- Design backup and disaster recovery procedures for student progress and content
- Optimize cloud infrastructure costs while maintaining educational service quality
- Create deployment documentation and runbooks for operational excellence

WORKFLOW:
1. Analyze application architecture and deployment requirements
2. Design containerization strategy for educational platform services
3. Create local development environment with service orchestration
4. Design cloud infrastructure for production deployment
5. Implement CI/CD pipelines with automated testing and security scanning
6. Set up monitoring, logging, and alerting systems
7. Create operational documentation and incident response procedures

COMMUNICATION WITH OTHER AGENTS:
- Agent Lead: Coordinate deployment milestones and infrastructure decisions
- Backend Agent: Containerize Node.js/TypeScript services, database connections, API deployment
- Frontend Agent: Build React applications, static asset deployment, CDN configuration
- Database Agent: Database migration automation, backup strategies, performance monitoring
- Testing Agent: Integrate testing pipelines, environment provisioning for test automation
- Docs Writer: Document deployment procedures, infrastructure setup, operational runbooks

PLATFORM-SPECIFIC FOCUS:
- Multi-tenant educational platform deployment with tenant isolation
- Video streaming infrastructure optimization (CDN, edge caching, bandwidth management)
- AI service integration deployment (OpenAI, Claude API orchestration)
- Student progress data backup and disaster recovery procedures
- Educational compliance infrastructure (GDPR, data retention automation)
- Session management across distributed educational services
- Auto-scaling for concurrent student video streaming and question answering

DEPLOYMENT ENVIRONMENTS:
- Local Development: Docker Compose with hot-reload for full-stack development
- Staging Environment: Google Cloud with production-like configuration for testing
- Production Environment: Auto-scaling Google Cloud infrastructure with high availability
- Testing Environment: Isolated environments for automated testing and QA

SECURITY FOCUS:
- Container security scanning and vulnerability management
- Secret management for AI APIs, database credentials, and service keys
- Network security and firewall configuration for educational data protection
- SSL/TLS certificate management and HTTPS enforcement
- Container image hardening and minimal attack surface
- Educational data encryption in transit and at rest

DELIVERABLES:
- Docker configurations for Node.js/TypeScript backend, React frontend, PostgreSQL database
- Docker Compose setup for local full-stack educational platform development
- Google Cloud Platform infrastructure as code (Terraform/Cloud Deployment Manager)
- CI/CD pipeline configurations (GitHub Actions) with automated testing and deployment
- Monitoring and alerting setup for educational platform observability
- Database migration and backup automation scripts
- Production deployment guides and operational runbooks
- Cost optimization reports and infrastructure scaling strategies

MONITORING AND OBSERVABILITY:
- Educational platform performance metrics (video streaming, question response times)
- Student engagement analytics and system usage monitoring
- Database performance monitoring for educational data queries
- AI service usage tracking and cost monitoring
- Security monitoring and incident detection for educational data protection
- Auto-scaling triggers based on concurrent student usage patterns

DISASTER RECOVERY:
- Student progress data backup and restoration procedures
- Educational content backup strategies (videos, questions, lessons)
- Database failover and recovery automation
- Service redundancy and high availability configuration
- Incident response procedures for educational platform outages
</file>

<file path=".claude/agents/docs-writer-agent.txt">
You are the Documentation Writer Agent in a multi-agent coding system specializing in the Interactive Learning Platform. You focus on educational technology documentation for students, teachers, and developers.

EXPERTISE:
- Educational platform documentation (user guides for teachers, students, admins)
- Node.js/TypeScript API documentation with OpenAPI/Swagger
- React/TypeScript component documentation with Storybook
- Video annotation and milestone creation guides
- AI integration documentation for question generation workflows
- Multi-tenant system administration and configuration guides
- Educational compliance documentation (GDPR, accessibility, data protection)
- Learning analytics and progress tracking documentation

RESPONSIBILITIES:
- Document teacher workflows (video upload, milestone annotation, question approval)
- Create student user guides for interactive learning and progress tracking
- Document admin interfaces for user management and system configuration
- Write developer guides for Node.js/TypeScript backend and React frontend
- Document AI integration patterns and multi-provider configuration
- Create video annotation tutorials and content creation best practices
- Document PostgreSQL schema and educational data models
- Write compliance guides for GDPR and educational data protection

DOCUMENTATION TYPES:
1. API Documentation: Endpoints, parameters, responses, examples
2. Code Documentation: Functions, classes, modules, inline comments
3. User Documentation: Guides, tutorials, feature explanations
4. Developer Documentation: Setup, architecture, contributing guidelines
5. Deployment Documentation: Environment setup, CI/CD processes
6. Operational Documentation: Monitoring, troubleshooting, maintenance

WORKFLOW:
1. Gather information from all agents about their implementations
2. Structure documentation hierarchically and logically
3. Write clear, concise content with practical examples
4. Create diagrams and visual aids where helpful
5. Review and update documentation as code evolves
6. Ensure consistency in tone, style, and formatting
7. Validate documentation accuracy through testing

COMMUNICATION WITH OTHER AGENTS:
- Agent Lead: Document system architecture and project decisions
- Front-End Agent: Create component documentation and style guides
- Back-End Agent: Document API specifications and deployment procedures
- Database Agent: Document schema, migrations, and data access patterns
- Testing Agent: Document testing procedures and quality standards
- DevOps Agent: Document deployment procedures, infrastructure setup, and operational runbooks

DOCUMENTATION STANDARDS:
- Clear, concise writing with actionable instructions
- Consistent formatting and structure
- Code examples with expected outputs
- Screenshots and diagrams for visual clarity
- Version control for documentation changes
- Regular review and updates

PLATFORM-SPECIFIC FOCUS:
- Multi-role user documentation (students learn, teachers create, admins manage)
- Interactive video learning workflows and milestone-based progression
- AI question generation processes and approval workflows
- Educational data analytics and progress reporting
- Content creation tools and video annotation systems
- Cross-device learning continuity and session management
- Educational accessibility compliance and inclusive design

DELIVERABLES:
- Teacher guides for content creation and video annotation
- Student tutorials for interactive learning and progress tracking
- Admin documentation for user management and system configuration
- Developer guides for TypeScript/React/Node.js/PostgreSQL stack
- API documentation for educational platform endpoints
- Video milestone and question generation workflow documentation
- Database schema documentation for educational data models
- Compliance guides for educational data protection and accessibility
- Deployment guides for Google Cloud Storage and AI API integration
</file>

<file path=".claude/agents/frontend-agent.txt">
You are the Front-End Agent in a multi-agent coding system specializing in the Interactive Learning Platform. You focus on React/TypeScript development for educational technology interfaces.

EXPERTISE:
- React.js with TypeScript for educational platform components
- Interactive video player development with milestone integration
- Educational UI/UX patterns (progress tracking, quiz interfaces, dashboards)
- State management for video progress and user sessions (React Query, Zustand)
- Responsive design for multi-device learning (mobile, tablet, desktop)
- Real-time updates for progress tracking and collaborative learning
- Accessibility for educational content (WCAG, screen readers, keyboard navigation)
- Performance optimization for video streaming and concurrent users

RESPONSIBILITIES:
- Build interactive video player with milestone pause/resume functionality
- Create question overlay components with multiple question types
- Implement role-based dashboards (student progress, teacher analytics, admin management)
- Develop video annotation tools for teachers to mark milestones
- Build progress tracking visualizations and learning analytics displays
- Create responsive interfaces for mobile learning and cross-device continuity
- Implement real-time session persistence and progress synchronization
- Design accessible educational interfaces compliant with accessibility standards

WORKFLOW:
1. Review UI/UX requirements and mockups
2. Plan component architecture and state management approach
3. Implement components following established patterns
4. Integrate with backend APIs using proper error handling
5. Test functionality across browsers and devices
6. Optimize bundle size and loading performance
7. Ensure accessibility compliance and SEO optimization

COMMUNICATION WITH OTHER AGENTS:
- Backend Agent: Define API contracts, data formats, and authentication flows
- Testing Agent: Provide testable components and assist with E2E test setup
- Database Agent: Understand data structures for optimal client-side handling
- DevOps Agent: Specify build requirements, static asset optimization, and deployment configurations
- Docs Writer: Document component APIs and usage guidelines

PLATFORM-SPECIFIC FOCUS:
- Interactive video player with precise milestone timing control
- Multi-role user interfaces (student learning, teacher creation, admin management)
- Question generation and review interfaces for teachers
- Progress dashboards with real-time analytics and reporting
- Mobile-first responsive design for multi-device learning
- Session management for cross-device learning continuity
- Educational accessibility features and compliance

DELIVERABLES:
- React/TypeScript components for interactive video learning
- Custom video player with milestone integration and question overlays
- Role-based dashboard interfaces (student/teacher/admin)
- Video annotation tools for content creators
- Progress tracking components with real-time updates
- Mobile-responsive educational interface components
- Accessible quiz and question components with keyboard navigation
- Performance-optimized builds for concurrent video streaming
</file>

<file path=".claude/agents/testing-agent.txt">
You are the Testing Agent in a multi-agent coding system specializing in the Interactive Learning Platform. You focus on educational technology testing with emphasis on video interactions and learning workflows.

EXPERTISE:
- Jest/React Testing Library for React/TypeScript component testing
- Node.js/TypeScript API testing with Supertest and Jest
- Cypress/Playwright for educational user workflows (student learning, teacher creation)
- Video player testing and milestone interaction validation
- Educational data integrity testing (progress tracking, grading systems)
- Multi-role user testing (student/teacher/admin workflow validation)
- AI integration testing for question generation and approval workflows
- Performance testing for concurrent video streaming and user sessions

RESPONSIBILITIES:
- Test interactive video player functionality (pause/resume at milestones)
- Validate question generation workflows and AI integration
- Test multi-role user authentication and authorization (student/teacher/admin)
- Create E2E tests for complete learning workflows (video → questions → progress)
- Test video annotation tools and milestone creation for teachers
- Validate progress tracking accuracy and cross-device session persistence
- Test educational data integrity (grades, attempts, completion tracking)
- Performance testing for concurrent students and video streaming

TESTING LEVELS:
1. Unit Tests: Individual functions, components, and modules
2. Integration Tests: API endpoints, database operations, service interactions
3. End-to-End Tests: Complete user workflows and critical paths
4. Performance Tests: Load, stress, and scalability testing
5. Security Tests: Vulnerability scanning and penetration testing
6. Accessibility Tests: WCAG compliance and usability testing

WORKFLOW:
1. Review requirements and identify testable scenarios
2. Create test plans and testing strategies
3. Write unit tests alongside development
4. Implement integration tests for API contracts
5. Create E2E tests for user workflows
6. Set up performance and load testing
7. Generate test reports and track metrics

COMMUNICATION WITH OTHER AGENTS:
- Front-End Agent: Test component behavior, user interactions, and accessibility
- Back-End Agent: Validate API contracts, error handling, and performance
- Database Agent: Test data integrity, migrations, and query performance
- DevOps Agent: Integrate testing into CI/CD pipelines, test environment provisioning
- Docs Writer: Document testing procedures and quality standards

QUALITY METRICS:
- Code coverage thresholds
- Test execution time and reliability
- Bug detection and resolution rates
- Performance benchmarks and SLA compliance
- Security vulnerability assessments

PLATFORM-SPECIFIC FOCUS:
- Interactive learning workflow testing (video progression, question answering)
- Educational role-based testing (student learning paths, teacher content creation)
- Video milestone accuracy and timing validation
- AI question generation quality and approval process testing
- Multi-device learning continuity and session management testing
- Educational data compliance testing (GDPR, data retention)
- Accessibility testing for educational content and interfaces

DELIVERABLES:
- Jest/React Testing Library test suites for educational components
- Supertest API tests for Node.js/TypeScript educational endpoints
- Cypress E2E tests for complete student and teacher workflows
- Video player interaction tests and milestone validation
- Performance tests for concurrent video streaming and user sessions
- Educational data integrity tests (progress, grades, completion tracking)
- Multi-role authorization and access control test suites
- AI integration test suites for question generation workflows
- Educational accessibility and compliance test automation
</file>

<file path=".serena/memories/code_style_and_conventions.md">
# Code Style and Conventions

## TypeScript Configuration
- **Strict Mode**: All TypeScript strict options enabled
- **Target**: ES2022 with modern JavaScript features
- **Module**: CommonJS for Node.js compatibility
- **Path Aliases**: Clean imports using `@/*` patterns for organized code structure

## Code Structure Patterns

### Directory Organization
```typescript
src/
├── config/         // Environment, database, and system configuration
├── controllers/    // HTTP request handlers (thin layer)
├── middleware/     // Express middleware (auth, security, logging, error handling)
├── models/         // Data models and TypeScript interfaces
├── routes/         // API route definitions and routing logic
├── services/       // Business logic and external service integrations
├── utils/          // Helper utilities and common functions
├── validators/     // Input validation schemas (likely using Zod)
└── types/          // TypeScript type definitions
```

### Import Patterns
```typescript
// External libraries first
import express from 'express';
import { PrismaClient } from '@prisma/client';

// Internal imports with path aliases
import { environment } from '@/config/environment';
import { logger } from '@/utils/logger';
import { AuthService } from '@/services/auth';
```

### Express.js Application Structure
- **Security-First**: Helmet, CORS, rate limiting as standard middleware
- **Comprehensive Logging**: Morgan for HTTP requests, Winston for application logs
- **Error Handling**: Centralized error handling with custom middleware
- **Modular Routes**: Separate route files imported into main routes index
- **Socket.IO Integration**: Real-time features with proper CORS configuration

## Naming Conventions

### Files and Directories
- **camelCase** for TypeScript files: `userController.ts`
- **kebab-case** for configuration: `.env.development`
- **Descriptive names** that indicate purpose: `errorHandler.ts`, `rateLimitMiddleware.ts`

### Variables and Functions
- **camelCase** for variables and functions
- **PascalCase** for classes and interfaces
- **UPPER_SNAKE_CASE** for constants and environment variables

### Database Schema (Prisma)
- **PascalCase** for model names: `User`, `VideoMilestone`
- **camelCase** for field names: `firstName`, `createdAt`
- **UPPER_CASE** for enums: `UserRole`, `UserStatus`

## TypeScript Best Practices

### Type Safety
```typescript
// Strict typing with interfaces
interface CreateUserRequest {
  email: string;
  firstName: string;
  lastName: string;
  role?: UserRole;
}

// Runtime validation with Zod (likely pattern based on dependencies)
import { z } from 'zod';

const CreateUserSchema = z.object({
  email: z.string().email(),
  firstName: z.string().min(1),
  lastName: z.string().min(1)
});
```

### Error Handling
```typescript
// Structured error responses
class AppError extends Error {
  statusCode: number;
  isOperational: boolean;
  
  constructor(message: string, statusCode: number) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;
  }
}
```

### Async/Await Pattern
```typescript
// Consistent async/await usage (no callbacks or .then chains)
export const getUserById = async (id: string): Promise<User | null> => {
  try {
    const user = await prisma.user.findUnique({ where: { id } });
    return user;
  } catch (error) {
    logger.error('Failed to fetch user', { id, error });
    throw new AppError('User fetch failed', 500);
  }
};
```

## Security Patterns
- **JWT Authentication**: Secure token-based authentication
- **Password Hashing**: bcrypt for secure password storage
- **Input Validation**: Comprehensive request validation
- **Rate Limiting**: API endpoint protection
- **CORS Configuration**: Proper cross-origin resource sharing setup
- **Security Headers**: Helmet middleware for security headers

## Database Patterns
- **Multi-tenant Architecture**: Tenant isolation in data models
- **Soft Deletes**: Avoid hard deletion of user data
- **Audit Fields**: createdAt, updatedAt, deletedAt tracking
- **Relationship Modeling**: Clear foreign key relationships
- **Migration-First**: Schema changes through Prisma migrations

## Logging and Monitoring
- **Structured Logging**: Winston with JSON format for production
- **Request Logging**: Morgan for HTTP request/response tracking
- **Error Context**: Include relevant context in error logs
- **Performance Tracking**: Log execution times for critical operations
</file>

<file path=".serena/memories/multi_agent_architecture.md">
# Multi-Agent Architecture Guide

## Agent Specializations

### 1. Agent Lead (Orchestration)
- **Role**: Coordinates all other agents and manages task dependencies
- **Responsibilities**: 
  - Requirement analysis and task breakdown
  - Dependency mapping across agents
  - Parallel coordination for efficiency
  - Integration management and quality validation
  - Progress tracking with milestone indicators

### 2. Backend Agent (Node.js/TypeScript)
- **Role**: Server-side development and API implementation
- **Focus Areas**:
  - Educational APIs and authentication systems
  - Video milestone tracking and streaming optimization
  - AI integration layer with configurable providers (OpenAI, Claude)
  - Multi-tenant architecture with role-based permissions
- **Technologies**: Express.js, Prisma, PostgreSQL, JWT, Socket.IO

### 3. Frontend Agent (React/TypeScript)
- **Role**: User interface development
- **Focus Areas**:
  - Interactive video player with educational overlays
  - Role-based dashboards (student/teacher/admin)
  - Mobile-responsive educational interfaces
  - Real-time progress tracking and analytics displays
- **Technologies**: React, TypeScript, responsive design

### 4. Database Agent (PostgreSQL)
- **Role**: Database design and optimization
- **Focus Areas**:
  - Educational data modeling (users, lessons, progress)
  - Video metadata and milestone optimization
  - Multi-tenant data isolation patterns
  - Learning analytics and reporting schemas
- **Technologies**: PostgreSQL, Prisma Schema, migrations

### 5. Testing Agent (Quality Assurance)
- **Role**: Comprehensive testing strategies
- **Focus Areas**:
  - Video interaction and milestone validation
  - Educational workflow testing (complete learning paths)
  - Multi-role authorization and access control testing
  - Performance testing for concurrent video streaming
- **Technologies**: Jest, Supertest, load testing tools

### 6. DevOps Agent (Infrastructure)
- **Role**: Deployment and infrastructure management
- **Focus Areas**:
  - Docker containerization for educational platform services
  - Local development environment automation with Docker Compose
  - Google Cloud Platform deployment and infrastructure as code
  - CI/CD pipelines with automated testing and security scanning
  - Monitoring and observability for educational platform health
- **Technologies**: Docker, GCP, CI/CD, monitoring tools

### 7. Docs Writer Agent (Documentation)
- **Role**: Comprehensive documentation creation
- **Focus Areas**:
  - User guides for teachers, students, and administrators
  - Developer documentation for TypeScript/React/Node.js stack
  - Educational compliance and accessibility guides
  - API documentation and deployment procedures

## Agent Invocation Protocol

### Standard Format
```
@[AGENT_NAME] - TASK: [specific task]
CONTEXT: [relevant background]
DEPENDENCIES: [what this task depends on]
DELIVERABLES: [expected outputs]
PRIORITY: [high/medium/low]
```

### Example Multi-Agent Coordination
```
@database-agent - TASK: Add lesson prerequisite system to schema
CONTEXT: Teachers need to set learning path dependencies
DEPENDENCIES: Current schema analysis complete
DELIVERABLES: Updated Prisma schema with prerequisite relationships
PRIORITY: high

@backend-agent - TASK: Implement prerequisite validation APIs
CONTEXT: Enforce learning path requirements
DEPENDENCIES: Database schema updated with prerequisites
DELIVERABLES: API endpoints for prerequisite checking and enforcement
PRIORITY: high

@frontend-agent - TASK: Create prerequisite selection UI for teachers
CONTEXT: Teachers need interface to set course dependencies
DEPENDENCIES: Backend prerequisite APIs implemented
DELIVERABLES: React components for prerequisite management
PRIORITY: high

@testing-agent - TASK: Validate prerequisite enforcement workflows
CONTEXT: Ensure learning path dependencies work correctly
DEPENDENCIES: Frontend and backend prerequisite features complete
DELIVERABLES: Test suites for prerequisite functionality
PRIORITY: medium
```

## Development Phases & Dependencies

### Phase 1: Foundation (Database + Backend)
**Critical Path**: Database schema → Backend APIs → Frontend contracts

**Database Agent Tasks**:
- Multi-role educational schema design
- Multi-tenant data isolation patterns
- Migration scripts with zero-downtime strategy
- Optimized indexes for video and progress queries

**Backend Agent Tasks**:
- JWT authentication with role-based middleware
- Core user management APIs
- Google Cloud Storage integration
- Video milestone tracking APIs

### Phase 2: Interactive Learning (Frontend + AI)
**Critical Path**: Core APIs → Video player → AI integration → Question workflows

**Frontend Agent Tasks**:
- Interactive video player with milestone functionality
- Role-based dashboards and responsive interfaces
- Question overlay components

**Backend Agent Tasks**:
- Multi-AI provider abstraction layer
- Question generation with approval workflows
- Real-time progress tracking endpoints
- Video streaming optimization

### Phase 3: Quality & Deployment
**Critical Path**: Feature completion → Testing → Containerization → Deployment → Documentation

**Testing Agent Tasks**:
- Comprehensive educational workflow testing
- Multi-role authorization testing
- Performance testing for concurrent users

**DevOps Agent Tasks**:
- Docker containerization
- Local development environment
- GCP infrastructure and CI/CD
- Monitoring and observability

**Docs Writer Agent Tasks**:
- User guides for all roles
- Developer documentation
- Deployment and infrastructure guides

## Integration Points & Quality Gates

### Critical Integration Points
1. **Video + AI Workflow**: Player → Milestone detection → AI questions → Approval
2. **Multi-Tenant Architecture**: Database isolation → Backend authorization → Frontend UI
3. **Real-Time Analytics**: Database tracking → Backend APIs → Frontend dashboards
4. **Cross-Device Sessions**: Database persistence → Backend management → Frontend sync

### Quality Gates
- **Before Phase 2**: Database validated, authentication tested, GCS integration confirmed
- **Before Phase 3**: Video player functional, AI workflow operational, dashboards active
- **Before Production**: End-to-end workflows tested, performance benchmarks met, security audited
</file>

<file path=".serena/memories/project_overview.md">
# Interactive Learning Platform - Project Overview

## Purpose
Interactive video-based learning system that pauses at key milestones to present AI-generated questions. Students must answer correctly to continue, creating an engaging and validated learning experience.

## Architecture
- **Multi-Agent Development System**: 7 specialized agents (Agent Lead, Backend, Frontend, Database, Testing, DevOps, Docs Writer)
- **Multi-Role Platform**: Students, Teachers, and Administrators with role-based access control
- **Video-Centric Learning**: Interactive video player with milestone-based question overlays
- **AI Integration**: Multi-provider AI (OpenAI, Claude) for automated question generation
- **Multi-Tenant Architecture**: Supports multiple organizations/schools on single platform

## Key Features
- Interactive video player with milestone pause/resume functionality
- AI-generated questions with teacher approval workflows
- Cross-device session persistence and progress tracking
- Real-time analytics and reporting dashboards
- Educational compliance (GDPR, accessibility)
- Multi-provider AI integration with configurable providers

## Directory Structure
```
education-platform/
├── src/                    # Backend TypeScript source code
│   ├── config/            # Environment and database configuration
│   ├── controllers/       # HTTP request handlers
│   ├── middleware/        # Express middleware (auth, security, logging)
│   ├── models/           # Data models and types
│   ├── routes/           # API route definitions
│   ├── services/         # Business logic and external integrations
│   ├── utils/            # Helper utilities
│   ├── validators/       # Input validation schemas
│   └── index.ts         # Application entry point
├── database/             # Database-related files
│   ├── prisma/          # Prisma schema and migrations
│   └── seeds/           # Database seeding scripts
├── frontend/            # React frontend application
├── tests/              # Test suites
├── scripts/            # Development and deployment scripts
├── logs/               # Application logs
├── uploads/            # File uploads storage
├── .claude/            # Claude Code agent configurations
└── dist/               # Compiled TypeScript output
```
</file>

<file path=".serena/memories/suggested_commands.md">
# Suggested Commands for Development

## Development Workflow
```bash
# Install dependencies
npm install

# Start development server with hot reload
npm run dev

# Build TypeScript to JavaScript
npm run build

# Start production server
npm start
```

## Database Operations
```bash
# Generate Prisma client after schema changes
npm run db:generate

# Run database migrations in development
npm run db:migrate

# Deploy migrations to production
npm run db:deploy

# Open Prisma Studio for database management
npm run db:studio

# Seed database with initial data
npm run db:seed

# Reset database (WARNING: destructive)
npm run db:reset

# Push schema changes without migration
npm run db:push
```

## Code Quality & Testing
```bash
# Run TypeScript type checking
npm run type-check

# Lint code with ESLint
npm run lint

# Fix linting issues automatically
npm run lint:fix

# Run test suite
npm test

# Run tests in watch mode
npm run test:watch

# Run tests with coverage report
npm run test:coverage
```

## Docker Development Environment
```bash
# Set up development environment
npm run dev:setup

# Start Docker containers (PostgreSQL, Redis)
npm run dev:up

# Stop Docker containers
npm run dev:down

# View Docker logs
npm run dev:logs

# Restart Docker containers
npm run dev:restart

# Reset Docker environment (WARNING: destroys data)
npm run dev:reset

# Start only database and Redis containers
npm run dev:db-only

# Clean up Docker resources
npm run dev:clean

# Test API endpoints
npm run dev:test
```

## Task Completion Commands
After completing any development task, always run these commands to ensure code quality:

```bash
# 1. Type checking (REQUIRED)
npm run type-check

# 2. Linting (REQUIRED)
npm run lint

# 3. Run tests (REQUIRED)
npm test

# 4. If tests pass, build the project
npm run build
```

## System Utilities (macOS/Darwin)
```bash
# File operations
ls -la          # List files with details
find . -name    # Find files by name
grep -r         # Search in files recursively
cp -r           # Copy directories recursively
mv              # Move/rename files
rm -rf          # Remove directories recursively

# Git operations
git status      # Check repository status
git add .       # Stage all changes
git commit -m   # Commit with message
git push        # Push to remote
git pull        # Pull from remote
git branch      # List branches
```

## Environment Setup
```bash
# Copy environment template
cp .env.example .env

# Edit environment variables
nano .env

# Ensure proper Node.js version
node --version  # Should be >= 18.0.0
npm --version   # Should be >= 9.0.0
```
</file>

<file path=".serena/memories/task_completion_checklist.md">
# Task Completion Checklist

## Required Commands After Any Code Changes

### 1. Type Checking (MANDATORY)
```bash
npm run type-check
```
- **Purpose**: Ensures TypeScript type safety and catches compilation errors
- **When**: After ANY code modification
- **Failure Action**: Fix all TypeScript errors before proceeding

### 2. Linting (MANDATORY)
```bash
npm run lint
```
- **Purpose**: Enforces code style and catches potential issues
- **Automatic Fix**: Use `npm run lint:fix` for auto-fixable issues
- **When**: After ANY code modification
- **Failure Action**: Fix all linting errors manually or with auto-fix

### 3. Testing (MANDATORY)
```bash
npm test
```
- **Purpose**: Validates functionality and prevents regressions
- **Coverage**: Use `npm run test:coverage` for coverage reports
- **When**: After ANY functional changes
- **Failure Action**: Fix failing tests before considering task complete

### 4. Build Verification (RECOMMENDED)
```bash
npm run build
```
- **Purpose**: Confirms production build succeeds
- **When**: After significant changes or before deployment
- **Failure Action**: Resolve build errors

## Pre-Commit Checklist

### Code Quality Gates
- [ ] All TypeScript errors resolved (`npm run type-check`)
- [ ] All ESLint issues fixed (`npm run lint`)
- [ ] All tests passing (`npm test`)
- [ ] Build succeeds without warnings (`npm run build`)

### Database Changes
- [ ] Prisma client regenerated if schema changed (`npm run db:generate`)
- [ ] Migration created and tested (`npm run db:migrate`)
- [ ] Seed data updated if needed (`npm run db:seed`)

### Security Checklist
- [ ] No sensitive data (passwords, API keys) in code
- [ ] Input validation implemented for new endpoints
- [ ] Authentication/authorization checks in place
- [ ] Rate limiting configured for new public endpoints

### Educational Platform Specific
- [ ] Multi-role access control tested
- [ ] Video milestone functionality validated
- [ ] AI integration error handling implemented
- [ ] Cross-device session persistence working
- [ ] Progress tracking updates correctly

## Development Environment Validation

### Docker Environment
```bash
# Ensure development environment is running
npm run dev:up

# Check container health
npm run dev:logs

# Test API endpoints
npm run dev:test
```

### Database Integrity
```bash
# Verify database connection
npm run db:studio

# Check migration status
npx prisma migrate status --schema=database/prisma/schema.prisma

# Validate seed data
npm run db:seed
```

## Performance Considerations
- [ ] Database queries optimized with proper indexes
- [ ] Large file uploads handled efficiently
- [ ] Video streaming performance tested
- [ ] Concurrent user load considered
- [ ] Memory leaks checked for long-running processes

## Documentation Updates
- [ ] API changes documented
- [ ] New environment variables added to `.env.example`
- [ ] README updated if setup process changed
- [ ] Type interfaces documented for complex data structures

## Multi-Agent Coordination
- [ ] Agent dependencies identified and communicated
- [ ] Integration points tested between agents
- [ ] Quality gates passed before handoff to next agent
- [ ] Progress tracked and reported to Agent Lead
</file>

<file path=".serena/memories/tech_stack_and_dependencies.md">
# Tech Stack and Dependencies

## Core Technologies
- **Runtime**: Node.js >= 18.0.0
- **Language**: TypeScript with strict configuration
- **Backend Framework**: Express.js with comprehensive middleware stack
- **Database**: PostgreSQL with Prisma ORM
- **Frontend**: React/TypeScript (separate application)
- **Real-time**: Socket.IO for real-time features
- **File Storage**: Google Cloud Storage for video content
- **Authentication**: JWT with bcrypt password hashing

## Key Dependencies

### Backend Core
- `express` - Web application framework
- `prisma` + `@prisma/client` - Database ORM and client
- `typescript` - Type-safe JavaScript
- `tsx` - TypeScript execution and watch mode
- `zod` - Runtime type validation
- `dotenv` - Environment variable management

### Security & Middleware
- `helmet` - Security headers middleware
- `cors` - Cross-origin resource sharing
- `express-rate-limit` - Rate limiting
- `express-validator` - Input validation
- `bcrypt` - Password hashing
- `jsonwebtoken` - JWT token handling
- `compression` - Response compression
- `morgan` - HTTP request logging

### AI & External Services
- `openai` - OpenAI API integration
- `@anthropic-ai/sdk` - Claude API integration
- `@google-cloud/storage` - Google Cloud Storage
- `axios` - HTTP client for external APIs

### Utilities
- `winston` - Structured logging
- `multer` - File upload handling
- `redis` - Caching and session storage
- `node-cron` - Scheduled tasks
- `uuid` - Unique identifier generation
- `socket.io` - WebSocket communication

### Development Tools
- `@typescript-eslint/*` - TypeScript ESLint configuration
- `jest` + `@types/jest` - Testing framework
- `supertest` - HTTP testing
- `nodemon` - Development file watching
- `prisma` - Database migrations and studio

## TypeScript Configuration
- Target: ES2022 with strict type checking
- Module system: CommonJS
- Path aliases for clean imports (`@/*` patterns)
- Declaration files and source maps enabled
- Strict null checks and function types
- No unused locals or parameters enforced
</file>

<file path=".serena/project.yml">
# language of the project (csharp, python, rust, java, typescript, go, cpp, or ruby)
#  * For C, use cpp
#  * For JavaScript, use typescript
# Special requirements:
#  * csharp: Requires the presence of a .sln file in the project folder.
language: typescript

# whether to use the project's gitignore file to ignore files
# Added on 2025-04-07
ignore_all_files_in_gitignore: true
# list of additional paths to ignore
# same syntax as gitignore, so you can use * and **
# Was previously called `ignored_dirs`, please update your config if you are using that.
# Added (renamed)on 2025-04-07
ignored_paths: []

# whether the project is in read-only mode
# If set to true, all editing tools will be disabled and attempts to use them will result in an error
# Added on 2025-04-18
read_only: false


# list of tool names to exclude. We recommend not excluding any tools, see the readme for more details.
# Below is the complete list of tools for convenience.
# To make sure you have the latest list of tools, and to view their descriptions, 
# execute `uv run scripts/print_tool_overview.py`.
#
#  * `activate_project`: Activates a project by name.
#  * `check_onboarding_performed`: Checks whether project onboarding was already performed.
#  * `create_text_file`: Creates/overwrites a file in the project directory.
#  * `delete_lines`: Deletes a range of lines within a file.
#  * `delete_memory`: Deletes a memory from Serena's project-specific memory store.
#  * `execute_shell_command`: Executes a shell command.
#  * `find_referencing_code_snippets`: Finds code snippets in which the symbol at the given location is referenced.
#  * `find_referencing_symbols`: Finds symbols that reference the symbol at the given location (optionally filtered by type).
#  * `find_symbol`: Performs a global (or local) search for symbols with/containing a given name/substring (optionally filtered by type).
#  * `get_current_config`: Prints the current configuration of the agent, including the active and available projects, tools, contexts, and modes.
#  * `get_symbols_overview`: Gets an overview of the top-level symbols defined in a given file or directory.
#  * `initial_instructions`: Gets the initial instructions for the current project.
#     Should only be used in settings where the system prompt cannot be set,
#     e.g. in clients you have no control over, like Claude Desktop.
#  * `insert_after_symbol`: Inserts content after the end of the definition of a given symbol.
#  * `insert_at_line`: Inserts content at a given line in a file.
#  * `insert_before_symbol`: Inserts content before the beginning of the definition of a given symbol.
#  * `list_dir`: Lists files and directories in the given directory (optionally with recursion).
#  * `list_memories`: Lists memories in Serena's project-specific memory store.
#  * `onboarding`: Performs onboarding (identifying the project structure and essential tasks, e.g. for testing or building).
#  * `prepare_for_new_conversation`: Provides instructions for preparing for a new conversation (in order to continue with the necessary context).
#  * `read_file`: Reads a file within the project directory.
#  * `read_memory`: Reads the memory with the given name from Serena's project-specific memory store.
#  * `remove_project`: Removes a project from the Serena configuration.
#  * `replace_lines`: Replaces a range of lines within a file with new content.
#  * `replace_symbol_body`: Replaces the full definition of a symbol.
#  * `restart_language_server`: Restarts the language server, may be necessary when edits not through Serena happen.
#  * `search_for_pattern`: Performs a search for a pattern in the project.
#  * `summarize_changes`: Provides instructions for summarizing the changes made to the codebase.
#  * `switch_modes`: Activates modes by providing a list of their names
#  * `think_about_collected_information`: Thinking tool for pondering the completeness of collected information.
#  * `think_about_task_adherence`: Thinking tool for determining whether the agent is still on track with the current task.
#  * `think_about_whether_you_are_done`: Thinking tool for determining whether the task is truly completed.
#  * `write_memory`: Writes a named memory (for future reference) to Serena's project-specific memory store.
excluded_tools: []

# initial prompt for the project. It will always be given to the LLM upon activating the project
# (contrary to the memories, which are loaded on demand).
initial_prompt: ""

project_name: "education-platform"
</file>

<file path="database/init-scripts/01-init-db.sql">
-- Interactive Learning Platform - Database Initialization
-- This script runs after PostgreSQL container startup

-- Create the main database if it doesn't exist
SELECT 'CREATE DATABASE interactive_learning'
WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'interactive_learning');

-- Connect to the main database
\c interactive_learning;

-- Create extensions if they don't exist
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";
CREATE EXTENSION IF NOT EXISTS "btree_gin";

-- Create a development user with appropriate permissions
DO
$do$
BEGIN
   IF NOT EXISTS (
      SELECT FROM pg_catalog.pg_roles
      WHERE  rolname = 'dev_user') THEN

      CREATE ROLE dev_user LOGIN PASSWORD 'dev_password';
   END IF;
END
$do$;

-- Grant permissions to dev_user
GRANT CONNECT ON DATABASE interactive_learning TO dev_user;
GRANT USAGE ON SCHEMA public TO dev_user;
GRANT CREATE ON SCHEMA public TO dev_user;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO dev_user;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO dev_user;

-- Set default privileges for future tables
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO dev_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO dev_user;

-- Log successful initialization
SELECT 'Database initialized successfully' AS status;
</file>

<file path="database/init-scripts/02-run-migrations.sh">
#!/bin/bash
# Run database migrations after initialization

set -e

echo "Running database migrations..."

# Wait for PostgreSQL to be ready
until pg_isready -h localhost -p 5432 -U postgres; do
    echo "Waiting for PostgreSQL to be ready..."
    sleep 2
done

# Run initial schema migration
if [ -f "/docker-entrypoint-initdb.d/migrations/001_initial_schema.sql" ]; then
    echo "Running initial schema migration..."
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" < /docker-entrypoint-initdb.d/migrations/001_initial_schema.sql
fi

# Run performance indexes migration
if [ -f "/docker-entrypoint-initdb.d/migrations/002_performance_indexes.sql" ]; then
    echo "Running performance indexes migration..."
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" < /docker-entrypoint-initdb.d/migrations/002_performance_indexes.sql
fi

echo "Database migrations completed successfully!"
</file>

<file path="database/migrations/001_initial_schema.sql">
-- Interactive Learning Platform - Initial Database Schema
-- PostgreSQL Migration Script
-- Generated: 2025-08-07

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm"; -- For text search optimization
CREATE EXTENSION IF NOT EXISTS "btree_gin"; -- For better JSONB indexing

-- ========================================
-- ENUMS
-- ========================================

CREATE TYPE "UserRole" AS ENUM ('STUDENT', 'TEACHER', 'ADMIN');
CREATE TYPE "UserStatus" AS ENUM ('ACTIVE', 'INACTIVE', 'SUSPENDED', 'PENDING_VERIFICATION');
CREATE TYPE "LessonStatus" AS ENUM ('DRAFT', 'PUBLISHED', 'ARCHIVED');
CREATE TYPE "VideoStatus" AS ENUM ('UPLOADING', 'PROCESSING', 'READY', 'ERROR');
CREATE TYPE "QuestionType" AS ENUM ('MULTIPLE_CHOICE', 'TRUE_FALSE', 'SHORT_ANSWER', 'FILL_IN_BLANK', 'MATCHING', 'ORDERING');
CREATE TYPE "QuestionStatus" AS ENUM ('AI_GENERATED', 'PENDING_REVIEW', 'APPROVED', 'REJECTED', 'NEEDS_REVISION');
CREATE TYPE "SessionStatus" AS ENUM ('ACTIVE', 'PAUSED', 'COMPLETED', 'ABANDONED');
CREATE TYPE "AttemptStatus" AS ENUM ('IN_PROGRESS', 'SUBMITTED', 'CORRECT', 'INCORRECT', 'PARTIAL', 'TIMEOUT');
CREATE TYPE "GradeStatus" AS ENUM ('IN_PROGRESS', 'COMPLETED', 'FAILED', 'RETRY_ALLOWED');
CREATE TYPE "AuditAction" AS ENUM ('CREATE', 'UPDATE', 'DELETE', 'LOGIN', 'LOGOUT', 'VIEW', 'DOWNLOAD', 'UPLOAD');
CREATE TYPE "AIProvider" AS ENUM ('OPENAI', 'CLAUDE', 'GOOGLE_PALM', 'CUSTOM');

-- ========================================
-- CORE TABLES
-- ========================================

-- Users table with multi-tenant support
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "username" TEXT,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "avatar" TEXT,
    "role" "UserRole" NOT NULL DEFAULT 'STUDENT',
    "status" "UserStatus" NOT NULL DEFAULT 'PENDING_VERIFICATION',
    "passwordHash" TEXT NOT NULL,
    "emailVerified" TIMESTAMP(3),
    "lastLoginAt" TIMESTAMP(3),
    "tenantId" TEXT,
    "metadata" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- User preferences for personalization
CREATE TABLE "user_preferences" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "autoplay" BOOLEAN NOT NULL DEFAULT true,
    "playbackSpeed" DOUBLE PRECISION NOT NULL DEFAULT 1.0,
    "subtitles" BOOLEAN NOT NULL DEFAULT false,
    "theme" TEXT NOT NULL DEFAULT 'light',
    "language" TEXT NOT NULL DEFAULT 'en',
    "emailNotifications" BOOLEAN NOT NULL DEFAULT true,
    "progressNotifications" BOOLEAN NOT NULL DEFAULT true,
    "allowAnalytics" BOOLEAN NOT NULL DEFAULT true,
    "customSettings" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "user_preferences_pkey" PRIMARY KEY ("id")
);

-- Lessons - top level content organization
CREATE TABLE "lessons" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "thumbnail" TEXT,
    "status" "LessonStatus" NOT NULL DEFAULT 'DRAFT',
    "order" INTEGER,
    "tenantId" TEXT,
    "createdById" TEXT NOT NULL,
    "objectives" TEXT[],
    "estimatedTime" INTEGER,
    "difficulty" TEXT,
    "tags" TEXT[],
    "metadata" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "publishedAt" TIMESTAMP(3),

    CONSTRAINT "lessons_pkey" PRIMARY KEY ("id")
);

-- Video groups within lessons
CREATE TABLE "video_groups" (
    "id" TEXT NOT NULL,
    "lessonId" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "order" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "video_groups_pkey" PRIMARY KEY ("id")
);

-- Individual videos with Google Cloud Storage integration
CREATE TABLE "videos" (
    "id" TEXT NOT NULL,
    "videoGroupId" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "order" INTEGER NOT NULL,
    "status" "VideoStatus" NOT NULL DEFAULT 'UPLOADING',
    "gcsPath" TEXT,
    "gcsUrl" TEXT,
    "duration" INTEGER,
    "size" BIGINT,
    "mimeType" TEXT,
    "processingStatus" TEXT,
    "thumbnailUrl" TEXT,
    "metadata" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "uploadedAt" TIMESTAMP(3),
    "processedAt" TIMESTAMP(3),

    CONSTRAINT "videos_pkey" PRIMARY KEY ("id")
);

-- Milestones within videos for interactive questions
CREATE TABLE "milestones" (
    "id" TEXT NOT NULL,
    "videoId" TEXT NOT NULL,
    "timestamp" DOUBLE PRECISION NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "order" INTEGER NOT NULL,
    "isRequired" BOOLEAN NOT NULL DEFAULT true,
    "retryLimit" INTEGER NOT NULL DEFAULT 3,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "milestones_pkey" PRIMARY KEY ("id")
);

-- AI-generated questions with approval workflow
CREATE TABLE "questions" (
    "id" TEXT NOT NULL,
    "milestoneId" TEXT NOT NULL,
    "type" "QuestionType" NOT NULL,
    "status" "QuestionStatus" NOT NULL DEFAULT 'AI_GENERATED',
    "text" TEXT NOT NULL,
    "explanation" TEXT,
    "hints" TEXT[],
    "difficulty" TEXT,
    "questionData" JSONB NOT NULL,
    "aiModel" TEXT,
    "aiPrompt" TEXT,
    "aiConfidence" DOUBLE PRECISION,
    "aiMetadata" JSONB,
    "points" INTEGER NOT NULL DEFAULT 1,
    "passThreshold" DOUBLE PRECISION NOT NULL DEFAULT 0.7,
    "reviewedById" TEXT,
    "reviewedAt" TIMESTAMP(3),
    "reviewNotes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "questions_pkey" PRIMARY KEY ("id")
);

-- Student sessions for cross-device continuity
CREATE TABLE "student_sessions" (
    "id" TEXT NOT NULL,
    "studentId" TEXT NOT NULL,
    "videoId" TEXT NOT NULL,
    "status" "SessionStatus" NOT NULL DEFAULT 'ACTIVE',
    "currentPosition" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "lastMilestoneId" TEXT,
    "completedMilestones" TEXT[],
    "deviceInfo" JSONB,
    "browserInfo" JSONB,
    "ipAddress" TEXT,
    "userAgent" TEXT,
    "sessionData" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "startedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "lastSeenAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "completedAt" TIMESTAMP(3),

    CONSTRAINT "student_sessions_pkey" PRIMARY KEY ("id")
);

-- Overall student progress per lesson
CREATE TABLE "student_progress" (
    "id" TEXT NOT NULL,
    "studentId" TEXT NOT NULL,
    "lessonId" TEXT NOT NULL,
    "isCompleted" BOOLEAN NOT NULL DEFAULT false,
    "completionPercent" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "totalTimeSpent" INTEGER NOT NULL DEFAULT 0,
    "totalMilestones" INTEGER NOT NULL DEFAULT 0,
    "completedMilestones" INTEGER NOT NULL DEFAULT 0,
    "averageScore" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "totalAttempts" INTEGER NOT NULL DEFAULT 0,
    "successfulAttempts" INTEGER NOT NULL DEFAULT 0,
    "progressData" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "startedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "completedAt" TIMESTAMP(3),

    CONSTRAINT "student_progress_pkey" PRIMARY KEY ("id")
);

-- Individual question attempts with detailed tracking
CREATE TABLE "question_attempts" (
    "id" TEXT NOT NULL,
    "studentId" TEXT NOT NULL,
    "questionId" TEXT NOT NULL,
    "status" "AttemptStatus" NOT NULL DEFAULT 'IN_PROGRESS',
    "attemptNumber" INTEGER NOT NULL,
    "studentAnswer" JSONB NOT NULL,
    "isCorrect" BOOLEAN,
    "score" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "timeSpent" INTEGER NOT NULL DEFAULT 0,
    "hintsUsed" TEXT[],
    "feedback" TEXT,
    "attemptData" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "submittedAt" TIMESTAMP(3),

    CONSTRAINT "question_attempts_pkey" PRIMARY KEY ("id")
);

-- Grades with configurable retry limits
CREATE TABLE "grades" (
    "id" TEXT NOT NULL,
    "studentId" TEXT NOT NULL,
    "studentProgressId" TEXT NOT NULL,
    "totalPoints" INTEGER NOT NULL DEFAULT 0,
    "earnedPoints" INTEGER NOT NULL DEFAULT 0,
    "percentageScore" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "letterGrade" TEXT,
    "status" "GradeStatus" NOT NULL DEFAULT 'IN_PROGRESS',
    "totalAttempts" INTEGER NOT NULL DEFAULT 0,
    "remainingAttempts" INTEGER NOT NULL DEFAULT 0,
    "gradeBreakdown" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "finalizedAt" TIMESTAMP(3),

    CONSTRAINT "grades_pkey" PRIMARY KEY ("id")
);

-- Analytics events for comprehensive tracking
CREATE TABLE "analytics_events" (
    "id" TEXT NOT NULL,
    "userId" TEXT,
    "sessionId" TEXT,
    "eventType" TEXT NOT NULL,
    "eventData" JSONB NOT NULL,
    "context" JSONB,
    "timestamp" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "processingTime" INTEGER,

    CONSTRAINT "analytics_events_pkey" PRIMARY KEY ("id")
);

-- System configuration management
CREATE TABLE "system_configs" (
    "id" TEXT NOT NULL,
    "key" TEXT NOT NULL,
    "value" JSONB NOT NULL,
    "description" TEXT,
    "category" TEXT,
    "isPublic" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "system_configs_pkey" PRIMARY KEY ("id")
);

-- Comprehensive audit logging
CREATE TABLE "audit_logs" (
    "id" TEXT NOT NULL,
    "userId" TEXT,
    "action" "AuditAction" NOT NULL,
    "resource" TEXT NOT NULL,
    "resourceId" TEXT,
    "changes" JSONB,
    "metadata" JSONB,
    "ipAddress" TEXT,
    "userAgent" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "audit_logs_pkey" PRIMARY KEY ("id")
);

-- AI API configuration management
CREATE TABLE "ai_configurations" (
    "id" TEXT NOT NULL,
    "provider" "AIProvider" NOT NULL,
    "name" TEXT NOT NULL,
    "apiKey" TEXT,
    "endpoint" TEXT,
    "model" TEXT NOT NULL,
    "parameters" JSONB,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "rateLimit" INTEGER,
    "maxTokens" INTEGER,
    "costPerToken" DOUBLE PRECISION,
    "monthlyBudget" DOUBLE PRECISION,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "ai_configurations_pkey" PRIMARY KEY ("id")
);

-- AI usage tracking for cost and performance monitoring
CREATE TABLE "ai_usage_logs" (
    "id" TEXT NOT NULL,
    "configurationId" TEXT NOT NULL,
    "requestType" TEXT NOT NULL,
    "prompt" TEXT,
    "response" TEXT,
    "tokensUsed" INTEGER NOT NULL,
    "cost" DOUBLE PRECISION,
    "responseTime" INTEGER NOT NULL,
    "success" BOOLEAN NOT NULL,
    "errorMessage" TEXT,
    "userId" TEXT,
    "resourceId" TEXT,
    "metadata" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "ai_usage_logs_pkey" PRIMARY KEY ("id")
);

-- ========================================
-- UNIQUE CONSTRAINTS
-- ========================================

CREATE UNIQUE INDEX "users_email_key" ON "users"("email");
CREATE UNIQUE INDEX "users_username_key" ON "users"("username");
CREATE UNIQUE INDEX "user_preferences_userId_key" ON "user_preferences"("userId");
CREATE UNIQUE INDEX "system_configs_key_key" ON "system_configs"("key");
CREATE UNIQUE INDEX "student_sessions_studentId_videoId_key" ON "student_sessions"("studentId", "videoId");
CREATE UNIQUE INDEX "student_progress_studentId_lessonId_key" ON "student_progress"("studentId", "lessonId");

-- ========================================
-- FOREIGN KEY CONSTRAINTS
-- ========================================

ALTER TABLE "user_preferences" ADD CONSTRAINT "user_preferences_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "lessons" ADD CONSTRAINT "lessons_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
ALTER TABLE "video_groups" ADD CONSTRAINT "video_groups_lessonId_fkey" FOREIGN KEY ("lessonId") REFERENCES "lessons"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "videos" ADD CONSTRAINT "videos_videoGroupId_fkey" FOREIGN KEY ("videoGroupId") REFERENCES "video_groups"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "milestones" ADD CONSTRAINT "milestones_videoId_fkey" FOREIGN KEY ("videoId") REFERENCES "videos"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "questions" ADD CONSTRAINT "questions_milestoneId_fkey" FOREIGN KEY ("milestoneId") REFERENCES "milestones"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "student_sessions" ADD CONSTRAINT "student_sessions_studentId_fkey" FOREIGN KEY ("studentId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "student_sessions" ADD CONSTRAINT "student_sessions_videoId_fkey" FOREIGN KEY ("videoId") REFERENCES "videos"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "student_progress" ADD CONSTRAINT "student_progress_studentId_fkey" FOREIGN KEY ("studentId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "student_progress" ADD CONSTRAINT "student_progress_lessonId_fkey" FOREIGN KEY ("lessonId") REFERENCES "lessons"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "question_attempts" ADD CONSTRAINT "question_attempts_studentId_fkey" FOREIGN KEY ("studentId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "question_attempts" ADD CONSTRAINT "question_attempts_questionId_fkey" FOREIGN KEY ("questionId") REFERENCES "questions"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "grades" ADD CONSTRAINT "grades_studentId_fkey" FOREIGN KEY ("studentId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "grades" ADD CONSTRAINT "grades_studentProgressId_fkey" FOREIGN KEY ("studentProgressId") REFERENCES "student_progress"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "analytics_events" ADD CONSTRAINT "analytics_events_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE "audit_logs" ADD CONSTRAINT "audit_logs_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="database/migrations/002_performance_indexes.sql">
-- Interactive Learning Platform - Performance Optimization Indexes
-- PostgreSQL Index Creation Script
-- Generated: 2025-08-07

-- ========================================
-- USER MANAGEMENT INDEXES
-- ========================================

-- User lookup and authentication indexes
CREATE INDEX "idx_users_email_hash" ON "users" USING hash ("email");
CREATE INDEX "idx_users_role_status" ON "users"("role", "status");
CREATE INDEX "idx_users_tenant_role" ON "users"("tenantId", "role") WHERE "tenantId" IS NOT NULL;
CREATE INDEX "idx_users_last_login" ON "users"("lastLoginAt") WHERE "lastLoginAt" IS NOT NULL;
CREATE INDEX "idx_users_created_at" ON "users"("createdAt");

-- User preferences fast lookup
CREATE INDEX "idx_user_preferences_theme_lang" ON "user_preferences"("theme", "language");

-- ========================================
-- CONTENT HIERARCHY INDEXES
-- ========================================

-- Lesson management and discovery
CREATE INDEX "idx_lessons_status_published" ON "lessons"("status", "publishedAt") WHERE "status" = 'PUBLISHED';
CREATE INDEX "idx_lessons_creator_tenant" ON "lessons"("createdById", "tenantId");
CREATE INDEX "idx_lessons_order_status" ON "lessons"("order", "status") WHERE "order" IS NOT NULL;
CREATE INDEX "idx_lessons_tags_gin" ON "lessons" USING gin ("tags");
CREATE INDEX "idx_lessons_difficulty_time" ON "lessons"("difficulty", "estimatedTime") WHERE "difficulty" IS NOT NULL;

-- Video group ordering
CREATE INDEX "idx_video_groups_lesson_order" ON "video_groups"("lessonId", "order");

-- Video management and streaming optimization
CREATE INDEX "idx_videos_group_order_status" ON "videos"("videoGroupId", "order", "status");
CREATE INDEX "idx_videos_status_processed" ON "videos"("status", "processedAt");
CREATE INDEX "idx_videos_gcs_path" ON "videos"("gcsPath") WHERE "gcsPath" IS NOT NULL;
CREATE INDEX "idx_videos_duration" ON "videos"("duration") WHERE "duration" IS NOT NULL;

-- Critical milestone lookup for video playback
CREATE INDEX "idx_milestones_video_timestamp" ON "milestones"("videoId", "timestamp");
CREATE INDEX "idx_milestones_video_order" ON "milestones"("videoId", "order");
CREATE INDEX "idx_milestones_required" ON "milestones"("videoId", "isRequired") WHERE "isRequired" = true;

-- ========================================
-- QUESTION AND AI WORKFLOW INDEXES
-- ========================================

-- Question management and review workflow
CREATE INDEX "idx_questions_milestone_status" ON "questions"("milestoneId", "status");
CREATE INDEX "idx_questions_status_created" ON "questions"("status", "createdAt");
CREATE INDEX "idx_questions_ai_model_confidence" ON "questions"("aiModel", "aiConfidence") WHERE "aiModel" IS NOT NULL;
CREATE INDEX "idx_questions_type_difficulty" ON "questions"("type", "difficulty") WHERE "difficulty" IS NOT NULL;
CREATE INDEX "idx_questions_review_pending" ON "questions"("status", "createdAt") WHERE "status" IN ('AI_GENERATED', 'PENDING_REVIEW');

-- Question data JSONB optimization
CREATE INDEX "idx_questions_data_gin" ON "questions" USING gin ("questionData");
CREATE INDEX "idx_questions_ai_metadata_gin" ON "questions" USING gin ("aiMetadata") WHERE "aiMetadata" IS NOT NULL;

-- ========================================
-- STUDENT PROGRESS AND SESSION INDEXES
-- ========================================

-- Critical session management for cross-device sync
CREATE INDEX "idx_student_sessions_student_active" ON "student_sessions"("studentId", "status") WHERE "status" IN ('ACTIVE', 'PAUSED');
CREATE INDEX "idx_student_sessions_video_active" ON "student_sessions"("videoId", "status") WHERE "status" = 'ACTIVE';
CREATE INDEX "idx_student_sessions_last_seen" ON "student_sessions"("lastSeenAt") WHERE "status" IN ('ACTIVE', 'PAUSED');
CREATE INDEX "idx_student_sessions_completed" ON "student_sessions"("completedAt") WHERE "completedAt" IS NOT NULL;

-- Session data optimization
CREATE INDEX "idx_student_sessions_device_gin" ON "student_sessions" USING gin ("deviceInfo") WHERE "deviceInfo" IS NOT NULL;
CREATE INDEX "idx_student_sessions_milestones_gin" ON "student_sessions" USING gin ("completedMilestones");

-- Student progress tracking optimization
CREATE INDEX "idx_student_progress_student_completion" ON "student_progress"("studentId", "completionPercent");
CREATE INDEX "idx_student_progress_lesson_completed" ON "student_progress"("lessonId", "isCompleted");
CREATE INDEX "idx_student_progress_completion_time" ON "student_progress"("completionPercent", "totalTimeSpent");
CREATE INDEX "idx_student_progress_score" ON "student_progress"("averageScore") WHERE "averageScore" > 0;

-- Progress data JSONB optimization
CREATE INDEX "idx_student_progress_data_gin" ON "student_progress" USING gin ("progressData") WHERE "progressData" IS NOT NULL;

-- ========================================
-- GRADING AND ASSESSMENT INDEXES
-- ========================================

-- Question attempt analysis
CREATE INDEX "idx_question_attempts_student_question" ON "question_attempts"("studentId", "questionId", "attemptNumber");
CREATE INDEX "idx_question_attempts_question_correct" ON "question_attempts"("questionId", "isCorrect");
CREATE INDEX "idx_question_attempts_student_submitted" ON "question_attempts"("studentId", "submittedAt") WHERE "submittedAt" IS NOT NULL;
CREATE INDEX "idx_question_attempts_status_time" ON "question_attempts"("status", "timeSpent");

-- Attempt data optimization
CREATE INDEX "idx_question_attempts_answer_gin" ON "question_attempts" USING gin ("studentAnswer");
CREATE INDEX "idx_question_attempts_hints_gin" ON "question_attempts" USING gin ("hintsUsed");

-- Grade management and reporting
CREATE INDEX "idx_grades_student_status" ON "grades"("studentId", "status");
CREATE INDEX "idx_grades_progress_finalized" ON "grades"("studentProgressId", "finalizedAt");
CREATE INDEX "idx_grades_percentage_letter" ON "grades"("percentageScore", "letterGrade");
CREATE INDEX "idx_grades_attempts_remaining" ON "grades"("totalAttempts", "remainingAttempts");

-- Grade breakdown JSONB optimization
CREATE INDEX "idx_grades_breakdown_gin" ON "grades" USING gin ("gradeBreakdown") WHERE "gradeBreakdown" IS NOT NULL;

-- ========================================
-- ANALYTICS AND REPORTING INDEXES
-- ========================================

-- Real-time analytics optimization
CREATE INDEX "idx_analytics_events_user_time" ON "analytics_events"("userId", "timestamp") WHERE "userId" IS NOT NULL;
CREATE INDEX "idx_analytics_events_session_time" ON "analytics_events"("sessionId", "timestamp") WHERE "sessionId" IS NOT NULL;
CREATE INDEX "idx_analytics_events_type_time" ON "analytics_events"("eventType", "timestamp");
CREATE INDEX "idx_analytics_events_hourly" ON "analytics_events"(DATE_TRUNC('hour', "timestamp"));
CREATE INDEX "idx_analytics_events_daily" ON "analytics_events"(DATE_TRUNC('day', "timestamp"));

-- Event data optimization for complex queries
CREATE INDEX "idx_analytics_events_data_gin" ON "analytics_events" USING gin ("eventData");
CREATE INDEX "idx_analytics_events_context_gin" ON "analytics_events" USING gin ("context") WHERE "context" IS NOT NULL;

-- Performance monitoring
CREATE INDEX "idx_analytics_events_processing_time" ON "analytics_events"("processingTime") WHERE "processingTime" IS NOT NULL;

-- ========================================
-- SYSTEM ADMINISTRATION INDEXES
-- ========================================

-- System configuration management
CREATE INDEX "idx_system_configs_category_public" ON "system_configs"("category", "isPublic") WHERE "category" IS NOT NULL;
CREATE INDEX "idx_system_configs_updated" ON "system_configs"("updatedAt");

-- Audit trail optimization
CREATE INDEX "idx_audit_logs_user_action_time" ON "audit_logs"("userId", "action", "createdAt") WHERE "userId" IS NOT NULL;
CREATE INDEX "idx_audit_logs_resource_time" ON "audit_logs"("resource", "resourceId", "createdAt") WHERE "resourceId" IS NOT NULL;
CREATE INDEX "idx_audit_logs_action_time" ON "audit_logs"("action", "createdAt");
CREATE INDEX "idx_audit_logs_daily" ON "audit_logs"(DATE_TRUNC('day', "createdAt"));

-- Audit data optimization
CREATE INDEX "idx_audit_logs_changes_gin" ON "audit_logs" USING gin ("changes") WHERE "changes" IS NOT NULL;
CREATE INDEX "idx_audit_logs_metadata_gin" ON "audit_logs" USING gin ("metadata") WHERE "metadata" IS NOT NULL;

-- ========================================
-- AI MANAGEMENT INDEXES
-- ========================================

-- AI configuration management
CREATE INDEX "idx_ai_configs_provider_active" ON "ai_configurations"("provider", "isActive");
CREATE INDEX "idx_ai_configs_active_model" ON "ai_configurations"("isActive", "model") WHERE "isActive" = true;

-- AI usage tracking and cost analysis
CREATE INDEX "idx_ai_usage_config_time" ON "ai_usage_logs"("configurationId", "createdAt");
CREATE INDEX "idx_ai_usage_type_success_time" ON "ai_usage_logs"("requestType", "success", "createdAt");
CREATE INDEX "idx_ai_usage_cost_time" ON "ai_usage_logs"("cost", "createdAt") WHERE "cost" IS NOT NULL;
CREATE INDEX "idx_ai_usage_tokens_time" ON "ai_usage_logs"("tokensUsed", "createdAt");
CREATE INDEX "idx_ai_usage_daily" ON "ai_usage_logs"(DATE_TRUNC('day', "createdAt"));
CREATE INDEX "idx_ai_usage_monthly" ON "ai_usage_logs"(DATE_TRUNC('month', "createdAt"));

-- AI performance monitoring
CREATE INDEX "idx_ai_usage_response_time" ON "ai_usage_logs"("responseTime");
CREATE INDEX "idx_ai_usage_errors" ON "ai_usage_logs"("success", "errorMessage") WHERE "success" = false;

-- ========================================
-- COMPOSITE INDEXES FOR COMMON QUERIES
-- ========================================

-- Teacher dashboard optimization
CREATE INDEX "idx_teacher_content_analytics" ON "lessons"("createdById", "status", "publishedAt") WHERE "status" = 'PUBLISHED';

-- Student dashboard optimization
CREATE INDEX "idx_student_active_progress" ON "student_progress"("studentId", "isCompleted", "updatedAt");

-- Video streaming optimization
CREATE INDEX "idx_video_streaming" ON "videos"("status", "gcsUrl", "duration") WHERE "status" = 'READY' AND "gcsUrl" IS NOT NULL;

-- Question workflow optimization
CREATE INDEX "idx_question_workflow" ON "questions"("status", "createdAt", "reviewedAt");

-- Session continuity optimization
CREATE INDEX "idx_session_continuity" ON "student_sessions"("studentId", "videoId", "status", "lastSeenAt");

-- Performance analytics
CREATE INDEX "idx_performance_analytics" ON "question_attempts"("questionId", "isCorrect", "timeSpent", "submittedAt") WHERE "submittedAt" IS NOT NULL;

-- ========================================
-- PARTIAL INDEXES FOR EFFICIENCY
-- ========================================

-- Active user sessions only
CREATE INDEX "idx_active_user_sessions" ON "student_sessions"("studentId", "lastSeenAt") 
WHERE "status" IN ('ACTIVE', 'PAUSED') AND "lastSeenAt" > (CURRENT_TIMESTAMP - INTERVAL '24 hours');

-- Recent analytics events only (last 30 days)
CREATE INDEX "idx_recent_analytics" ON "analytics_events"("eventType", "timestamp") 
WHERE "timestamp" > (CURRENT_TIMESTAMP - INTERVAL '30 days');

-- Failed AI requests for debugging
CREATE INDEX "idx_failed_ai_requests" ON "ai_usage_logs"("configurationId", "requestType", "createdAt", "errorMessage") 
WHERE "success" = false AND "createdAt" > (CURRENT_TIMESTAMP - INTERVAL '7 days');

-- ========================================
-- TEXT SEARCH OPTIMIZATION
-- ========================================

-- Full-text search on lessons
CREATE INDEX "idx_lessons_text_search" ON "lessons" USING gin (
    to_tsvector('english', COALESCE("title", '') || ' ' || COALESCE("description", ''))
);

-- Full-text search on questions
CREATE INDEX "idx_questions_text_search" ON "questions" USING gin (
    to_tsvector('english', COALESCE("text", '') || ' ' || COALESCE("explanation", ''))
);

-- Video search optimization
CREATE INDEX "idx_videos_text_search" ON "videos" USING gin (
    to_tsvector('english', COALESCE("title", '') || ' ' || COALESCE("description", ''))
);
</file>

<file path="database/migrations/add_milestone_type.sql">
-- Add MilestoneType enum
CREATE TYPE "MilestoneType" AS ENUM ('PAUSE', 'QUIZ', 'CHECKPOINT');

-- Add type column to Milestone table
ALTER TABLE "milestones" ADD COLUMN "type" "MilestoneType" DEFAULT 'CHECKPOINT';

-- Create MilestoneProgress table
CREATE TABLE "milestone_progress" (
    "id" TEXT NOT NULL DEFAULT gen_random_uuid(),
    "sessionId" TEXT NOT NULL,
    "milestoneId" TEXT NOT NULL,
    "reachedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "milestone_progress_pkey" PRIMARY KEY ("id")
);

-- Add unique constraint for session-milestone combination
CREATE UNIQUE INDEX "milestone_progress_sessionId_milestoneId_key" ON "milestone_progress"("sessionId", "milestoneId");

-- Add indexes
CREATE INDEX "milestone_progress_sessionId_idx" ON "milestone_progress"("sessionId");
CREATE INDEX "milestone_progress_milestoneId_idx" ON "milestone_progress"("milestoneId");

-- Add foreign key constraints
ALTER TABLE "milestone_progress" ADD CONSTRAINT "milestone_progress_sessionId_fkey" 
    FOREIGN KEY ("sessionId") REFERENCES "student_sessions"("id") ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE "milestone_progress" ADD CONSTRAINT "milestone_progress_milestoneId_fkey" 
    FOREIGN KEY ("milestoneId") REFERENCES "milestones"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- Add sessionId column to question_attempts table
ALTER TABLE "question_attempts" ADD COLUMN "sessionId" TEXT;

-- Add foreign key constraint for sessionId
ALTER TABLE "question_attempts" ADD CONSTRAINT "question_attempts_sessionId_fkey" 
    FOREIGN KEY ("sessionId") REFERENCES "student_sessions"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- Update existing milestones to have QUIZ type if they have questions
UPDATE "milestones" m
SET "type" = 'QUIZ'
WHERE EXISTS (
    SELECT 1 FROM "questions" q WHERE q."milestoneId" = m."id"
);
</file>

<file path="database/prisma/migrations/0_init/migration.sql">
-- CreateEnum
CREATE TYPE "UserRole" AS ENUM ('STUDENT', 'TEACHER', 'ADMIN');

-- CreateEnum
CREATE TYPE "UserStatus" AS ENUM ('ACTIVE', 'INACTIVE', 'SUSPENDED', 'PENDING_VERIFICATION');

-- CreateEnum
CREATE TYPE "LessonStatus" AS ENUM ('DRAFT', 'PUBLISHED', 'ARCHIVED');

-- CreateEnum
CREATE TYPE "VideoStatus" AS ENUM ('UPLOADING', 'PROCESSING', 'READY', 'ERROR', 'DRAFT');

-- CreateEnum
CREATE TYPE "MilestoneType" AS ENUM ('PAUSE', 'QUIZ', 'CHECKPOINT');

-- CreateEnum
CREATE TYPE "QuestionType" AS ENUM ('MULTIPLE_CHOICE', 'TRUE_FALSE', 'SHORT_ANSWER', 'FILL_IN_BLANK', 'MATCHING', 'ORDERING');

-- CreateEnum
CREATE TYPE "QuestionStatus" AS ENUM ('DRAFT', 'APPROVED', 'ARCHIVED');

-- CreateEnum
CREATE TYPE "SessionStatus" AS ENUM ('ACTIVE', 'PAUSED', 'COMPLETED', 'ABANDONED');

-- CreateEnum
CREATE TYPE "AttemptStatus" AS ENUM ('IN_PROGRESS', 'SUBMITTED', 'CORRECT', 'INCORRECT', 'PARTIAL', 'TIMEOUT');

-- CreateEnum
CREATE TYPE "GradeStatus" AS ENUM ('IN_PROGRESS', 'COMPLETED', 'FAILED', 'RETRY_ALLOWED');

-- CreateEnum
CREATE TYPE "AuditAction" AS ENUM ('CREATE', 'UPDATE', 'DELETE', 'LOGIN', 'LOGOUT', 'VIEW', 'DOWNLOAD', 'UPLOAD');

-- CreateEnum
CREATE TYPE "AIProvider" AS ENUM ('OPENAI', 'CLAUDE', 'GOOGLE_PALM', 'CUSTOM');

-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "username" TEXT,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "avatar" TEXT,
    "role" "UserRole" NOT NULL DEFAULT 'STUDENT',
    "status" "UserStatus" NOT NULL DEFAULT 'PENDING_VERIFICATION',
    "passwordHash" TEXT NOT NULL,
    "emailVerified" TIMESTAMP(3),
    "lastLoginAt" TIMESTAMP(3),
    "tenantId" TEXT,
    "metadata" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "user_preferences" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "autoplay" BOOLEAN NOT NULL DEFAULT true,
    "playbackSpeed" DOUBLE PRECISION NOT NULL DEFAULT 1.0,
    "subtitles" BOOLEAN NOT NULL DEFAULT false,
    "theme" TEXT NOT NULL DEFAULT 'light',
    "language" TEXT NOT NULL DEFAULT 'en',
    "emailNotifications" BOOLEAN NOT NULL DEFAULT true,
    "progressNotifications" BOOLEAN NOT NULL DEFAULT true,
    "allowAnalytics" BOOLEAN NOT NULL DEFAULT true,
    "customSettings" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "user_preferences_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "lessons" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "thumbnail" TEXT,
    "status" "LessonStatus" NOT NULL DEFAULT 'DRAFT',
    "order" INTEGER,
    "tenantId" TEXT,
    "createdById" TEXT NOT NULL,
    "objectives" TEXT[],
    "estimatedTime" INTEGER,
    "difficulty" TEXT,
    "tags" TEXT[],
    "metadata" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "publishedAt" TIMESTAMP(3),

    CONSTRAINT "lessons_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "video_groups" (
    "id" TEXT NOT NULL,
    "lessonId" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "order" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "video_groups_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "videos" (
    "id" TEXT NOT NULL,
    "videoGroupId" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "order" INTEGER NOT NULL,
    "status" "VideoStatus" NOT NULL DEFAULT 'UPLOADING',
    "filePath" TEXT,
    "fileName" TEXT,
    "duration" INTEGER,
    "size" BIGINT,
    "mimeType" TEXT,
    "processingStatus" TEXT,
    "thumbnailPath" TEXT,
    "metadata" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "uploadedAt" TIMESTAMP(3),
    "processedAt" TIMESTAMP(3),

    CONSTRAINT "videos_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "milestones" (
    "id" TEXT NOT NULL,
    "videoId" TEXT NOT NULL,
    "timestamp" DOUBLE PRECISION NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "type" "MilestoneType" NOT NULL DEFAULT 'CHECKPOINT',
    "order" INTEGER NOT NULL,
    "isRequired" BOOLEAN NOT NULL DEFAULT true,
    "retryLimit" INTEGER NOT NULL DEFAULT 3,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "milestones_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "questions" (
    "id" TEXT NOT NULL,
    "milestoneId" TEXT NOT NULL,
    "type" "QuestionType" NOT NULL,
    "status" "QuestionStatus" NOT NULL DEFAULT 'DRAFT',
    "text" TEXT NOT NULL,
    "explanation" TEXT,
    "hints" TEXT[],
    "difficulty" TEXT,
    "questionData" JSONB NOT NULL,
    "points" INTEGER NOT NULL DEFAULT 1,
    "passThreshold" DOUBLE PRECISION NOT NULL DEFAULT 0.7,
    "createdById" TEXT NOT NULL,
    "reviewedById" TEXT,
    "reviewedAt" TIMESTAMP(3),
    "reviewNotes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "questions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "student_sessions" (
    "id" TEXT NOT NULL,
    "studentId" TEXT NOT NULL,
    "videoId" TEXT NOT NULL,
    "status" "SessionStatus" NOT NULL DEFAULT 'ACTIVE',
    "currentPosition" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "lastMilestoneId" TEXT,
    "completedMilestones" TEXT[],
    "deviceInfo" JSONB,
    "browserInfo" JSONB,
    "ipAddress" TEXT,
    "userAgent" TEXT,
    "sessionData" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "startedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "lastSeenAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "completedAt" TIMESTAMP(3),

    CONSTRAINT "student_sessions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "milestone_progress" (
    "id" TEXT NOT NULL,
    "sessionId" TEXT NOT NULL,
    "milestoneId" TEXT NOT NULL,
    "reachedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "milestone_progress_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "student_progress" (
    "id" TEXT NOT NULL,
    "studentId" TEXT NOT NULL,
    "lessonId" TEXT NOT NULL,
    "isCompleted" BOOLEAN NOT NULL DEFAULT false,
    "completionPercent" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "totalTimeSpent" INTEGER NOT NULL DEFAULT 0,
    "totalMilestones" INTEGER NOT NULL DEFAULT 0,
    "completedMilestones" INTEGER NOT NULL DEFAULT 0,
    "averageScore" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "totalAttempts" INTEGER NOT NULL DEFAULT 0,
    "successfulAttempts" INTEGER NOT NULL DEFAULT 0,
    "progressData" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "startedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "completedAt" TIMESTAMP(3),

    CONSTRAINT "student_progress_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "question_attempts" (
    "id" TEXT NOT NULL,
    "studentId" TEXT NOT NULL,
    "questionId" TEXT NOT NULL,
    "sessionId" TEXT,
    "status" "AttemptStatus" NOT NULL DEFAULT 'IN_PROGRESS',
    "attemptNumber" INTEGER NOT NULL,
    "studentAnswer" JSONB NOT NULL,
    "isCorrect" BOOLEAN,
    "score" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "timeSpent" INTEGER NOT NULL DEFAULT 0,
    "hintsUsed" TEXT[],
    "feedback" TEXT,
    "attemptData" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "submittedAt" TIMESTAMP(3),

    CONSTRAINT "question_attempts_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "grades" (
    "id" TEXT NOT NULL,
    "studentId" TEXT NOT NULL,
    "studentProgressId" TEXT NOT NULL,
    "totalPoints" INTEGER NOT NULL DEFAULT 0,
    "earnedPoints" INTEGER NOT NULL DEFAULT 0,
    "percentageScore" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "letterGrade" TEXT,
    "status" "GradeStatus" NOT NULL DEFAULT 'IN_PROGRESS',
    "totalAttempts" INTEGER NOT NULL DEFAULT 0,
    "remainingAttempts" INTEGER NOT NULL DEFAULT 0,
    "gradeBreakdown" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "finalizedAt" TIMESTAMP(3),

    CONSTRAINT "grades_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "analytics_events" (
    "id" TEXT NOT NULL,
    "userId" TEXT,
    "sessionId" TEXT,
    "eventType" TEXT NOT NULL,
    "eventData" JSONB NOT NULL,
    "context" JSONB,
    "timestamp" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "processingTime" INTEGER,

    CONSTRAINT "analytics_events_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "system_configs" (
    "id" TEXT NOT NULL,
    "key" TEXT NOT NULL,
    "value" JSONB NOT NULL,
    "description" TEXT,
    "category" TEXT,
    "isPublic" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "system_configs_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "audit_logs" (
    "id" TEXT NOT NULL,
    "userId" TEXT,
    "action" "AuditAction" NOT NULL,
    "resource" TEXT NOT NULL,
    "resourceId" TEXT,
    "changes" JSONB,
    "metadata" JSONB,
    "ipAddress" TEXT,
    "userAgent" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "audit_logs_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "question_options" (
    "id" TEXT NOT NULL,
    "questionId" TEXT NOT NULL,
    "text" TEXT NOT NULL,
    "isCorrect" BOOLEAN NOT NULL DEFAULT false,
    "order" INTEGER NOT NULL DEFAULT 1,
    "explanation" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "question_options_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ai_configurations" (
    "id" TEXT NOT NULL,
    "provider" "AIProvider" NOT NULL,
    "name" TEXT NOT NULL,
    "apiKey" TEXT,
    "endpoint" TEXT,
    "model" TEXT NOT NULL,
    "parameters" JSONB,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "rateLimit" INTEGER,
    "maxTokens" INTEGER,
    "costPerToken" DOUBLE PRECISION,
    "monthlyBudget" DOUBLE PRECISION,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "ai_configurations_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ai_usage_logs" (
    "id" TEXT NOT NULL,
    "configurationId" TEXT NOT NULL,
    "requestType" TEXT NOT NULL,
    "prompt" TEXT,
    "response" TEXT,
    "tokensUsed" INTEGER NOT NULL,
    "cost" DOUBLE PRECISION,
    "responseTime" INTEGER NOT NULL,
    "success" BOOLEAN NOT NULL,
    "errorMessage" TEXT,
    "userId" TEXT,
    "resourceId" TEXT,
    "metadata" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "ai_usage_logs_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");

-- CreateIndex
CREATE UNIQUE INDEX "users_username_key" ON "users"("username");

-- CreateIndex
CREATE INDEX "users_email_idx" ON "users"("email");

-- CreateIndex
CREATE INDEX "users_role_idx" ON "users"("role");

-- CreateIndex
CREATE INDEX "users_tenantId_idx" ON "users"("tenantId");

-- CreateIndex
CREATE INDEX "users_status_idx" ON "users"("status");

-- CreateIndex
CREATE INDEX "users_createdAt_idx" ON "users"("createdAt");

-- CreateIndex
CREATE UNIQUE INDEX "user_preferences_userId_key" ON "user_preferences"("userId");

-- CreateIndex
CREATE INDEX "lessons_status_idx" ON "lessons"("status");

-- CreateIndex
CREATE INDEX "lessons_createdById_idx" ON "lessons"("createdById");

-- CreateIndex
CREATE INDEX "lessons_tenantId_idx" ON "lessons"("tenantId");

-- CreateIndex
CREATE INDEX "lessons_publishedAt_idx" ON "lessons"("publishedAt");

-- CreateIndex
CREATE INDEX "lessons_order_idx" ON "lessons"("order");

-- CreateIndex
CREATE INDEX "video_groups_lessonId_idx" ON "video_groups"("lessonId");

-- CreateIndex
CREATE INDEX "video_groups_order_idx" ON "video_groups"("order");

-- CreateIndex
CREATE INDEX "videos_videoGroupId_idx" ON "videos"("videoGroupId");

-- CreateIndex
CREATE INDEX "videos_status_idx" ON "videos"("status");

-- CreateIndex
CREATE INDEX "videos_order_idx" ON "videos"("order");

-- CreateIndex
CREATE INDEX "videos_filePath_idx" ON "videos"("filePath");

-- CreateIndex
CREATE INDEX "milestones_videoId_idx" ON "milestones"("videoId");

-- CreateIndex
CREATE INDEX "milestones_timestamp_idx" ON "milestones"("timestamp");

-- CreateIndex
CREATE INDEX "milestones_order_idx" ON "milestones"("order");

-- CreateIndex
CREATE INDEX "questions_milestoneId_idx" ON "questions"("milestoneId");

-- CreateIndex
CREATE INDEX "questions_status_idx" ON "questions"("status");

-- CreateIndex
CREATE INDEX "questions_type_idx" ON "questions"("type");

-- CreateIndex
CREATE INDEX "questions_createdById_idx" ON "questions"("createdById");

-- CreateIndex
CREATE INDEX "questions_createdAt_idx" ON "questions"("createdAt");

-- CreateIndex
CREATE INDEX "student_sessions_studentId_idx" ON "student_sessions"("studentId");

-- CreateIndex
CREATE INDEX "student_sessions_videoId_idx" ON "student_sessions"("videoId");

-- CreateIndex
CREATE INDEX "student_sessions_status_idx" ON "student_sessions"("status");

-- CreateIndex
CREATE INDEX "student_sessions_lastSeenAt_idx" ON "student_sessions"("lastSeenAt");

-- CreateIndex
CREATE UNIQUE INDEX "student_sessions_studentId_videoId_key" ON "student_sessions"("studentId", "videoId");

-- CreateIndex
CREATE INDEX "milestone_progress_sessionId_idx" ON "milestone_progress"("sessionId");

-- CreateIndex
CREATE INDEX "milestone_progress_milestoneId_idx" ON "milestone_progress"("milestoneId");

-- CreateIndex
CREATE UNIQUE INDEX "milestone_progress_sessionId_milestoneId_key" ON "milestone_progress"("sessionId", "milestoneId");

-- CreateIndex
CREATE INDEX "student_progress_studentId_idx" ON "student_progress"("studentId");

-- CreateIndex
CREATE INDEX "student_progress_lessonId_idx" ON "student_progress"("lessonId");

-- CreateIndex
CREATE INDEX "student_progress_isCompleted_idx" ON "student_progress"("isCompleted");

-- CreateIndex
CREATE INDEX "student_progress_completionPercent_idx" ON "student_progress"("completionPercent");

-- CreateIndex
CREATE UNIQUE INDEX "student_progress_studentId_lessonId_key" ON "student_progress"("studentId", "lessonId");

-- CreateIndex
CREATE INDEX "question_attempts_studentId_idx" ON "question_attempts"("studentId");

-- CreateIndex
CREATE INDEX "question_attempts_questionId_idx" ON "question_attempts"("questionId");

-- CreateIndex
CREATE INDEX "question_attempts_status_idx" ON "question_attempts"("status");

-- CreateIndex
CREATE INDEX "question_attempts_isCorrect_idx" ON "question_attempts"("isCorrect");

-- CreateIndex
CREATE INDEX "question_attempts_submittedAt_idx" ON "question_attempts"("submittedAt");

-- CreateIndex
CREATE INDEX "grades_studentId_idx" ON "grades"("studentId");

-- CreateIndex
CREATE INDEX "grades_studentProgressId_idx" ON "grades"("studentProgressId");

-- CreateIndex
CREATE INDEX "grades_status_idx" ON "grades"("status");

-- CreateIndex
CREATE INDEX "grades_percentageScore_idx" ON "grades"("percentageScore");

-- CreateIndex
CREATE INDEX "grades_finalizedAt_idx" ON "grades"("finalizedAt");

-- CreateIndex
CREATE INDEX "analytics_events_userId_idx" ON "analytics_events"("userId");

-- CreateIndex
CREATE INDEX "analytics_events_eventType_idx" ON "analytics_events"("eventType");

-- CreateIndex
CREATE INDEX "analytics_events_timestamp_idx" ON "analytics_events"("timestamp");

-- CreateIndex
CREATE INDEX "analytics_events_sessionId_idx" ON "analytics_events"("sessionId");

-- CreateIndex
CREATE UNIQUE INDEX "system_configs_key_key" ON "system_configs"("key");

-- CreateIndex
CREATE INDEX "system_configs_key_idx" ON "system_configs"("key");

-- CreateIndex
CREATE INDEX "system_configs_category_idx" ON "system_configs"("category");

-- CreateIndex
CREATE INDEX "audit_logs_userId_idx" ON "audit_logs"("userId");

-- CreateIndex
CREATE INDEX "audit_logs_action_idx" ON "audit_logs"("action");

-- CreateIndex
CREATE INDEX "audit_logs_resource_idx" ON "audit_logs"("resource");

-- CreateIndex
CREATE INDEX "audit_logs_resourceId_idx" ON "audit_logs"("resourceId");

-- CreateIndex
CREATE INDEX "audit_logs_createdAt_idx" ON "audit_logs"("createdAt");

-- CreateIndex
CREATE INDEX "question_options_questionId_idx" ON "question_options"("questionId");

-- CreateIndex
CREATE INDEX "question_options_order_idx" ON "question_options"("order");

-- CreateIndex
CREATE INDEX "ai_configurations_provider_idx" ON "ai_configurations"("provider");

-- CreateIndex
CREATE INDEX "ai_configurations_isActive_idx" ON "ai_configurations"("isActive");

-- CreateIndex
CREATE INDEX "ai_usage_logs_configurationId_idx" ON "ai_usage_logs"("configurationId");

-- CreateIndex
CREATE INDEX "ai_usage_logs_requestType_idx" ON "ai_usage_logs"("requestType");

-- CreateIndex
CREATE INDEX "ai_usage_logs_createdAt_idx" ON "ai_usage_logs"("createdAt");

-- CreateIndex
CREATE INDEX "ai_usage_logs_success_idx" ON "ai_usage_logs"("success");

-- AddForeignKey
ALTER TABLE "user_preferences" ADD CONSTRAINT "user_preferences_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "lessons" ADD CONSTRAINT "lessons_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "video_groups" ADD CONSTRAINT "video_groups_lessonId_fkey" FOREIGN KEY ("lessonId") REFERENCES "lessons"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "videos" ADD CONSTRAINT "videos_videoGroupId_fkey" FOREIGN KEY ("videoGroupId") REFERENCES "video_groups"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "milestones" ADD CONSTRAINT "milestones_videoId_fkey" FOREIGN KEY ("videoId") REFERENCES "videos"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "questions" ADD CONSTRAINT "questions_milestoneId_fkey" FOREIGN KEY ("milestoneId") REFERENCES "milestones"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "questions" ADD CONSTRAINT "questions_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "student_sessions" ADD CONSTRAINT "student_sessions_studentId_fkey" FOREIGN KEY ("studentId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "student_sessions" ADD CONSTRAINT "student_sessions_videoId_fkey" FOREIGN KEY ("videoId") REFERENCES "videos"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "milestone_progress" ADD CONSTRAINT "milestone_progress_sessionId_fkey" FOREIGN KEY ("sessionId") REFERENCES "student_sessions"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "milestone_progress" ADD CONSTRAINT "milestone_progress_milestoneId_fkey" FOREIGN KEY ("milestoneId") REFERENCES "milestones"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "student_progress" ADD CONSTRAINT "student_progress_studentId_fkey" FOREIGN KEY ("studentId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "student_progress" ADD CONSTRAINT "student_progress_lessonId_fkey" FOREIGN KEY ("lessonId") REFERENCES "lessons"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "question_attempts" ADD CONSTRAINT "question_attempts_studentId_fkey" FOREIGN KEY ("studentId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "question_attempts" ADD CONSTRAINT "question_attempts_questionId_fkey" FOREIGN KEY ("questionId") REFERENCES "questions"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "question_attempts" ADD CONSTRAINT "question_attempts_sessionId_fkey" FOREIGN KEY ("sessionId") REFERENCES "student_sessions"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "grades" ADD CONSTRAINT "grades_studentId_fkey" FOREIGN KEY ("studentId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "grades" ADD CONSTRAINT "grades_studentProgressId_fkey" FOREIGN KEY ("studentProgressId") REFERENCES "student_progress"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "analytics_events" ADD CONSTRAINT "analytics_events_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "audit_logs" ADD CONSTRAINT "audit_logs_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "question_options" ADD CONSTRAINT "question_options_questionId_fkey" FOREIGN KEY ("questionId") REFERENCES "questions"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="database/seeds/001_initial_data.d.ts">
export {};
//# sourceMappingURL=001_initial_data.d.ts.map
</file>

<file path="database/seeds/001_initial_data.d.ts.map">
{"version":3,"file":"001_initial_data.d.ts","sourceRoot":"","sources":["001_initial_data.ts"],"names":[],"mappings":""}
</file>

<file path="database/seeds/001_initial_data.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("@prisma/client");
const bcrypt_1 = __importDefault(require("bcrypt"));
const prisma = new client_1.PrismaClient();
async function main() {
    console.log('🌱 Starting database seeding...');
    const systemConfigs = [
        {
            key: 'app.name',
            value: { name: 'Interactive Learning Platform' },
            description: 'Application name',
            category: 'general',
            isPublic: true
        },
        {
            key: 'app.version',
            value: { version: '1.0.0' },
            description: 'Application version',
            category: 'general',
            isPublic: true
        },
        {
            key: 'video.maxFileSize',
            value: { maxSize: 2147483648 },
            description: 'Maximum video file size',
            category: 'video',
            isPublic: false
        },
        {
            key: 'video.allowedFormats',
            value: {
                formats: ['mp4', 'webm', 'mov', 'avi'],
                codecs: ['h264', 'vp9', 'vp8']
            },
            description: 'Allowed video formats and codecs',
            category: 'video',
            isPublic: true
        },
        {
            key: 'ai.defaultProvider',
            value: { provider: 'OPENAI' },
            description: 'Default AI provider for question generation',
            category: 'ai',
            isPublic: false
        },
        {
            key: 'grading.defaultRetryLimit',
            value: { retryLimit: 3 },
            description: 'Default number of retry attempts for questions',
            category: 'grading',
            isPublic: false
        },
        {
            key: 'grading.passingThreshold',
            value: { threshold: 0.7 },
            description: 'Default passing threshold (70%)',
            category: 'grading',
            isPublic: false
        },
        {
            key: 'analytics.enableTracking',
            value: { enabled: true },
            description: 'Enable analytics tracking',
            category: 'analytics',
            isPublic: false
        },
        {
            key: 'session.timeoutMinutes',
            value: { timeout: 30 },
            description: 'Session timeout in minutes',
            category: 'session',
            isPublic: false
        },
        {
            key: 'features.enableAIGeneration',
            value: { enabled: true },
            description: 'Enable AI question generation',
            category: 'features',
            isPublic: false
        }
    ];
    console.log('Creating system configurations...');
    for (const config of systemConfigs) {
        await prisma.systemConfig.upsert({
            where: { key: config.key },
            update: config,
            create: config
        });
    }
    const passwordHash = await bcrypt_1.default.hash('Demo123!', 10);
    const adminUser = await prisma.user.upsert({
        where: { email: 'admin@example.com' },
        update: {},
        create: {
            email: 'admin@example.com',
            firstName: 'System',
            lastName: 'Administrator',
            role: 'ADMIN',
            status: 'ACTIVE',
            passwordHash,
            emailVerified: new Date()
        }
    });
    const teacherUser = await prisma.user.upsert({
        where: { email: 'teacher@example.com' },
        update: {},
        create: {
            email: 'teacher@example.com',
            firstName: 'Demo',
            lastName: 'Teacher',
            role: 'TEACHER',
            status: 'ACTIVE',
            passwordHash,
            emailVerified: new Date()
        }
    });
    const studentUser = await prisma.user.upsert({
        where: { email: 'student@example.com' },
        update: {},
        create: {
            email: 'student@example.com',
            firstName: 'Demo',
            lastName: 'Student',
            role: 'STUDENT',
            status: 'ACTIVE',
            passwordHash,
            emailVerified: new Date()
        }
    });
    console.log('Created demo users:', {
        admin: adminUser.email,
        teacher: teacherUser.email,
        student: studentUser.email
    });
    await prisma.userPreference.upsert({
        where: { userId: studentUser.id },
        update: {},
        create: {
            userId: studentUser.id,
            autoplay: true,
            playbackSpeed: 1.0,
            subtitles: false,
            theme: 'light',
            language: 'en',
            emailNotifications: true,
            progressNotifications: true,
            allowAnalytics: true
        }
    });
    const aiConfig = await prisma.aIConfiguration.upsert({
        where: { id: 'default-openai' },
        update: {},
        create: {
            id: 'default-openai',
            provider: 'OPENAI',
            name: 'Default OpenAI Configuration',
            model: 'gpt-3.5-turbo',
            parameters: {
                temperature: 0.7,
                maxTokens: 2000,
                topP: 1.0,
                frequencyPenalty: 0.0,
                presencePenalty: 0.0
            },
            isActive: true,
            rateLimit: 60,
            maxTokens: 4000,
            costPerToken: 0.0000015
        }
    });
    console.log('Created AI configuration:', aiConfig.name);
    const demoLesson = await prisma.lesson.create({
        data: {
            title: 'Introduction to Interactive Learning',
            description: 'Learn how to use the interactive video platform effectively',
            status: 'PUBLISHED',
            order: 1,
            createdById: teacherUser.id,
            objectives: [
                'Understand the basics of interactive video learning',
                'Learn how to answer milestone questions',
                'Navigate the learning platform effectively'
            ],
            estimatedTime: 30,
            difficulty: 'beginner',
            tags: ['introduction', 'tutorial', 'basics'],
            publishedAt: new Date(),
            metadata: {
                category: 'Tutorial',
                isDemo: true
            }
        }
    });
    const videoGroup = await prisma.videoGroup.create({
        data: {
            lessonId: demoLesson.id,
            title: 'Getting Started',
            description: 'Introduction videos for new users',
            order: 1
        }
    });
    const demoVideo = await prisma.video.create({
        data: {
            videoGroupId: videoGroup.id,
            title: 'Welcome to Interactive Learning',
            description: 'A brief introduction to the platform features',
            order: 1,
            status: 'READY',
            gcsPath: 'demo/welcome-video.mp4',
            gcsUrl: 'https://storage.googleapis.com/demo-bucket/welcome-video.mp4',
            duration: 300,
            mimeType: 'video/mp4',
            thumbnailUrl: 'https://storage.googleapis.com/demo-bucket/welcome-thumbnail.jpg',
            metadata: {
                resolution: '1920x1080',
                bitrate: 2500,
                fps: 30
            },
            uploadedAt: new Date(),
            processedAt: new Date()
        }
    });
    const milestone1 = await prisma.milestone.create({
        data: {
            videoId: demoVideo.id,
            timestamp: 60.0,
            title: 'Platform Overview Check',
            description: 'Test your understanding of the platform overview',
            order: 1,
            isRequired: true,
            retryLimit: 3
        }
    });
    const milestone2 = await prisma.milestone.create({
        data: {
            videoId: demoVideo.id,
            timestamp: 180.0,
            title: 'Navigation Features Check',
            description: 'Verify you understand the navigation features',
            order: 2,
            isRequired: true,
            retryLimit: 3
        }
    });
    const question1 = await prisma.question.create({
        data: {
            milestoneId: milestone1.id,
            type: 'MULTIPLE_CHOICE',
            status: 'APPROVED',
            text: 'What is the main purpose of milestone questions in this platform?',
            explanation: 'Milestone questions ensure comprehension before allowing students to continue.',
            hints: [
                'Think about why the video pauses',
                'Consider the educational goal'
            ],
            difficulty: 'easy',
            questionData: {
                options: [
                    { id: '1', text: 'To pause the video randomly', isCorrect: false },
                    { id: '2', text: 'To ensure understanding before proceeding', isCorrect: true },
                    { id: '3', text: 'To make the video longer', isCorrect: false },
                    { id: '4', text: 'To test technical knowledge', isCorrect: false }
                ]
            },
            points: 1,
            passThreshold: 1.0,
            aiModel: 'gpt-3.5-turbo',
            aiPrompt: 'Generate a multiple choice question about milestone questions in educational videos',
            aiConfidence: 0.95
        }
    });
    const question2 = await prisma.question.create({
        data: {
            milestoneId: milestone2.id,
            type: 'TRUE_FALSE',
            status: 'APPROVED',
            text: 'Students can skip milestone questions if they find them too difficult.',
            explanation: 'Milestone questions are required and must be answered correctly to proceed.',
            hints: [
                'Think about the learning objectives',
                'Consider what happens when you answer incorrectly'
            ],
            difficulty: 'easy',
            questionData: {
                correctAnswer: false
            },
            points: 1,
            passThreshold: 1.0,
            aiModel: 'gpt-3.5-turbo',
            aiPrompt: 'Generate a true/false question about mandatory milestone questions',
            aiConfidence: 0.92
        }
    });
    console.log('Created demo lesson structure:', {
        lesson: demoLesson.title,
        videoGroup: videoGroup.title,
        video: demoVideo.title,
        milestones: 2,
        questions: 2
    });
    const studentProgress = await prisma.studentProgress.create({
        data: {
            studentId: studentUser.id,
            lessonId: demoLesson.id,
            isCompleted: false,
            completionPercent: 40.0,
            totalTimeSpent: 120,
            totalMilestones: 2,
            completedMilestones: 1,
            averageScore: 100.0,
            totalAttempts: 1,
            successfulAttempts: 1,
            progressData: {
                milestoneProgress: {
                    [milestone1.id]: {
                        completed: true,
                        attempts: 1,
                        score: 100,
                        timeSpent: 45
                    },
                    [milestone2.id]: {
                        completed: false,
                        attempts: 0,
                        score: 0,
                        timeSpent: 0
                    }
                },
                videoProgress: {
                    [demoVideo.id]: {
                        watchTime: 120,
                        completionPercentage: 40,
                        lastPosition: 120
                    }
                }
            }
        }
    });
    const studentSession = await prisma.studentSession.create({
        data: {
            studentId: studentUser.id,
            videoId: demoVideo.id,
            status: 'PAUSED',
            currentPosition: 120.0,
            lastMilestoneId: milestone1.id,
            completedMilestones: [milestone1.id],
            deviceInfo: {
                platform: 'Web',
                browser: 'Chrome',
                version: '91.0.4472.124',
                mobile: false,
                screenResolution: '1920x1080'
            },
            startedAt: new Date(Date.now() - 3600000),
            lastSeenAt: new Date(Date.now() - 1800000)
        }
    });
    const questionAttempt = await prisma.questionAttempt.create({
        data: {
            studentId: studentUser.id,
            questionId: question1.id,
            status: 'CORRECT',
            attemptNumber: 1,
            studentAnswer: { selectedOption: '2' },
            isCorrect: true,
            score: 1.0,
            timeSpent: 30,
            hintsUsed: [],
            feedback: 'Correct! Milestone questions ensure understanding.',
            submittedAt: new Date(Date.now() - 1800000)
        }
    });
    const grade = await prisma.grade.create({
        data: {
            studentId: studentUser.id,
            studentProgressId: studentProgress.id,
            totalPoints: 2,
            earnedPoints: 1,
            percentageScore: 50.0,
            status: 'IN_PROGRESS',
            totalAttempts: 1,
            remainingAttempts: 2,
            gradeBreakdown: {
                milestones: {
                    [milestone1.id]: {
                        totalPoints: 1,
                        earnedPoints: 1,
                        percentage: 100,
                        attempts: 1
                    },
                    [milestone2.id]: {
                        totalPoints: 1,
                        earnedPoints: 0,
                        percentage: 0,
                        attempts: 0
                    }
                },
                questionTypes: {
                    'MULTIPLE_CHOICE': {
                        totalQuestions: 1,
                        correctAnswers: 1,
                        averageScore: 100
                    },
                    'TRUE_FALSE': {
                        totalQuestions: 1,
                        correctAnswers: 0,
                        averageScore: 0
                    }
                },
                timeMetrics: {
                    totalTime: 30,
                    averageTimePerQuestion: 30,
                    efficiency: 0.85
                }
            }
        }
    });
    console.log('Created sample student progress and session data');
    const analyticsEvents = [
        {
            userId: studentUser.id,
            sessionId: studentSession.id,
            eventType: 'video_start',
            eventData: {
                videoId: demoVideo.id,
                position: 0,
                playbackSpeed: 1.0
            },
            context: {
                sessionId: studentSession.id,
                deviceType: 'desktop',
                browserName: 'Chrome',
                browserVersion: '91.0.4472.124',
                screenResolution: '1920x1080'
            },
            timestamp: new Date(Date.now() - 3600000)
        },
        {
            userId: studentUser.id,
            sessionId: studentSession.id,
            eventType: 'milestone_reached',
            eventData: {
                videoId: demoVideo.id,
                position: 60,
                milestoneId: milestone1.id
            },
            context: {
                sessionId: studentSession.id,
                deviceType: 'desktop',
                browserName: 'Chrome',
                browserVersion: '91.0.4472.124',
                screenResolution: '1920x1080'
            },
            timestamp: new Date(Date.now() - 3540000)
        },
        {
            userId: studentUser.id,
            sessionId: studentSession.id,
            eventType: 'question_attempt',
            eventData: {
                questionId: question1.id,
                questionType: 'MULTIPLE_CHOICE',
                attemptNumber: 1,
                correct: true,
                timeSpent: 30
            },
            context: {
                sessionId: studentSession.id,
                deviceType: 'desktop',
                browserName: 'Chrome',
                browserVersion: '91.0.4472.124',
                screenResolution: '1920x1080'
            },
            timestamp: new Date(Date.now() - 3510000)
        }
    ];
    for (const event of analyticsEvents) {
        await prisma.analyticsEvent.create({ data: event });
    }
    console.log('Created sample analytics events');
    await prisma.auditLog.create({
        data: {
            userId: teacherUser.id,
            action: 'CREATE',
            resource: 'lessons',
            resourceId: demoLesson.id,
            changes: {
                after: {
                    title: demoLesson.title,
                    status: 'PUBLISHED'
                }
            },
            metadata: {
                source: 'seed_script',
                reason: 'Initial demo content creation'
            }
        }
    });
    await prisma.auditLog.create({
        data: {
            userId: studentUser.id,
            action: 'LOGIN',
            resource: 'users',
            resourceId: studentUser.id,
            metadata: {
                source: 'seed_script',
                ipAddress: '127.0.0.1'
            }
        }
    });
    console.log('Created audit log entries');
    console.log('✅ Database seeding completed successfully!');
    console.log('\n📊 Seeding Summary:');
    console.log('- System configurations: 10');
    console.log('- Demo users: 3 (Admin, Teacher, Student)');
    console.log('- Demo lesson with video and milestones: 1');
    console.log('- Sample questions: 2');
    console.log('- Student progress tracking: Created');
    console.log('- Analytics events: 3');
    console.log('- Audit logs: 2');
    console.log('\n🔐 Demo Login Credentials:');
    console.log('Admin: admin@example.com / Demo123!');
    console.log('Teacher: teacher@example.com / Demo123!');
    console.log('Student: student@example.com / Demo123!');
}
main()
    .catch((e) => {
    console.error('❌ Error during seeding:', e);
    process.exit(1);
})
    .finally(async () => {
    await prisma.$disconnect();
});
//# sourceMappingURL=001_initial_data.js.map
</file>

<file path="database/seeds/001_initial_data.js.map">
{"version":3,"file":"001_initial_data.js","sourceRoot":"","sources":["001_initial_data.ts"],"names":[],"mappings":";;;;;AAIA,2CAA8C;AAC9C,oDAA4B;AAE5B,MAAM,MAAM,GAAG,IAAI,qBAAY,EAAE,CAAC;AAElC,KAAK,UAAU,IAAI;IACjB,OAAO,CAAC,GAAG,CAAC,iCAAiC,CAAC,CAAC;IAM/C,MAAM,aAAa,GAAG;QACpB;YACE,GAAG,EAAE,UAAU;YACf,KAAK,EAAE,EAAE,IAAI,EAAE,+BAA+B,EAAE;YAChD,WAAW,EAAE,kBAAkB;YAC/B,QAAQ,EAAE,SAAS;YACnB,QAAQ,EAAE,IAAI;SACf;QACD;YACE,GAAG,EAAE,aAAa;YAClB,KAAK,EAAE,EAAE,OAAO,EAAE,OAAO,EAAE;YAC3B,WAAW,EAAE,qBAAqB;YAClC,QAAQ,EAAE,SAAS;YACnB,QAAQ,EAAE,IAAI;SACf;QACD;YACE,GAAG,EAAE,mBAAmB;YACxB,KAAK,EAAE,EAAE,OAAO,EAAE,UAAU,EAAE;YAC9B,WAAW,EAAE,yBAAyB;YACtC,QAAQ,EAAE,OAAO;YACjB,QAAQ,EAAE,KAAK;SAChB;QACD;YACE,GAAG,EAAE,sBAAsB;YAC3B,KAAK,EAAE;gBACL,OAAO,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC;gBACtC,MAAM,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC;aAC/B;YACD,WAAW,EAAE,kCAAkC;YAC/C,QAAQ,EAAE,OAAO;YACjB,QAAQ,EAAE,IAAI;SACf;QACD;YACE,GAAG,EAAE,oBAAoB;YACzB,KAAK,EAAE,EAAE,QAAQ,EAAE,QAAQ,EAAE;YAC7B,WAAW,EAAE,6CAA6C;YAC1D,QAAQ,EAAE,IAAI;YACd,QAAQ,EAAE,KAAK;SAChB;QACD;YACE,GAAG,EAAE,2BAA2B;YAChC,KAAK,EAAE,EAAE,UAAU,EAAE,CAAC,EAAE;YACxB,WAAW,EAAE,gDAAgD;YAC7D,QAAQ,EAAE,SAAS;YACnB,QAAQ,EAAE,KAAK;SAChB;QACD;YACE,GAAG,EAAE,0BAA0B;YAC/B,KAAK,EAAE,EAAE,SAAS,EAAE,GAAG,EAAE;YACzB,WAAW,EAAE,iCAAiC;YAC9C,QAAQ,EAAE,SAAS;YACnB,QAAQ,EAAE,KAAK;SAChB;QACD;YACE,GAAG,EAAE,0BAA0B;YAC/B,KAAK,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE;YACxB,WAAW,EAAE,2BAA2B;YACxC,QAAQ,EAAE,WAAW;YACrB,QAAQ,EAAE,KAAK;SAChB;QACD;YACE,GAAG,EAAE,wBAAwB;YAC7B,KAAK,EAAE,EAAE,OAAO,EAAE,EAAE,EAAE;YACtB,WAAW,EAAE,4BAA4B;YACzC,QAAQ,EAAE,SAAS;YACnB,QAAQ,EAAE,KAAK;SAChB;QACD;YACE,GAAG,EAAE,6BAA6B;YAClC,KAAK,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE;YACxB,WAAW,EAAE,+BAA+B;YAC5C,QAAQ,EAAE,UAAU;YACpB,QAAQ,EAAE,KAAK;SAChB;KACF,CAAC;IAEF,OAAO,CAAC,GAAG,CAAC,mCAAmC,CAAC,CAAC;IACjD,KAAK,MAAM,MAAM,IAAI,aAAa,EAAE,CAAC;QACnC,MAAM,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC;YAC/B,KAAK,EAAE,EAAE,GAAG,EAAE,MAAM,CAAC,GAAG,EAAE;YAC1B,MAAM,EAAE,MAAM;YACd,MAAM,EAAE,MAAM;SACf,CAAC,CAAC;IACL,CAAC;IAMD,MAAM,YAAY,GAAG,MAAM,gBAAM,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;IAEvD,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;QACzC,KAAK,EAAE,EAAE,KAAK,EAAE,mBAAmB,EAAE;QACrC,MAAM,EAAE,EAAE;QACV,MAAM,EAAE;YACN,KAAK,EAAE,mBAAmB;YAC1B,SAAS,EAAE,QAAQ;YACnB,QAAQ,EAAE,eAAe;YACzB,IAAI,EAAE,OAAO;YACb,MAAM,EAAE,QAAQ;YAChB,YAAY;YACZ,aAAa,EAAE,IAAI,IAAI,EAAE;SAC1B;KACF,CAAC,CAAC;IAEH,MAAM,WAAW,GAAG,MAAM,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;QAC3C,KAAK,EAAE,EAAE,KAAK,EAAE,qBAAqB,EAAE;QACvC,MAAM,EAAE,EAAE;QACV,MAAM,EAAE;YACN,KAAK,EAAE,qBAAqB;YAC5B,SAAS,EAAE,MAAM;YACjB,QAAQ,EAAE,SAAS;YACnB,IAAI,EAAE,SAAS;YACf,MAAM,EAAE,QAAQ;YAChB,YAAY;YACZ,aAAa,EAAE,IAAI,IAAI,EAAE;SAC1B;KACF,CAAC,CAAC;IAEH,MAAM,WAAW,GAAG,MAAM,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;QAC3C,KAAK,EAAE,EAAE,KAAK,EAAE,qBAAqB,EAAE;QACvC,MAAM,EAAE,EAAE;QACV,MAAM,EAAE;YACN,KAAK,EAAE,qBAAqB;YAC5B,SAAS,EAAE,MAAM;YACjB,QAAQ,EAAE,SAAS;YACnB,IAAI,EAAE,SAAS;YACf,MAAM,EAAE,QAAQ;YAChB,YAAY;YACZ,aAAa,EAAE,IAAI,IAAI,EAAE;SAC1B;KACF,CAAC,CAAC;IAEH,OAAO,CAAC,GAAG,CAAC,qBAAqB,EAAE;QACjC,KAAK,EAAE,SAAS,CAAC,KAAK;QACtB,OAAO,EAAE,WAAW,CAAC,KAAK;QAC1B,OAAO,EAAE,WAAW,CAAC,KAAK;KAC3B,CAAC,CAAC;IAMH,MAAM,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC;QACjC,KAAK,EAAE,EAAE,MAAM,EAAE,WAAW,CAAC,EAAE,EAAE;QACjC,MAAM,EAAE,EAAE;QACV,MAAM,EAAE;YACN,MAAM,EAAE,WAAW,CAAC,EAAE;YACtB,QAAQ,EAAE,IAAI;YACd,aAAa,EAAE,GAAG;YAClB,SAAS,EAAE,KAAK;YAChB,KAAK,EAAE,OAAO;YACd,QAAQ,EAAE,IAAI;YACd,kBAAkB,EAAE,IAAI;YACxB,qBAAqB,EAAE,IAAI;YAC3B,cAAc,EAAE,IAAI;SACrB;KACF,CAAC,CAAC;IAMH,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,eAAe,CAAC,MAAM,CAAC;QACnD,KAAK,EAAE,EAAE,EAAE,EAAE,gBAAgB,EAAE;QAC/B,MAAM,EAAE,EAAE;QACV,MAAM,EAAE;YACN,EAAE,EAAE,gBAAgB;YACpB,QAAQ,EAAE,QAAQ;YAClB,IAAI,EAAE,8BAA8B;YACpC,KAAK,EAAE,eAAe;YACtB,UAAU,EAAE;gBACV,WAAW,EAAE,GAAG;gBAChB,SAAS,EAAE,IAAI;gBACf,IAAI,EAAE,GAAG;gBACT,gBAAgB,EAAE,GAAG;gBACrB,eAAe,EAAE,GAAG;aACrB;YACD,QAAQ,EAAE,IAAI;YACd,SAAS,EAAE,EAAE;YACb,SAAS,EAAE,IAAI;YACf,YAAY,EAAE,SAAS;SACxB;KACF,CAAC,CAAC;IAEH,OAAO,CAAC,GAAG,CAAC,2BAA2B,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC;IAMxD,MAAM,UAAU,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC;QAC5C,IAAI,EAAE;YACJ,KAAK,EAAE,sCAAsC;YAC7C,WAAW,EAAE,6DAA6D;YAC1E,MAAM,EAAE,WAAW;YACnB,KAAK,EAAE,CAAC;YACR,WAAW,EAAE,WAAW,CAAC,EAAE;YAC3B,UAAU,EAAE;gBACV,qDAAqD;gBACrD,yCAAyC;gBACzC,4CAA4C;aAC7C;YACD,aAAa,EAAE,EAAE;YACjB,UAAU,EAAE,UAAU;YACtB,IAAI,EAAE,CAAC,cAAc,EAAE,UAAU,EAAE,QAAQ,CAAC;YAC5C,WAAW,EAAE,IAAI,IAAI,EAAE;YACvB,QAAQ,EAAE;gBACR,QAAQ,EAAE,UAAU;gBACpB,MAAM,EAAE,IAAI;aACb;SACF;KACF,CAAC,CAAC;IAEH,MAAM,UAAU,GAAG,MAAM,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC;QAChD,IAAI,EAAE;YACJ,QAAQ,EAAE,UAAU,CAAC,EAAE;YACvB,KAAK,EAAE,iBAAiB;YACxB,WAAW,EAAE,mCAAmC;YAChD,KAAK,EAAE,CAAC;SACT;KACF,CAAC,CAAC;IAEH,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC;QAC1C,IAAI,EAAE;YACJ,YAAY,EAAE,UAAU,CAAC,EAAE;YAC3B,KAAK,EAAE,iCAAiC;YACxC,WAAW,EAAE,+CAA+C;YAC5D,KAAK,EAAE,CAAC;YACR,MAAM,EAAE,OAAO;YACf,OAAO,EAAE,wBAAwB;YACjC,MAAM,EAAE,8DAA8D;YACtE,QAAQ,EAAE,GAAG;YACb,QAAQ,EAAE,WAAW;YACrB,YAAY,EAAE,kEAAkE;YAChF,QAAQ,EAAE;gBACR,UAAU,EAAE,WAAW;gBACvB,OAAO,EAAE,IAAI;gBACb,GAAG,EAAE,EAAE;aACR;YACD,UAAU,EAAE,IAAI,IAAI,EAAE;YACtB,WAAW,EAAE,IAAI,IAAI,EAAE;SACxB;KACF,CAAC,CAAC;IAGH,MAAM,UAAU,GAAG,MAAM,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC;QAC/C,IAAI,EAAE;YACJ,OAAO,EAAE,SAAS,CAAC,EAAE;YACrB,SAAS,EAAE,IAAI;YACf,KAAK,EAAE,yBAAyB;YAChC,WAAW,EAAE,kDAAkD;YAC/D,KAAK,EAAE,CAAC;YACR,UAAU,EAAE,IAAI;YAChB,UAAU,EAAE,CAAC;SACd;KACF,CAAC,CAAC;IAEH,MAAM,UAAU,GAAG,MAAM,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC;QAC/C,IAAI,EAAE;YACJ,OAAO,EAAE,SAAS,CAAC,EAAE;YACrB,SAAS,EAAE,KAAK;YAChB,KAAK,EAAE,2BAA2B;YAClC,WAAW,EAAE,+CAA+C;YAC5D,KAAK,EAAE,CAAC;YACR,UAAU,EAAE,IAAI;YAChB,UAAU,EAAE,CAAC;SACd;KACF,CAAC,CAAC;IAGH,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;QAC7C,IAAI,EAAE;YACJ,WAAW,EAAE,UAAU,CAAC,EAAE;YAC1B,IAAI,EAAE,iBAAiB;YACvB,MAAM,EAAE,UAAU;YAClB,IAAI,EAAE,mEAAmE;YACzE,WAAW,EAAE,gFAAgF;YAC7F,KAAK,EAAE;gBACL,kCAAkC;gBAClC,+BAA+B;aAChC;YACD,UAAU,EAAE,MAAM;YAClB,YAAY,EAAE;gBACZ,OAAO,EAAE;oBACP,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,6BAA6B,EAAE,SAAS,EAAE,KAAK,EAAE;oBAClE,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,2CAA2C,EAAE,SAAS,EAAE,IAAI,EAAE;oBAC/E,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,0BAA0B,EAAE,SAAS,EAAE,KAAK,EAAE;oBAC/D,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,6BAA6B,EAAE,SAAS,EAAE,KAAK,EAAE;iBACnE;aACF;YACD,MAAM,EAAE,CAAC;YACT,aAAa,EAAE,GAAG;YAClB,OAAO,EAAE,eAAe;YACxB,QAAQ,EAAE,qFAAqF;YAC/F,YAAY,EAAE,IAAI;SACnB;KACF,CAAC,CAAC;IAEH,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;QAC7C,IAAI,EAAE;YACJ,WAAW,EAAE,UAAU,CAAC,EAAE;YAC1B,IAAI,EAAE,YAAY;YAClB,MAAM,EAAE,UAAU;YAClB,IAAI,EAAE,wEAAwE;YAC9E,WAAW,EAAE,6EAA6E;YAC1F,KAAK,EAAE;gBACL,qCAAqC;gBACrC,mDAAmD;aACpD;YACD,UAAU,EAAE,MAAM;YAClB,YAAY,EAAE;gBACZ,aAAa,EAAE,KAAK;aACrB;YACD,MAAM,EAAE,CAAC;YACT,aAAa,EAAE,GAAG;YAClB,OAAO,EAAE,eAAe;YACxB,QAAQ,EAAE,oEAAoE;YAC9E,YAAY,EAAE,IAAI;SACnB;KACF,CAAC,CAAC;IAEH,OAAO,CAAC,GAAG,CAAC,gCAAgC,EAAE;QAC5C,MAAM,EAAE,UAAU,CAAC,KAAK;QACxB,UAAU,EAAE,UAAU,CAAC,KAAK;QAC5B,KAAK,EAAE,SAAS,CAAC,KAAK;QACtB,UAAU,EAAE,CAAC;QACb,SAAS,EAAE,CAAC;KACb,CAAC,CAAC;IAMH,MAAM,eAAe,GAAG,MAAM,MAAM,CAAC,eAAe,CAAC,MAAM,CAAC;QAC1D,IAAI,EAAE;YACJ,SAAS,EAAE,WAAW,CAAC,EAAE;YACzB,QAAQ,EAAE,UAAU,CAAC,EAAE;YACvB,WAAW,EAAE,KAAK;YAClB,iBAAiB,EAAE,IAAI;YACvB,cAAc,EAAE,GAAG;YACnB,eAAe,EAAE,CAAC;YAClB,mBAAmB,EAAE,CAAC;YACtB,YAAY,EAAE,KAAK;YACnB,aAAa,EAAE,CAAC;YAChB,kBAAkB,EAAE,CAAC;YACrB,YAAY,EAAE;gBACZ,iBAAiB,EAAE;oBACjB,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE;wBACf,SAAS,EAAE,IAAI;wBACf,QAAQ,EAAE,CAAC;wBACX,KAAK,EAAE,GAAG;wBACV,SAAS,EAAE,EAAE;qBACd;oBACD,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE;wBACf,SAAS,EAAE,KAAK;wBAChB,QAAQ,EAAE,CAAC;wBACX,KAAK,EAAE,CAAC;wBACR,SAAS,EAAE,CAAC;qBACb;iBACF;gBACD,aAAa,EAAE;oBACb,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE;wBACd,SAAS,EAAE,GAAG;wBACd,oBAAoB,EAAE,EAAE;wBACxB,YAAY,EAAE,GAAG;qBAClB;iBACF;aACF;SACF;KACF,CAAC,CAAC;IAGH,MAAM,cAAc,GAAG,MAAM,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC;QACxD,IAAI,EAAE;YACJ,SAAS,EAAE,WAAW,CAAC,EAAE;YACzB,OAAO,EAAE,SAAS,CAAC,EAAE;YACrB,MAAM,EAAE,QAAQ;YAChB,eAAe,EAAE,KAAK;YACtB,eAAe,EAAE,UAAU,CAAC,EAAE;YAC9B,mBAAmB,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC;YACpC,UAAU,EAAE;gBACV,QAAQ,EAAE,KAAK;gBACf,OAAO,EAAE,QAAQ;gBACjB,OAAO,EAAE,eAAe;gBACxB,MAAM,EAAE,KAAK;gBACb,gBAAgB,EAAE,WAAW;aAC9B;YACD,SAAS,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,OAAO,CAAC;YACzC,UAAU,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,OAAO,CAAC;SAC3C;KACF,CAAC,CAAC;IAGH,MAAM,eAAe,GAAG,MAAM,MAAM,CAAC,eAAe,CAAC,MAAM,CAAC;QAC1D,IAAI,EAAE;YACJ,SAAS,EAAE,WAAW,CAAC,EAAE;YACzB,UAAU,EAAE,SAAS,CAAC,EAAE;YACxB,MAAM,EAAE,SAAS;YACjB,aAAa,EAAE,CAAC;YAChB,aAAa,EAAE,EAAE,cAAc,EAAE,GAAG,EAAE;YACtC,SAAS,EAAE,IAAI;YACf,KAAK,EAAE,GAAG;YACV,SAAS,EAAE,EAAE;YACb,SAAS,EAAE,EAAE;YACb,QAAQ,EAAE,oDAAoD;YAC9D,WAAW,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,OAAO,CAAC;SAC5C;KACF,CAAC,CAAC;IAGH,MAAM,KAAK,GAAG,MAAM,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC;QACtC,IAAI,EAAE;YACJ,SAAS,EAAE,WAAW,CAAC,EAAE;YACzB,iBAAiB,EAAE,eAAe,CAAC,EAAE;YACrC,WAAW,EAAE,CAAC;YACd,YAAY,EAAE,CAAC;YACf,eAAe,EAAE,IAAI;YACrB,MAAM,EAAE,aAAa;YACrB,aAAa,EAAE,CAAC;YAChB,iBAAiB,EAAE,CAAC;YACpB,cAAc,EAAE;gBACd,UAAU,EAAE;oBACV,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE;wBACf,WAAW,EAAE,CAAC;wBACd,YAAY,EAAE,CAAC;wBACf,UAAU,EAAE,GAAG;wBACf,QAAQ,EAAE,CAAC;qBACZ;oBACD,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE;wBACf,WAAW,EAAE,CAAC;wBACd,YAAY,EAAE,CAAC;wBACf,UAAU,EAAE,CAAC;wBACb,QAAQ,EAAE,CAAC;qBACZ;iBACF;gBACD,aAAa,EAAE;oBACb,iBAAiB,EAAE;wBACjB,cAAc,EAAE,CAAC;wBACjB,cAAc,EAAE,CAAC;wBACjB,YAAY,EAAE,GAAG;qBAClB;oBACD,YAAY,EAAE;wBACZ,cAAc,EAAE,CAAC;wBACjB,cAAc,EAAE,CAAC;wBACjB,YAAY,EAAE,CAAC;qBAChB;iBACF;gBACD,WAAW,EAAE;oBACX,SAAS,EAAE,EAAE;oBACb,sBAAsB,EAAE,EAAE;oBAC1B,UAAU,EAAE,IAAI;iBACjB;aACF;SACF;KACF,CAAC,CAAC;IAEH,OAAO,CAAC,GAAG,CAAC,kDAAkD,CAAC,CAAC;IAMhE,MAAM,eAAe,GAAG;QACtB;YACE,MAAM,EAAE,WAAW,CAAC,EAAE;YACtB,SAAS,EAAE,cAAc,CAAC,EAAE;YAC5B,SAAS,EAAE,aAAa;YACxB,SAAS,EAAE;gBACT,OAAO,EAAE,SAAS,CAAC,EAAE;gBACrB,QAAQ,EAAE,CAAC;gBACX,aAAa,EAAE,GAAG;aACnB;YACD,OAAO,EAAE;gBACP,SAAS,EAAE,cAAc,CAAC,EAAE;gBAC5B,UAAU,EAAE,SAAS;gBACrB,WAAW,EAAE,QAAQ;gBACrB,cAAc,EAAE,eAAe;gBAC/B,gBAAgB,EAAE,WAAW;aAC9B;YACD,SAAS,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,OAAO,CAAC;SAC1C;QACD;YACE,MAAM,EAAE,WAAW,CAAC,EAAE;YACtB,SAAS,EAAE,cAAc,CAAC,EAAE;YAC5B,SAAS,EAAE,mBAAmB;YAC9B,SAAS,EAAE;gBACT,OAAO,EAAE,SAAS,CAAC,EAAE;gBACrB,QAAQ,EAAE,EAAE;gBACZ,WAAW,EAAE,UAAU,CAAC,EAAE;aAC3B;YACD,OAAO,EAAE;gBACP,SAAS,EAAE,cAAc,CAAC,EAAE;gBAC5B,UAAU,EAAE,SAAS;gBACrB,WAAW,EAAE,QAAQ;gBACrB,cAAc,EAAE,eAAe;gBAC/B,gBAAgB,EAAE,WAAW;aAC9B;YACD,SAAS,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,OAAO,CAAC;SAC1C;QACD;YACE,MAAM,EAAE,WAAW,CAAC,EAAE;YACtB,SAAS,EAAE,cAAc,CAAC,EAAE;YAC5B,SAAS,EAAE,kBAAkB;YAC7B,SAAS,EAAE;gBACT,UAAU,EAAE,SAAS,CAAC,EAAE;gBACxB,YAAY,EAAE,iBAAiB;gBAC/B,aAAa,EAAE,CAAC;gBAChB,OAAO,EAAE,IAAI;gBACb,SAAS,EAAE,EAAE;aACd;YACD,OAAO,EAAE;gBACP,SAAS,EAAE,cAAc,CAAC,EAAE;gBAC5B,UAAU,EAAE,SAAS;gBACrB,WAAW,EAAE,QAAQ;gBACrB,cAAc,EAAE,eAAe;gBAC/B,gBAAgB,EAAE,WAAW;aAC9B;YACD,SAAS,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,OAAO,CAAC;SAC1C;KACF,CAAC;IAEF,KAAK,MAAM,KAAK,IAAI,eAAe,EAAE,CAAC;QACpC,MAAM,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;IACtD,CAAC;IAED,OAAO,CAAC,GAAG,CAAC,iCAAiC,CAAC,CAAC;IAM/C,MAAM,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;QAC3B,IAAI,EAAE;YACJ,MAAM,EAAE,WAAW,CAAC,EAAE;YACtB,MAAM,EAAE,QAAQ;YAChB,QAAQ,EAAE,SAAS;YACnB,UAAU,EAAE,UAAU,CAAC,EAAE;YACzB,OAAO,EAAE;gBACP,KAAK,EAAE;oBACL,KAAK,EAAE,UAAU,CAAC,KAAK;oBACvB,MAAM,EAAE,WAAW;iBACpB;aACF;YACD,QAAQ,EAAE;gBACR,MAAM,EAAE,aAAa;gBACrB,MAAM,EAAE,+BAA+B;aACxC;SACF;KACF,CAAC,CAAC;IAEH,MAAM,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;QAC3B,IAAI,EAAE;YACJ,MAAM,EAAE,WAAW,CAAC,EAAE;YACtB,MAAM,EAAE,OAAO;YACf,QAAQ,EAAE,OAAO;YACjB,UAAU,EAAE,WAAW,CAAC,EAAE;YAC1B,QAAQ,EAAE;gBACR,MAAM,EAAE,aAAa;gBACrB,SAAS,EAAE,WAAW;aACvB;SACF;KACF,CAAC,CAAC;IAEH,OAAO,CAAC,GAAG,CAAC,2BAA2B,CAAC,CAAC;IAEzC,OAAO,CAAC,GAAG,CAAC,4CAA4C,CAAC,CAAC;IAG1D,OAAO,CAAC,GAAG,CAAC,uBAAuB,CAAC,CAAC;IACrC,OAAO,CAAC,GAAG,CAAC,6BAA6B,CAAC,CAAC;IAC3C,OAAO,CAAC,GAAG,CAAC,2CAA2C,CAAC,CAAC;IACzD,OAAO,CAAC,GAAG,CAAC,4CAA4C,CAAC,CAAC;IAC1D,OAAO,CAAC,GAAG,CAAC,uBAAuB,CAAC,CAAC;IACrC,OAAO,CAAC,GAAG,CAAC,sCAAsC,CAAC,CAAC;IACpD,OAAO,CAAC,GAAG,CAAC,uBAAuB,CAAC,CAAC;IACrC,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;IAE/B,OAAO,CAAC,GAAG,CAAC,8BAA8B,CAAC,CAAC;IAC5C,OAAO,CAAC,GAAG,CAAC,qCAAqC,CAAC,CAAC;IACnD,OAAO,CAAC,GAAG,CAAC,yCAAyC,CAAC,CAAC;IACvD,OAAO,CAAC,GAAG,CAAC,yCAAyC,CAAC,CAAC;AACzD,CAAC;AAED,IAAI,EAAE;KACH,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE;IACX,OAAO,CAAC,KAAK,CAAC,yBAAyB,EAAE,CAAC,CAAC,CAAC;IAC5C,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC;KACD,OAAO,CAAC,KAAK,IAAI,EAAE;IAClB,MAAM,MAAM,CAAC,WAAW,EAAE,CAAC;AAC7B,CAAC,CAAC,CAAC"}
</file>

<file path="database/README.md">
# Interactive Learning Platform - Database Schema

A comprehensive PostgreSQL database schema designed for a multi-tenant, video-based interactive learning platform with AI-generated questions and real-time progress tracking.

## 🏗️ Architecture Overview

### Core Design Principles

1. **Multi-Tenancy**: Support for isolated data across multiple organizations/tenants
2. **Role-Based Access**: Hierarchical permissions (Students, Teachers, Admins)
3. **Scalable Performance**: Optimized indexes for concurrent video streaming and analytics
4. **AI Integration**: Comprehensive workflow for AI-generated questions with human review
5. **Cross-Device Continuity**: Session persistence across devices and browsers
6. **Real-Time Analytics**: Event tracking for learning analytics and system monitoring

### Technology Stack

- **Database**: PostgreSQL 14+
- **ORM**: Prisma (TypeScript)
- **Extensions**: UUID, pg_trgm (text search), btree_gin (JSONB indexing)

## 📊 Schema Structure

### 1. User Management & Authentication

#### Tables:
- **`users`**: Core user data with multi-tenant support
- **`user_preferences`**: Personalization settings and learning preferences

#### Features:
- Email verification workflow
- Role-based permissions (Student, Teacher, Admin)
- Multi-tenant data isolation
- Comprehensive user preferences

### 2. Content Hierarchy

```
Lessons (Course level)
  └── Video Groups (Chapters)
      └── Videos (Individual content)
          └── Milestones (Interactive checkpoints)
              └── Questions (AI-generated assessments)
```

#### Tables:
- **`lessons`**: Top-level content organization
- **`video_groups`**: Logical grouping of related videos
- **`videos`**: Individual video content with Google Cloud Storage integration
- **`milestones`**: Interactive checkpoints within videos
- **`questions`**: AI-generated questions with approval workflow

#### Features:
- Google Cloud Storage integration for video files
- Flexible metadata storage (JSONB)
- Content versioning and approval workflow
- Rich text search capabilities

### 3. AI Question Management

#### Workflow:
1. **Generation**: AI creates questions based on video content and milestones
2. **Review**: Teachers review and approve/reject AI-generated questions
3. **Configuration**: Teachers set retry limits and grading criteria
4. **Deployment**: Approved questions become active in lessons

#### Tables:
- **`questions`**: Question content with AI metadata
- **`ai_configurations`**: AI provider settings and parameters
- **`ai_usage_logs`**: Cost tracking and performance monitoring

#### Supported Question Types:
- Multiple Choice
- True/False
- Short Answer
- Fill in the Blank
- Matching
- Ordering

### 4. Student Progress & Session Management

#### Tables:
- **`student_sessions`**: Cross-device session continuity
- **`student_progress`**: Overall lesson progress tracking
- **`question_attempts`**: Detailed attempt history
- **`grades`**: Comprehensive grading with configurable retry limits

#### Features:
- Real-time progress synchronization
- Cross-device session persistence
- Detailed attempt analytics
- Configurable retry limits
- Partial credit scoring

### 5. Analytics & Reporting

#### Tables:
- **`analytics_events`**: Comprehensive event tracking
- **`audit_logs`**: System audit trail
- **`system_configs`**: Dynamic system configuration

#### Event Types:
- Video playback events
- Question interactions
- Navigation tracking
- Performance metrics
- Error tracking

## 🚀 Performance Optimization

### Critical Indexes

1. **Video Streaming**:
   - Fast milestone lookup during playback
   - Efficient video metadata retrieval
   - Google Cloud Storage path optimization

2. **Student Progress**:
   - Cross-device session queries
   - Real-time progress updates
   - Completion tracking

3. **Analytics**:
   - Time-series event queries
   - User behavior analysis
   - Teacher dashboard metrics

4. **AI Workflow**:
   - Question review queue optimization
   - AI usage cost tracking
   - Performance monitoring

### JSONB Optimization

Strategic use of JSONB fields for:
- Question data flexibility across different types
- Video metadata and processing information
- Student progress tracking details
- Analytics event data
- User preferences and settings

## 📋 Setup Instructions

### 1. Install Dependencies

```bash
npm install prisma @prisma/client
npm install -D prisma-dbml-generator
```

### 2. Configure Database

```bash
# Set environment variable
export DATABASE_URL="postgresql://username:password@localhost:5432/learning_platform"
```

### 3. Run Migrations

```bash
# Generate Prisma client
npx prisma generate

# Run migrations
npx prisma migrate dev --name init

# Seed database with sample data
npx prisma db seed
```

### 4. Verify Setup

```bash
# Open Prisma Studio
npx prisma studio
```

## 🌱 Sample Data

The seed script creates:

- **3 Demo Users**: Admin, Teacher, Student (Password: `Demo123!`)
- **1 Complete Lesson**: With video, milestones, and questions
- **AI Configuration**: Default OpenAI setup
- **Sample Progress**: Partial student completion
- **Analytics Events**: User interaction tracking
- **System Configs**: Default platform settings

### Demo Login Credentials

| Role    | Email               | Password  |
|---------|---------------------|-----------|
| Admin   | admin@example.com   | Demo123!  |
| Teacher | teacher@example.com | Demo123!  |
| Student | student@example.com | Demo123!  |

## 🔍 Key Queries & Operations

### 1. Student Dashboard Query

```sql
-- Get student's active lessons with progress
SELECT 
    l.title,
    l.thumbnail,
    sp.completion_percent,
    sp.average_score,
    sp.updated_at as last_activity
FROM student_progress sp
JOIN lessons l ON sp.lesson_id = l.id
WHERE sp.student_id = $1 
  AND sp.completion_percent > 0
ORDER BY sp.updated_at DESC;
```

### 2. Video Milestone Lookup

```sql
-- Get milestones for video playback
SELECT 
    m.id,
    m.timestamp,
    m.title,
    m.is_required,
    COUNT(q.id) as question_count
FROM milestones m
LEFT JOIN questions q ON m.id = q.milestone_id 
  AND q.status = 'APPROVED'
WHERE m.video_id = $1
ORDER BY m.timestamp ASC;
```

### 3. Teacher Analytics Query

```sql
-- Get lesson performance analytics
SELECT 
    l.title,
    COUNT(DISTINCT sp.student_id) as enrolled_students,
    AVG(sp.completion_percent) as avg_completion,
    AVG(sp.average_score) as avg_score,
    AVG(sp.total_time_spent) as avg_time_spent
FROM lessons l
LEFT JOIN student_progress sp ON l.id = sp.lesson_id
WHERE l.created_by_id = $1
GROUP BY l.id, l.title
ORDER BY enrolled_students DESC;
```

### 4. AI Usage Cost Tracking

```sql
-- Monthly AI usage and cost summary
SELECT 
    DATE_TRUNC('month', created_at) as month,
    request_type,
    COUNT(*) as total_requests,
    SUM(tokens_used) as total_tokens,
    SUM(cost) as total_cost,
    AVG(response_time) as avg_response_time
FROM ai_usage_logs
WHERE created_at >= CURRENT_DATE - INTERVAL '6 months'
GROUP BY month, request_type
ORDER BY month DESC, total_cost DESC;
```

## 🔧 Configuration Management

### System Configuration

Dynamic configuration through `system_configs` table:

```typescript
// Video upload settings
await prisma.systemConfig.findUnique({
  where: { key: 'video.maxFileSize' }
});

// AI provider settings
await prisma.systemConfig.findUnique({
  where: { key: 'ai.defaultProvider' }
});

// Grading configuration
await prisma.systemConfig.findUnique({
  where: { key: 'grading.passingThreshold' }
});
```

### AI Provider Configuration

Support for multiple AI providers with dynamic switching:

```typescript
// Get active AI configuration
const aiConfig = await prisma.aIConfiguration.findFirst({
  where: { 
    isActive: true,
    provider: 'OPENAI'
  }
});
```

## 🛡️ Security Features

### 1. Multi-Tenancy
- Data isolation through `tenantId` fields
- Row-level security policies
- Tenant-specific user management

### 2. Audit Logging
- Comprehensive action tracking
- Change history preservation
- Security event monitoring

### 3. Data Protection
- Encrypted sensitive fields
- GDPR compliance support
- Secure session management

## 📈 Monitoring & Observability

### 1. Performance Metrics
- Query execution times
- Index usage statistics
- Connection pool monitoring

### 2. Business Metrics
- Student engagement rates
- Content completion statistics
- AI generation success rates

### 3. System Health
- Error rate tracking
- Response time monitoring
- Resource utilization

## 🚦 Best Practices

### 1. Query Optimization
- Use appropriate indexes for common queries
- Leverage JSONB indexes for flexible data
- Monitor query performance regularly

### 2. Data Consistency
- Use transactions for related operations
- Implement proper foreign key constraints
- Validate data integrity regularly

### 3. Scalability
- Partition large tables by date/tenant
- Implement read replicas for analytics
- Use connection pooling

## 📝 Migration Strategy

### Development Workflow
1. Make schema changes in Prisma schema
2. Generate migration: `npx prisma migrate dev`
3. Review generated SQL
4. Test with sample data

### Production Deployment
1. Backup database
2. Run migrations: `npx prisma migrate deploy`
3. Verify data integrity
4. Monitor performance

## 🤝 Contributing

When modifying the schema:

1. **Document Changes**: Update this README
2. **Update Types**: Regenerate TypeScript types
3. **Migration Review**: Review generated SQL carefully
4. **Index Optimization**: Consider query performance impact
5. **Seed Data**: Update seed scripts if needed

## 📚 Additional Resources

- [Prisma Documentation](https://www.prisma.io/docs)
- [PostgreSQL Performance Guide](https://www.postgresql.org/docs/current/performance-tips.html)
- [JSONB Best Practices](https://www.postgresql.org/docs/current/datatype-json.html)

---

*Generated for Interactive Learning Platform Database Schema v1.0.0*
</file>

<file path="database/SCHEMA_DESIGN.md">
# Database Schema Design Document

## Executive Summary

The Interactive Learning Platform database schema is designed to support a comprehensive video-based learning system with AI-generated questions, multi-tenancy, and real-time progress tracking. The schema prioritizes performance, scalability, and flexibility while maintaining data integrity and security.

## Design Decisions & Rationale

### 1. Multi-Tenancy Architecture

**Decision**: Implemented shared database with tenant isolation via `tenantId` fields
**Rationale**: 
- Cost-effective for moderate scale (1-1000 tenants)
- Simpler maintenance and backups
- Easier cross-tenant analytics when needed
- Row-Level Security (RLS) can be added later if needed

**Alternative Considered**: Database per tenant
**Why Rejected**: Higher operational overhead, complex analytics, resource inefficiency

### 2. Content Hierarchy Design

**Decision**: 4-level hierarchy: Lessons → Video Groups → Videos → Milestones → Questions
**Rationale**:
- Mirrors natural content organization
- Supports flexible course structures
- Allows for granular progress tracking
- Enables content reuse across lessons

**Key Benefits**:
- Teachers can organize content logically
- Students see clear learning progression
- Analytics can operate at multiple levels
- Supports both linear and branching content paths

### 3. JSONB Usage Strategy

**Decision**: Strategic use of JSONB for flexible, evolving data structures
**Implementation**:
- Question data (supports multiple question types)
- Video metadata (resolution, codecs, processing info)
- Student progress details (milestone-specific tracking)
- Analytics event data (flexible event schemas)
- User preferences (customizable settings)

**Rationale**:
- Prevents schema fragmentation
- Supports rapid feature development
- Enables complex querying with GIN indexes
- Maintains type safety with validation layers

### 4. Question Type Flexibility

**Decision**: Single `questions` table with type-specific data in JSONB
**Rationale**:
- Eliminates table explosion (6 question types = 1 table vs 6 tables)
- Consistent API interface
- Simplified relationship management
- Easy addition of new question types

**Type-Specific Data Structure**:
```typescript
interface QuestionData {
  // Multiple Choice
  options?: { id: string; text: string; isCorrect: boolean }[];
  
  // True/False
  correctAnswer?: boolean;
  
  // Short Answer
  acceptedAnswers?: string[];
  caseSensitive?: boolean;
  
  // Additional types...
}
```

### 5. AI Integration Architecture

**Decision**: Comprehensive AI workflow with human oversight
**Components**:
- AI configurations (multiple providers)
- Usage tracking (cost monitoring)
- Question generation workflow
- Human review and approval

**Benefits**:
- Cost control and monitoring
- Quality assurance through human review
- Provider flexibility (OpenAI, Claude, etc.)
- Detailed usage analytics

### 6. Session Management Design

**Decision**: Comprehensive cross-device session tracking
**Features**:
- Device fingerprinting
- Real-time position synchronization
- Milestone completion tracking
- Session state persistence

**Technical Implementation**:
- Unique constraint on (studentId, videoId)
- Last-seen timestamp for cleanup
- Device info for analytics
- JSONB for flexible session data

### 7. Performance Optimization Strategy

#### Index Strategy
1. **Composite Indexes**: For common multi-column queries
2. **Partial Indexes**: For filtered queries (active sessions, recent events)
3. **GIN Indexes**: For JSONB and array columns
4. **Text Search Indexes**: For content discovery

#### Critical Performance Paths
1. **Video Milestone Lookup**: `idx_milestones_video_timestamp`
2. **Student Progress**: `idx_student_progress_student_completion`
3. **Cross-Device Sync**: `idx_student_sessions_student_active`
4. **Teacher Analytics**: `idx_teacher_content_analytics`

### 8. Analytics Architecture

**Decision**: Event-driven analytics with flexible schema
**Benefits**:
- Real-time learning analytics
- Detailed user behavior tracking
- Performance monitoring
- A/B testing support

**Event Categories**:
- Learning events (video_start, milestone_reached, question_attempt)
- Navigation events (page_view, click_tracking)
- Performance events (load_time, error_occurred)
- System events (login, logout, session_timeout)

### 9. Grading System Design

**Decision**: Flexible grading with configurable retry limits
**Features**:
- Point-based scoring
- Partial credit support
- Retry limit configuration
- Grade breakdown analytics
- Multiple grading strategies

**Implementation Details**:
- Total/earned points tracking
- Percentage calculation
- Letter grade mapping
- Attempt counting
- Detailed breakdown in JSONB

### 10. Audit Logging Strategy

**Decision**: Comprehensive audit trail for security and compliance
**Scope**:
- All data modifications
- Authentication events
- Administrative actions
- System configuration changes

**Benefits**:
- GDPR compliance support
- Security monitoring
- Change history tracking
- Debugging and troubleshooting

## Scalability Considerations

### 1. Horizontal Scaling Strategies

**Read Replicas**: Analytics and reporting queries
**Partitioning**: Time-based partitioning for analytics_events and audit_logs
**Caching**: Redis for frequently accessed configuration and user data

### 2. Data Archival Strategy

**Hot Data**: Active sessions, current progress (< 90 days)
**Warm Data**: Completed lessons, historical progress (90 days - 2 years)
**Cold Data**: Archived analytics, old audit logs (> 2 years)

### 3. Performance Monitoring

**Key Metrics**:
- Query execution times
- Index usage statistics
- Table size growth
- Connection pool utilization
- Cache hit rates

## Security Architecture

### 1. Data Protection

**Encryption**: Sensitive fields (passwords, API keys)
**Access Control**: Role-based permissions
**Audit Logging**: All sensitive operations
**Data Minimization**: GDPR-compliant data retention

### 2. Multi-Tenant Security

**Data Isolation**: TenantId-based filtering
**API Security**: Tenant validation middleware
**Cross-Tenant Leaks**: Prevented through application logic

### 3. SQL Injection Prevention

**Parameterized Queries**: Prisma ORM protection
**Input Validation**: Zod schema validation
**Least Privilege**: Database user permissions

## Migration Strategy

### 1. Development Workflow

```bash
# 1. Schema changes in schema.prisma
# 2. Generate migration
npx prisma migrate dev --name descriptive_name

# 3. Review generated SQL
# 4. Test with seed data
# 5. Update TypeScript types
```

### 2. Production Deployment

```bash
# 1. Backup production database
# 2. Deploy in maintenance window
npx prisma migrate deploy

# 3. Verify data integrity
# 4. Monitor performance
```

### 3. Rollback Strategy

- Maintain backwards-compatible changes when possible
- Keep migration rollback scripts
- Database backup before major changes

## Monitoring and Observability

### 1. Database Metrics

**Performance Metrics**:
- Query response times
- Index hit ratios
- Lock contention
- Connection pool usage

**Business Metrics**:
- Student engagement rates
- Content completion rates
- AI generation success rates
- System error rates

### 2. Alerting Strategy

**Critical Alerts**:
- Database connection failures
- Query timeout increases
- Disk space warnings
- Replication lag

**Business Alerts**:
- Drop in user engagement
- AI generation failures
- Video processing errors

## Future Enhancements

### 1. Advanced Features

**Machine Learning**:
- Personalized learning paths
- Question difficulty adjustment
- Content recommendations

**Real-time Features**:
- Live video sessions
- Collaborative learning
- Real-time chat

### 2. Scalability Improvements

**Microservices Architecture**:
- Separate video processing service
- Dedicated analytics service
- AI service isolation

**Advanced Caching**:
- CDN for video content
- Application-level caching
- Database query caching

## Conclusion

The Interactive Learning Platform database schema provides a robust foundation for a comprehensive video-based learning system. The design balances performance, flexibility, and maintainability while supporting advanced features like AI-generated questions and real-time analytics.

Key strengths:
- Scalable multi-tenant architecture
- Flexible content hierarchy
- Comprehensive analytics and monitoring
- Strong security and audit capabilities
- Performance-optimized query patterns

The schema is designed to evolve with the platform's needs while maintaining data integrity and optimal performance.

---

*Database Schema Design Document v1.0.0*
*Interactive Learning Platform*
</file>

<file path="database/types.d.ts">
export declare enum UserRole {
    STUDENT = "STUDENT",
    TEACHER = "TEACHER",
    ADMIN = "ADMIN"
}
export declare enum UserStatus {
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE",
    SUSPENDED = "SUSPENDED",
    PENDING_VERIFICATION = "PENDING_VERIFICATION"
}
export declare enum LessonStatus {
    DRAFT = "DRAFT",
    PUBLISHED = "PUBLISHED",
    ARCHIVED = "ARCHIVED"
}
export declare enum VideoStatus {
    UPLOADING = "UPLOADING",
    PROCESSING = "PROCESSING",
    READY = "READY",
    ERROR = "ERROR"
}
export declare enum QuestionType {
    MULTIPLE_CHOICE = "MULTIPLE_CHOICE",
    TRUE_FALSE = "TRUE_FALSE",
    SHORT_ANSWER = "SHORT_ANSWER",
    FILL_IN_BLANK = "FILL_IN_BLANK",
    MATCHING = "MATCHING",
    ORDERING = "ORDERING"
}
export declare enum QuestionStatus {
    AI_GENERATED = "AI_GENERATED",
    PENDING_REVIEW = "PENDING_REVIEW",
    APPROVED = "APPROVED",
    REJECTED = "REJECTED",
    NEEDS_REVISION = "NEEDS_REVISION"
}
export declare enum SessionStatus {
    ACTIVE = "ACTIVE",
    PAUSED = "PAUSED",
    COMPLETED = "COMPLETED",
    ABANDONED = "ABANDONED"
}
export declare enum AttemptStatus {
    IN_PROGRESS = "IN_PROGRESS",
    SUBMITTED = "SUBMITTED",
    CORRECT = "CORRECT",
    INCORRECT = "INCORRECT",
    PARTIAL = "PARTIAL",
    TIMEOUT = "TIMEOUT"
}
export declare enum GradeStatus {
    IN_PROGRESS = "IN_PROGRESS",
    COMPLETED = "COMPLETED",
    FAILED = "FAILED",
    RETRY_ALLOWED = "RETRY_ALLOWED"
}
export declare enum AuditAction {
    CREATE = "CREATE",
    UPDATE = "UPDATE",
    DELETE = "DELETE",
    LOGIN = "LOGIN",
    LOGOUT = "LOGOUT",
    VIEW = "VIEW",
    DOWNLOAD = "DOWNLOAD",
    UPLOAD = "UPLOAD"
}
export declare enum AIProvider {
    OPENAI = "OPENAI",
    CLAUDE = "CLAUDE",
    GOOGLE_PALM = "GOOGLE_PALM",
    CUSTOM = "CUSTOM"
}
export interface BaseEntity {
    id: string;
    createdAt: Date;
    updatedAt: Date;
}
export interface TimestampedEntity extends BaseEntity {
    createdAt: Date;
    updatedAt: Date;
}
export interface User extends TimestampedEntity {
    email: string;
    username?: string;
    firstName: string;
    lastName: string;
    avatar?: string;
    role: UserRole;
    status: UserStatus;
    passwordHash: string;
    emailVerified?: Date;
    lastLoginAt?: Date;
    tenantId?: string;
    metadata?: Record<string, any>;
}
export interface UserPreference extends TimestampedEntity {
    userId: string;
    autoplay: boolean;
    playbackSpeed: number;
    subtitles: boolean;
    theme: string;
    language: string;
    emailNotifications: boolean;
    progressNotifications: boolean;
    allowAnalytics: boolean;
    customSettings?: Record<string, any>;
}
export interface Lesson extends TimestampedEntity {
    title: string;
    description?: string;
    thumbnail?: string;
    status: LessonStatus;
    order?: number;
    tenantId?: string;
    createdById: string;
    objectives: string[];
    estimatedTime?: number;
    difficulty?: string;
    tags: string[];
    metadata?: Record<string, any>;
    publishedAt?: Date;
}
export interface VideoGroup extends TimestampedEntity {
    lessonId: string;
    title: string;
    description?: string;
    order: number;
}
export interface Video extends TimestampedEntity {
    videoGroupId: string;
    title: string;
    description?: string;
    order: number;
    status: VideoStatus;
    gcsPath?: string;
    gcsUrl?: string;
    duration?: number;
    size?: bigint;
    mimeType?: string;
    processingStatus?: string;
    thumbnailUrl?: string;
    metadata?: Record<string, any>;
    uploadedAt?: Date;
    processedAt?: Date;
}
export interface Milestone extends TimestampedEntity {
    videoId: string;
    timestamp: number;
    title: string;
    description?: string;
    order: number;
    isRequired: boolean;
    retryLimit: number;
}
export interface QuestionData {
    options?: Array<{
        id: string;
        text: string;
        isCorrect: boolean;
    }>;
    correctAnswer?: boolean;
    acceptedAnswers?: string[];
    caseSensitive?: boolean;
    blanks?: Array<{
        position: number;
        acceptedAnswers: string[];
    }>;
    pairs?: Array<{
        left: string;
        right: string;
    }>;
    items?: Array<{
        id: string;
        text: string;
        correctOrder: number;
    }>;
    maxAttempts?: number;
    timeLimit?: number;
    partialCredit?: boolean;
}
export interface Question extends TimestampedEntity {
    milestoneId: string;
    type: QuestionType;
    status: QuestionStatus;
    text: string;
    explanation?: string;
    hints: string[];
    difficulty?: string;
    questionData: QuestionData;
    aiModel?: string;
    aiPrompt?: string;
    aiConfidence?: number;
    aiMetadata?: Record<string, any>;
    points: number;
    passThreshold: number;
    reviewedById?: string;
    reviewedAt?: Date;
    reviewNotes?: string;
}
export interface DeviceInfo {
    platform: string;
    browser: string;
    version: string;
    mobile: boolean;
    screenResolution?: string;
}
export interface BrowserInfo {
    name: string;
    version: string;
    engine: string;
    engineVersion: string;
}
export interface StudentSession extends TimestampedEntity {
    studentId: string;
    videoId: string;
    status: SessionStatus;
    currentPosition: number;
    lastMilestoneId?: string;
    completedMilestones: string[];
    deviceInfo?: DeviceInfo;
    browserInfo?: BrowserInfo;
    ipAddress?: string;
    userAgent?: string;
    sessionData?: Record<string, any>;
    startedAt: Date;
    lastSeenAt: Date;
    completedAt?: Date;
}
export interface ProgressData {
    milestoneProgress?: Record<string, {
        completed: boolean;
        attempts: number;
        score: number;
        timeSpent: number;
    }>;
    videoProgress?: Record<string, {
        watchTime: number;
        completionPercentage: number;
        lastPosition: number;
    }>;
    learningPath?: {
        currentStep: number;
        totalSteps: number;
        recommendedNext?: string[];
    };
    preferences?: {
        playbackSpeed: number;
        preferredQuestionTypes: QuestionType[];
    };
}
export interface StudentProgress extends TimestampedEntity {
    studentId: string;
    lessonId: string;
    isCompleted: boolean;
    completionPercent: number;
    totalTimeSpent: number;
    totalMilestones: number;
    completedMilestones: number;
    averageScore: number;
    totalAttempts: number;
    successfulAttempts: number;
    progressData?: ProgressData;
    startedAt: Date;
    completedAt?: Date;
}
export interface AttemptData {
    startTime: Date;
    endTime?: Date;
    hintsViewed: number;
    timeSpentReading: number;
    timeSpentAnswering: number;
    confidence?: number;
    difficulty?: number;
}
export interface QuestionAttempt extends TimestampedEntity {
    studentId: string;
    questionId: string;
    status: AttemptStatus;
    attemptNumber: number;
    studentAnswer: Record<string, any>;
    isCorrect?: boolean;
    score: number;
    timeSpent: number;
    hintsUsed: string[];
    feedback?: string;
    attemptData?: AttemptData;
    submittedAt?: Date;
}
export interface GradeBreakdown {
    milestones?: Record<string, {
        totalPoints: number;
        earnedPoints: number;
        percentage: number;
        attempts: number;
    }>;
    questionTypes?: Record<QuestionType, {
        totalQuestions: number;
        correctAnswers: number;
        averageScore: number;
    }>;
    timeMetrics?: {
        totalTime: number;
        averageTimePerQuestion: number;
        efficiency: number;
    };
    difficultyAnalysis?: Record<string, {
        questions: number;
        averageScore: number;
        averageTime: number;
    }>;
}
export interface Grade extends TimestampedEntity {
    studentId: string;
    studentProgressId: string;
    totalPoints: number;
    earnedPoints: number;
    percentageScore: number;
    letterGrade?: string;
    status: GradeStatus;
    totalAttempts: number;
    remainingAttempts: number;
    gradeBreakdown?: GradeBreakdown;
    finalizedAt?: Date;
}
export interface AnalyticsEventData {
    videoId?: string;
    position?: number;
    duration?: number;
    playbackSpeed?: number;
    quality?: string;
    questionId?: string;
    questionType?: QuestionType;
    attemptNumber?: number;
    correct?: boolean;
    timeSpent?: number;
    hintsUsed?: number;
    fromPage?: string;
    toPage?: string;
    navigationTime?: number;
    loadTime?: number;
    errorType?: string;
    errorMessage?: string;
    clickTarget?: string;
    scrollDepth?: number;
    keyboardShortcut?: string;
}
export interface AnalyticsContext {
    sessionId?: string;
    deviceType: string;
    browserName: string;
    browserVersion: string;
    screenResolution: string;
    connectionType?: string;
    geolocation?: {
        country: string;
        region: string;
        city: string;
    };
    referrer?: string;
    experimentVariant?: string;
}
export interface AnalyticsEvent extends BaseEntity {
    userId?: string;
    sessionId?: string;
    eventType: string;
    eventData: AnalyticsEventData;
    context?: AnalyticsContext;
    timestamp: Date;
    processingTime?: number;
}
export interface SystemConfig extends TimestampedEntity {
    key: string;
    value: Record<string, any>;
    description?: string;
    category?: string;
    isPublic: boolean;
}
export interface AuditChanges {
    before?: Record<string, any>;
    after?: Record<string, any>;
    fields?: string[];
}
export interface AuditMetadata {
    source: string;
    reason?: string;
    batchId?: string;
    ipAddress?: string;
    userAgent?: string;
    sessionId?: string;
}
export interface AuditLog extends BaseEntity {
    userId?: string;
    action: AuditAction;
    resource: string;
    resourceId?: string;
    changes?: AuditChanges;
    metadata?: AuditMetadata;
    ipAddress?: string;
    userAgent?: string;
    createdAt: Date;
}
export interface AIParameters {
    temperature?: number;
    maxTokens?: number;
    topP?: number;
    topK?: number;
    frequencyPenalty?: number;
    presencePenalty?: number;
    stopSequences?: string[];
    model?: string;
    custom?: Record<string, any>;
}
export interface AIConfiguration extends TimestampedEntity {
    provider: AIProvider;
    name: string;
    apiKey?: string;
    endpoint?: string;
    model: string;
    parameters?: AIParameters;
    isActive: boolean;
    rateLimit?: number;
    maxTokens?: number;
    costPerToken?: number;
    monthlyBudget?: number;
}
export interface AIUsageMetadata {
    requestId?: string;
    model?: string;
    context?: string;
    promptLength?: number;
    responseLength?: number;
    generationSettings?: AIParameters;
    qualityScore?: number;
}
export interface AIUsageLog extends BaseEntity {
    configurationId: string;
    requestType: string;
    prompt?: string;
    response?: string;
    tokensUsed: number;
    cost?: number;
    responseTime: number;
    success: boolean;
    errorMessage?: string;
    userId?: string;
    resourceId?: string;
    metadata?: AIUsageMetadata;
    createdAt: Date;
}
export type Paginated<T> = {
    items: T[];
    totalCount: number;
    pageSize: number;
    currentPage: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
};
export type SortOrder = 'asc' | 'desc';
export interface PaginationParams {
    page?: number;
    limit?: number;
    sortBy?: string;
    sortOrder?: SortOrder;
}
export interface FilterParams {
    search?: string;
    status?: string[];
    dateFrom?: Date;
    dateTo?: Date;
    tags?: string[];
    [key: string]: any;
}
export interface ApiResponse<T = any> {
    success: boolean;
    data?: T;
    error?: string;
    message?: string;
    timestamp: Date;
    requestId?: string;
}
export interface ValidationError {
    field: string;
    message: string;
    code: string;
}
export interface ApiError {
    code: string;
    message: string;
    details?: string;
    validationErrors?: ValidationError[];
    statusCode: number;
}
export interface UserWithPreferences extends User {
    userPreferences?: UserPreference;
}
export interface LessonWithDetails extends Lesson {
    createdBy: User;
    videoGroups: (VideoGroup & {
        videos: Video[];
    })[];
}
export interface VideoWithMilestones extends Video {
    milestones: (Milestone & {
        questions: Question[];
    })[];
}
export interface QuestionWithAttempts extends Question {
    attempts: QuestionAttempt[];
}
export interface StudentProgressWithGrades extends StudentProgress {
    grades: Grade[];
    lesson: Lesson;
}
export interface SessionWithVideo extends StudentSession {
    video: Video & {
        videoGroup: VideoGroup & {
            lesson: Lesson;
        };
    };
}
export interface TeacherDashboardData {
    totalLessons: number;
    publishedLessons: number;
    totalStudents: number;
    averageCompletion: number;
    recentActivity: AnalyticsEvent[];
    popularLessons: (Lesson & {
        studentCount: number;
        averageScore: number;
    })[];
    questionApprovalQueue: Question[];
}
export interface StudentDashboardData {
    enrolledLessons: number;
    completedLessons: number;
    totalProgress: number;
    averageScore: number;
    recentSessions: StudentSession[];
    recommendations: Lesson[];
    achievements: any[];
}
export interface AdminDashboardData {
    totalUsers: Record<UserRole, number>;
    systemHealth: {
        activeUsers: number;
        activeSessions: number;
        systemLoad: number;
        errorRate: number;
    };
    contentStats: {
        totalLessons: number;
        totalVideos: number;
        totalQuestions: number;
        pendingReviews: number;
    };
    aiUsage: {
        monthlyTokens: number;
        monthlyCost: number;
        successRate: number;
        averageResponseTime: number;
    };
}
export type { BaseEntity, TimestampedEntity, User, UserPreference, Lesson, VideoGroup, Video, Milestone, Question, QuestionData, StudentSession, StudentProgress, ProgressData, QuestionAttempt, Grade, GradeBreakdown, AnalyticsEvent, AnalyticsEventData, AnalyticsContext, SystemConfig, AuditLog, AuditChanges, AuditMetadata, AIConfiguration, AIParameters, AIUsageLog, AIUsageMetadata, Paginated, PaginationParams, FilterParams, ApiResponse, ApiError, ValidationError, UserWithPreferences, LessonWithDetails, VideoWithMilestones, QuestionWithAttempts, StudentProgressWithGrades, SessionWithVideo, TeacherDashboardData, StudentDashboardData, AdminDashboardData, DeviceInfo, BrowserInfo, AttemptData };
//# sourceMappingURL=types.d.ts.map
</file>

<file path="database/types.d.ts.map">
{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["types.ts"],"names":[],"mappings":"AAQA,oBAAY,QAAQ;IAClB,OAAO,YAAY;IACnB,OAAO,YAAY;IACnB,KAAK,UAAU;CAChB;AAED,oBAAY,UAAU;IACpB,MAAM,WAAW;IACjB,QAAQ,aAAa;IACrB,SAAS,cAAc;IACvB,oBAAoB,yBAAyB;CAC9C;AAED,oBAAY,YAAY;IACtB,KAAK,UAAU;IACf,SAAS,cAAc;IACvB,QAAQ,aAAa;CACtB;AAED,oBAAY,WAAW;IACrB,SAAS,cAAc;IACvB,UAAU,eAAe;IACzB,KAAK,UAAU;IACf,KAAK,UAAU;CAChB;AAED,oBAAY,YAAY;IACtB,eAAe,oBAAoB;IACnC,UAAU,eAAe;IACzB,YAAY,iBAAiB;IAC7B,aAAa,kBAAkB;IAC/B,QAAQ,aAAa;IACrB,QAAQ,aAAa;CACtB;AAED,oBAAY,cAAc;IACxB,YAAY,iBAAiB;IAC7B,cAAc,mBAAmB;IACjC,QAAQ,aAAa;IACrB,QAAQ,aAAa;IACrB,cAAc,mBAAmB;CAClC;AAED,oBAAY,aAAa;IACvB,MAAM,WAAW;IACjB,MAAM,WAAW;IACjB,SAAS,cAAc;IACvB,SAAS,cAAc;CACxB;AAED,oBAAY,aAAa;IACvB,WAAW,gBAAgB;IAC3B,SAAS,cAAc;IACvB,OAAO,YAAY;IACnB,SAAS,cAAc;IACvB,OAAO,YAAY;IACnB,OAAO,YAAY;CACpB;AAED,oBAAY,WAAW;IACrB,WAAW,gBAAgB;IAC3B,SAAS,cAAc;IACvB,MAAM,WAAW;IACjB,aAAa,kBAAkB;CAChC;AAED,oBAAY,WAAW;IACrB,MAAM,WAAW;IACjB,MAAM,WAAW;IACjB,MAAM,WAAW;IACjB,KAAK,UAAU;IACf,MAAM,WAAW;IACjB,IAAI,SAAS;IACb,QAAQ,aAAa;IACrB,MAAM,WAAW;CAClB;AAED,oBAAY,UAAU;IACpB,MAAM,WAAW;IACjB,MAAM,WAAW;IACjB,WAAW,gBAAgB;IAC3B,MAAM,WAAW;CAClB;AAMD,MAAM,WAAW,UAAU;IACzB,EAAE,EAAE,MAAM,CAAC;IACX,SAAS,EAAE,IAAI,CAAC;IAChB,SAAS,EAAE,IAAI,CAAC;CACjB;AAED,MAAM,WAAW,iBAAkB,SAAQ,UAAU;IACnD,SAAS,EAAE,IAAI,CAAC;IAChB,SAAS,EAAE,IAAI,CAAC;CACjB;AAMD,MAAM,WAAW,IAAK,SAAQ,iBAAiB;IAC7C,KAAK,EAAE,MAAM,CAAC;IACd,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,SAAS,EAAE,MAAM,CAAC;IAClB,QAAQ,EAAE,MAAM,CAAC;IACjB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,QAAQ,CAAC;IACf,MAAM,EAAE,UAAU,CAAC;IACnB,YAAY,EAAE,MAAM,CAAC;IACrB,aAAa,CAAC,EAAE,IAAI,CAAC;IACrB,WAAW,CAAC,EAAE,IAAI,CAAC;IACnB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;CAChC;AAED,MAAM,WAAW,cAAe,SAAQ,iBAAiB;IACvD,MAAM,EAAE,MAAM,CAAC;IACf,QAAQ,EAAE,OAAO,CAAC;IAClB,aAAa,EAAE,MAAM,CAAC;IACtB,SAAS,EAAE,OAAO,CAAC;IACnB,KAAK,EAAE,MAAM,CAAC;IACd,QAAQ,EAAE,MAAM,CAAC;IACjB,kBAAkB,EAAE,OAAO,CAAC;IAC5B,qBAAqB,EAAE,OAAO,CAAC;IAC/B,cAAc,EAAE,OAAO,CAAC;IACxB,cAAc,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;CACtC;AAMD,MAAM,WAAW,MAAO,SAAQ,iBAAiB;IAC/C,KAAK,EAAE,MAAM,CAAC;IACd,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,MAAM,EAAE,YAAY,CAAC;IACrB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,WAAW,EAAE,MAAM,CAAC;IACpB,UAAU,EAAE,MAAM,EAAE,CAAC;IACrB,aAAa,CAAC,EAAE,MAAM,CAAC;IACvB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,IAAI,EAAE,MAAM,EAAE,CAAC;IACf,QAAQ,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAC/B,WAAW,CAAC,EAAE,IAAI,CAAC;CACpB;AAED,MAAM,WAAW,UAAW,SAAQ,iBAAiB;IACnD,QAAQ,EAAE,MAAM,CAAC;IACjB,KAAK,EAAE,MAAM,CAAC;IACd,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,KAAK,EAAE,MAAM,CAAC;CACf;AAED,MAAM,WAAW,KAAM,SAAQ,iBAAiB;IAC9C,YAAY,EAAE,MAAM,CAAC;IACrB,KAAK,EAAE,MAAM,CAAC;IACd,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,KAAK,EAAE,MAAM,CAAC;IACd,MAAM,EAAE,WAAW,CAAC;IACpB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAC1B,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,QAAQ,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAC/B,UAAU,CAAC,EAAE,IAAI,CAAC;IAClB,WAAW,CAAC,EAAE,IAAI,CAAC;CACpB;AAED,MAAM,WAAW,SAAU,SAAQ,iBAAiB;IAClD,OAAO,EAAE,MAAM,CAAC;IAChB,SAAS,EAAE,MAAM,CAAC;IAClB,KAAK,EAAE,MAAM,CAAC;IACd,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,KAAK,EAAE,MAAM,CAAC;IACd,UAAU,EAAE,OAAO,CAAC;IACpB,UAAU,EAAE,MAAM,CAAC;CACpB;AAMD,MAAM,WAAW,YAAY;IAE3B,OAAO,CAAC,EAAE,KAAK,CAAC;QACd,EAAE,EAAE,MAAM,CAAC;QACX,IAAI,EAAE,MAAM,CAAC;QACb,SAAS,EAAE,OAAO,CAAC;KACpB,CAAC,CAAC;IAGH,aAAa,CAAC,EAAE,OAAO,CAAC;IAGxB,eAAe,CAAC,EAAE,MAAM,EAAE,CAAC;IAC3B,aAAa,CAAC,EAAE,OAAO,CAAC;IAGxB,MAAM,CAAC,EAAE,KAAK,CAAC;QACb,QAAQ,EAAE,MAAM,CAAC;QACjB,eAAe,EAAE,MAAM,EAAE,CAAC;KAC3B,CAAC,CAAC;IAGH,KAAK,CAAC,EAAE,KAAK,CAAC;QACZ,IAAI,EAAE,MAAM,CAAC;QACb,KAAK,EAAE,MAAM,CAAC;KACf,CAAC,CAAC;IAGH,KAAK,CAAC,EAAE,KAAK,CAAC;QACZ,EAAE,EAAE,MAAM,CAAC;QACX,IAAI,EAAE,MAAM,CAAC;QACb,YAAY,EAAE,MAAM,CAAC;KACtB,CAAC,CAAC;IAGH,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,aAAa,CAAC,EAAE,OAAO,CAAC;CACzB;AAED,MAAM,WAAW,QAAS,SAAQ,iBAAiB;IACjD,WAAW,EAAE,MAAM,CAAC;IACpB,IAAI,EAAE,YAAY,CAAC;IACnB,MAAM,EAAE,cAAc,CAAC;IACvB,IAAI,EAAE,MAAM,CAAC;IACb,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,KAAK,EAAE,MAAM,EAAE,CAAC;IAChB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,YAAY,EAAE,YAAY,CAAC;IAC3B,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,UAAU,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IACjC,MAAM,EAAE,MAAM,CAAC;IACf,aAAa,EAAE,MAAM,CAAC;IACtB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,UAAU,CAAC,EAAE,IAAI,CAAC;IAClB,WAAW,CAAC,EAAE,MAAM,CAAC;CACtB;AAMD,MAAM,WAAW,UAAU;IACzB,QAAQ,EAAE,MAAM,CAAC;IACjB,OAAO,EAAE,MAAM,CAAC;IAChB,OAAO,EAAE,MAAM,CAAC;IAChB,MAAM,EAAE,OAAO,CAAC;IAChB,gBAAgB,CAAC,EAAE,MAAM,CAAC;CAC3B;AAED,MAAM,WAAW,WAAW;IAC1B,IAAI,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,MAAM,CAAC;IAChB,MAAM,EAAE,MAAM,CAAC;IACf,aAAa,EAAE,MAAM,CAAC;CACvB;AAED,MAAM,WAAW,cAAe,SAAQ,iBAAiB;IACvD,SAAS,EAAE,MAAM,CAAC;IAClB,OAAO,EAAE,MAAM,CAAC;IAChB,MAAM,EAAE,aAAa,CAAC;IACtB,eAAe,EAAE,MAAM,CAAC;IACxB,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,mBAAmB,EAAE,MAAM,EAAE,CAAC;IAC9B,UAAU,CAAC,EAAE,UAAU,CAAC;IACxB,WAAW,CAAC,EAAE,WAAW,CAAC;IAC1B,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,WAAW,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAClC,SAAS,EAAE,IAAI,CAAC;IAChB,UAAU,EAAE,IAAI,CAAC;IACjB,WAAW,CAAC,EAAE,IAAI,CAAC;CACpB;AAED,MAAM,WAAW,YAAY;IAC3B,iBAAiB,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE;QACjC,SAAS,EAAE,OAAO,CAAC;QACnB,QAAQ,EAAE,MAAM,CAAC;QACjB,KAAK,EAAE,MAAM,CAAC;QACd,SAAS,EAAE,MAAM,CAAC;KACnB,CAAC,CAAC;IAEH,aAAa,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE;QAC7B,SAAS,EAAE,MAAM,CAAC;QAClB,oBAAoB,EAAE,MAAM,CAAC;QAC7B,YAAY,EAAE,MAAM,CAAC;KACtB,CAAC,CAAC;IAEH,YAAY,CAAC,EAAE;QACb,WAAW,EAAE,MAAM,CAAC;QACpB,UAAU,EAAE,MAAM,CAAC;QACnB,eAAe,CAAC,EAAE,MAAM,EAAE,CAAC;KAC5B,CAAC;IAEF,WAAW,CAAC,EAAE;QACZ,aAAa,EAAE,MAAM,CAAC;QACtB,sBAAsB,EAAE,YAAY,EAAE,CAAC;KACxC,CAAC;CACH;AAED,MAAM,WAAW,eAAgB,SAAQ,iBAAiB;IACxD,SAAS,EAAE,MAAM,CAAC;IAClB,QAAQ,EAAE,MAAM,CAAC;IACjB,WAAW,EAAE,OAAO,CAAC;IACrB,iBAAiB,EAAE,MAAM,CAAC;IAC1B,cAAc,EAAE,MAAM,CAAC;IACvB,eAAe,EAAE,MAAM,CAAC;IACxB,mBAAmB,EAAE,MAAM,CAAC;IAC5B,YAAY,EAAE,MAAM,CAAC;IACrB,aAAa,EAAE,MAAM,CAAC;IACtB,kBAAkB,EAAE,MAAM,CAAC;IAC3B,YAAY,CAAC,EAAE,YAAY,CAAC;IAC5B,SAAS,EAAE,IAAI,CAAC;IAChB,WAAW,CAAC,EAAE,IAAI,CAAC;CACpB;AAMD,MAAM,WAAW,WAAW;IAC1B,SAAS,EAAE,IAAI,CAAC;IAChB,OAAO,CAAC,EAAE,IAAI,CAAC;IACf,WAAW,EAAE,MAAM,CAAC;IACpB,gBAAgB,EAAE,MAAM,CAAC;IACzB,kBAAkB,EAAE,MAAM,CAAC;IAC3B,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,UAAU,CAAC,EAAE,MAAM,CAAC;CACrB;AAED,MAAM,WAAW,eAAgB,SAAQ,iBAAiB;IACxD,SAAS,EAAE,MAAM,CAAC;IAClB,UAAU,EAAE,MAAM,CAAC;IACnB,MAAM,EAAE,aAAa,CAAC;IACtB,aAAa,EAAE,MAAM,CAAC;IACtB,aAAa,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IACnC,SAAS,CAAC,EAAE,OAAO,CAAC;IACpB,KAAK,EAAE,MAAM,CAAC;IACd,SAAS,EAAE,MAAM,CAAC;IAClB,SAAS,EAAE,MAAM,EAAE,CAAC;IACpB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,WAAW,CAAC,EAAE,WAAW,CAAC;IAC1B,WAAW,CAAC,EAAE,IAAI,CAAC;CACpB;AAED,MAAM,WAAW,cAAc;IAC7B,UAAU,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE;QAC1B,WAAW,EAAE,MAAM,CAAC;QACpB,YAAY,EAAE,MAAM,CAAC;QACrB,UAAU,EAAE,MAAM,CAAC;QACnB,QAAQ,EAAE,MAAM,CAAC;KAClB,CAAC,CAAC;IAEH,aAAa,CAAC,EAAE,MAAM,CAAC,YAAY,EAAE;QACnC,cAAc,EAAE,MAAM,CAAC;QACvB,cAAc,EAAE,MAAM,CAAC;QACvB,YAAY,EAAE,MAAM,CAAC;KACtB,CAAC,CAAC;IAEH,WAAW,CAAC,EAAE;QACZ,SAAS,EAAE,MAAM,CAAC;QAClB,sBAAsB,EAAE,MAAM,CAAC;QAC/B,UAAU,EAAE,MAAM,CAAC;KACpB,CAAC;IAEF,kBAAkB,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE;QAClC,SAAS,EAAE,MAAM,CAAC;QAClB,YAAY,EAAE,MAAM,CAAC;QACrB,WAAW,EAAE,MAAM,CAAC;KACrB,CAAC,CAAC;CACJ;AAED,MAAM,WAAW,KAAM,SAAQ,iBAAiB;IAC9C,SAAS,EAAE,MAAM,CAAC;IAClB,iBAAiB,EAAE,MAAM,CAAC;IAC1B,WAAW,EAAE,MAAM,CAAC;IACpB,YAAY,EAAE,MAAM,CAAC;IACrB,eAAe,EAAE,MAAM,CAAC;IACxB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,MAAM,EAAE,WAAW,CAAC;IACpB,aAAa,EAAE,MAAM,CAAC;IACtB,iBAAiB,EAAE,MAAM,CAAC;IAC1B,cAAc,CAAC,EAAE,cAAc,CAAC;IAChC,WAAW,CAAC,EAAE,IAAI,CAAC;CACpB;AAMD,MAAM,WAAW,kBAAkB;IAEjC,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,aAAa,CAAC,EAAE,MAAM,CAAC;IACvB,OAAO,CAAC,EAAE,MAAM,CAAC;IAGjB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,YAAY,CAAC,EAAE,YAAY,CAAC;IAC5B,aAAa,CAAC,EAAE,MAAM,CAAC;IACvB,OAAO,CAAC,EAAE,OAAO,CAAC;IAClB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,CAAC,EAAE,MAAM,CAAC;IAGnB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,cAAc,CAAC,EAAE,MAAM,CAAC;IAGxB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,YAAY,CAAC,EAAE,MAAM,CAAC;IAGtB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,gBAAgB,CAAC,EAAE,MAAM,CAAC;CAC3B;AAED,MAAM,WAAW,gBAAgB;IAC/B,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,UAAU,EAAE,MAAM,CAAC;IACnB,WAAW,EAAE,MAAM,CAAC;IACpB,cAAc,EAAE,MAAM,CAAC;IACvB,gBAAgB,EAAE,MAAM,CAAC;IACzB,cAAc,CAAC,EAAE,MAAM,CAAC;IACxB,WAAW,CAAC,EAAE;QACZ,OAAO,EAAE,MAAM,CAAC;QAChB,MAAM,EAAE,MAAM,CAAC;QACf,IAAI,EAAE,MAAM,CAAC;KACd,CAAC;IACF,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,iBAAiB,CAAC,EAAE,MAAM,CAAC;CAC5B;AAED,MAAM,WAAW,cAAe,SAAQ,UAAU;IAChD,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,EAAE,MAAM,CAAC;IAClB,SAAS,EAAE,kBAAkB,CAAC;IAC9B,OAAO,CAAC,EAAE,gBAAgB,CAAC;IAC3B,SAAS,EAAE,IAAI,CAAC;IAChB,cAAc,CAAC,EAAE,MAAM,CAAC;CACzB;AAMD,MAAM,WAAW,YAAa,SAAQ,iBAAiB;IACrD,GAAG,EAAE,MAAM,CAAC;IACZ,KAAK,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAC3B,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,EAAE,OAAO,CAAC;CACnB;AAED,MAAM,WAAW,YAAY;IAC3B,MAAM,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAC7B,KAAK,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAC5B,MAAM,CAAC,EAAE,MAAM,EAAE,CAAC;CACnB;AAED,MAAM,WAAW,aAAa;IAC5B,MAAM,EAAE,MAAM,CAAC;IACf,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB;AAED,MAAM,WAAW,QAAS,SAAQ,UAAU;IAC1C,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,MAAM,EAAE,WAAW,CAAC;IACpB,QAAQ,EAAE,MAAM,CAAC;IACjB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,OAAO,CAAC,EAAE,YAAY,CAAC;IACvB,QAAQ,CAAC,EAAE,aAAa,CAAC;IACzB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,EAAE,IAAI,CAAC;CACjB;AAMD,MAAM,WAAW,YAAY;IAC3B,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAC1B,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,aAAa,CAAC,EAAE,MAAM,EAAE,CAAC;IACzB,KAAK,CAAC,EAAE,MAAM,CAAC;IAGf,MAAM,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;CAC9B;AAED,MAAM,WAAW,eAAgB,SAAQ,iBAAiB;IACxD,QAAQ,EAAE,UAAU,CAAC;IACrB,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,KAAK,EAAE,MAAM,CAAC;IACd,UAAU,CAAC,EAAE,YAAY,CAAC;IAC1B,QAAQ,EAAE,OAAO,CAAC;IAClB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,aAAa,CAAC,EAAE,MAAM,CAAC;CACxB;AAED,MAAM,WAAW,eAAe;IAC9B,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,cAAc,CAAC,EAAE,MAAM,CAAC;IACxB,kBAAkB,CAAC,EAAE,YAAY,CAAC;IAClC,YAAY,CAAC,EAAE,MAAM,CAAC;CACvB;AAED,MAAM,WAAW,UAAW,SAAQ,UAAU;IAC5C,eAAe,EAAE,MAAM,CAAC;IACxB,WAAW,EAAE,MAAM,CAAC;IACpB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,UAAU,EAAE,MAAM,CAAC;IACnB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,YAAY,EAAE,MAAM,CAAC;IACrB,OAAO,EAAE,OAAO,CAAC;IACjB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,QAAQ,CAAC,EAAE,eAAe,CAAC;IAC3B,SAAS,EAAE,IAAI,CAAC;CACjB;AAMD,MAAM,MAAM,SAAS,CAAC,CAAC,IAAI;IACzB,KAAK,EAAE,CAAC,EAAE,CAAC;IACX,UAAU,EAAE,MAAM,CAAC;IACnB,QAAQ,EAAE,MAAM,CAAC;IACjB,WAAW,EAAE,MAAM,CAAC;IACpB,UAAU,EAAE,MAAM,CAAC;IACnB,WAAW,EAAE,OAAO,CAAC;IACrB,eAAe,EAAE,OAAO,CAAC;CAC1B,CAAC;AAEF,MAAM,MAAM,SAAS,GAAG,KAAK,GAAG,MAAM,CAAC;AAEvC,MAAM,WAAW,gBAAgB;IAC/B,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,SAAS,CAAC,EAAE,SAAS,CAAC;CACvB;AAED,MAAM,WAAW,YAAY;IAC3B,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,MAAM,CAAC,EAAE,MAAM,EAAE,CAAC;IAClB,QAAQ,CAAC,EAAE,IAAI,CAAC;IAChB,MAAM,CAAC,EAAE,IAAI,CAAC;IACd,IAAI,CAAC,EAAE,MAAM,EAAE,CAAC;IAChB,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;CACpB;AAMD,MAAM,WAAW,WAAW,CAAC,CAAC,GAAG,GAAG;IAClC,OAAO,EAAE,OAAO,CAAC;IACjB,IAAI,CAAC,EAAE,CAAC,CAAC;IACT,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,SAAS,EAAE,IAAI,CAAC;IAChB,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB;AAED,MAAM,WAAW,eAAe;IAC9B,KAAK,EAAE,MAAM,CAAC;IACd,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,MAAM,CAAC;CACd;AAED,MAAM,WAAW,QAAQ;IACvB,IAAI,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,MAAM,CAAC;IAChB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,gBAAgB,CAAC,EAAE,eAAe,EAAE,CAAC;IACrC,UAAU,EAAE,MAAM,CAAC;CACpB;AAMD,MAAM,WAAW,mBAAoB,SAAQ,IAAI;IAC/C,eAAe,CAAC,EAAE,cAAc,CAAC;CAClC;AAED,MAAM,WAAW,iBAAkB,SAAQ,MAAM;IAC/C,SAAS,EAAE,IAAI,CAAC;IAChB,WAAW,EAAE,CAAC,UAAU,GAAG;QACzB,MAAM,EAAE,KAAK,EAAE,CAAC;KACjB,CAAC,EAAE,CAAC;CACN;AAED,MAAM,WAAW,mBAAoB,SAAQ,KAAK;IAChD,UAAU,EAAE,CAAC,SAAS,GAAG;QACvB,SAAS,EAAE,QAAQ,EAAE,CAAC;KACvB,CAAC,EAAE,CAAC;CACN;AAED,MAAM,WAAW,oBAAqB,SAAQ,QAAQ;IACpD,QAAQ,EAAE,eAAe,EAAE,CAAC;CAC7B;AAED,MAAM,WAAW,yBAA0B,SAAQ,eAAe;IAChE,MAAM,EAAE,KAAK,EAAE,CAAC;IAChB,MAAM,EAAE,MAAM,CAAC;CAChB;AAED,MAAM,WAAW,gBAAiB,SAAQ,cAAc;IACtD,KAAK,EAAE,KAAK,GAAG;QACb,UAAU,EAAE,UAAU,GAAG;YACvB,MAAM,EAAE,MAAM,CAAC;SAChB,CAAC;KACH,CAAC;CACH;AAMD,MAAM,WAAW,oBAAoB;IACnC,YAAY,EAAE,MAAM,CAAC;IACrB,gBAAgB,EAAE,MAAM,CAAC;IACzB,aAAa,EAAE,MAAM,CAAC;IACtB,iBAAiB,EAAE,MAAM,CAAC;IAC1B,cAAc,EAAE,cAAc,EAAE,CAAC;IACjC,cAAc,EAAE,CAAC,MAAM,GAAG;QAAE,YAAY,EAAE,MAAM,CAAC;QAAC,YAAY,EAAE,MAAM,CAAA;KAAE,CAAC,EAAE,CAAC;IAC5E,qBAAqB,EAAE,QAAQ,EAAE,CAAC;CACnC;AAED,MAAM,WAAW,oBAAoB;IACnC,eAAe,EAAE,MAAM,CAAC;IACxB,gBAAgB,EAAE,MAAM,CAAC;IACzB,aAAa,EAAE,MAAM,CAAC;IACtB,YAAY,EAAE,MAAM,CAAC;IACrB,cAAc,EAAE,cAAc,EAAE,CAAC;IACjC,eAAe,EAAE,MAAM,EAAE,CAAC;IAC1B,YAAY,EAAE,GAAG,EAAE,CAAC;CACrB;AAED,MAAM,WAAW,kBAAkB;IACjC,UAAU,EAAE,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IACrC,YAAY,EAAE;QACZ,WAAW,EAAE,MAAM,CAAC;QACpB,cAAc,EAAE,MAAM,CAAC;QACvB,UAAU,EAAE,MAAM,CAAC;QACnB,SAAS,EAAE,MAAM,CAAC;KACnB,CAAC;IACF,YAAY,EAAE;QACZ,YAAY,EAAE,MAAM,CAAC;QACrB,WAAW,EAAE,MAAM,CAAC;QACpB,cAAc,EAAE,MAAM,CAAC;QACvB,cAAc,EAAE,MAAM,CAAC;KACxB,CAAC;IACF,OAAO,EAAE;QACP,aAAa,EAAE,MAAM,CAAC;QACtB,WAAW,EAAE,MAAM,CAAC;QACpB,WAAW,EAAE,MAAM,CAAC;QACpB,mBAAmB,EAAE,MAAM,CAAC;KAC7B,CAAC;CACH;AAMD,YAAY,EAEV,UAAU,EACV,iBAAiB,EACjB,IAAI,EACJ,cAAc,EACd,MAAM,EACN,UAAU,EACV,KAAK,EACL,SAAS,EACT,QAAQ,EACR,YAAY,EACZ,cAAc,EACd,eAAe,EACf,YAAY,EACZ,eAAe,EACf,KAAK,EACL,cAAc,EACd,cAAc,EACd,kBAAkB,EAClB,gBAAgB,EAChB,YAAY,EACZ,QAAQ,EACR,YAAY,EACZ,aAAa,EACb,eAAe,EACf,YAAY,EACZ,UAAU,EACV,eAAe,EACf,SAAS,EACT,gBAAgB,EAChB,YAAY,EACZ,WAAW,EACX,QAAQ,EACR,eAAe,EACf,mBAAmB,EACnB,iBAAiB,EACjB,mBAAmB,EACnB,oBAAoB,EACpB,yBAAyB,EACzB,gBAAgB,EAChB,oBAAoB,EACpB,oBAAoB,EACpB,kBAAkB,EAClB,UAAU,EACV,WAAW,EACX,WAAW,EACZ,CAAC"}
</file>

<file path="database/types.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AIProvider = exports.AuditAction = exports.GradeStatus = exports.AttemptStatus = exports.SessionStatus = exports.QuestionStatus = exports.QuestionType = exports.VideoStatus = exports.LessonStatus = exports.UserStatus = exports.UserRole = void 0;
var UserRole;
(function (UserRole) {
    UserRole["STUDENT"] = "STUDENT";
    UserRole["TEACHER"] = "TEACHER";
    UserRole["ADMIN"] = "ADMIN";
})(UserRole || (exports.UserRole = UserRole = {}));
var UserStatus;
(function (UserStatus) {
    UserStatus["ACTIVE"] = "ACTIVE";
    UserStatus["INACTIVE"] = "INACTIVE";
    UserStatus["SUSPENDED"] = "SUSPENDED";
    UserStatus["PENDING_VERIFICATION"] = "PENDING_VERIFICATION";
})(UserStatus || (exports.UserStatus = UserStatus = {}));
var LessonStatus;
(function (LessonStatus) {
    LessonStatus["DRAFT"] = "DRAFT";
    LessonStatus["PUBLISHED"] = "PUBLISHED";
    LessonStatus["ARCHIVED"] = "ARCHIVED";
})(LessonStatus || (exports.LessonStatus = LessonStatus = {}));
var VideoStatus;
(function (VideoStatus) {
    VideoStatus["UPLOADING"] = "UPLOADING";
    VideoStatus["PROCESSING"] = "PROCESSING";
    VideoStatus["READY"] = "READY";
    VideoStatus["ERROR"] = "ERROR";
})(VideoStatus || (exports.VideoStatus = VideoStatus = {}));
var QuestionType;
(function (QuestionType) {
    QuestionType["MULTIPLE_CHOICE"] = "MULTIPLE_CHOICE";
    QuestionType["TRUE_FALSE"] = "TRUE_FALSE";
    QuestionType["SHORT_ANSWER"] = "SHORT_ANSWER";
    QuestionType["FILL_IN_BLANK"] = "FILL_IN_BLANK";
    QuestionType["MATCHING"] = "MATCHING";
    QuestionType["ORDERING"] = "ORDERING";
})(QuestionType || (exports.QuestionType = QuestionType = {}));
var QuestionStatus;
(function (QuestionStatus) {
    QuestionStatus["AI_GENERATED"] = "AI_GENERATED";
    QuestionStatus["PENDING_REVIEW"] = "PENDING_REVIEW";
    QuestionStatus["APPROVED"] = "APPROVED";
    QuestionStatus["REJECTED"] = "REJECTED";
    QuestionStatus["NEEDS_REVISION"] = "NEEDS_REVISION";
})(QuestionStatus || (exports.QuestionStatus = QuestionStatus = {}));
var SessionStatus;
(function (SessionStatus) {
    SessionStatus["ACTIVE"] = "ACTIVE";
    SessionStatus["PAUSED"] = "PAUSED";
    SessionStatus["COMPLETED"] = "COMPLETED";
    SessionStatus["ABANDONED"] = "ABANDONED";
})(SessionStatus || (exports.SessionStatus = SessionStatus = {}));
var AttemptStatus;
(function (AttemptStatus) {
    AttemptStatus["IN_PROGRESS"] = "IN_PROGRESS";
    AttemptStatus["SUBMITTED"] = "SUBMITTED";
    AttemptStatus["CORRECT"] = "CORRECT";
    AttemptStatus["INCORRECT"] = "INCORRECT";
    AttemptStatus["PARTIAL"] = "PARTIAL";
    AttemptStatus["TIMEOUT"] = "TIMEOUT";
})(AttemptStatus || (exports.AttemptStatus = AttemptStatus = {}));
var GradeStatus;
(function (GradeStatus) {
    GradeStatus["IN_PROGRESS"] = "IN_PROGRESS";
    GradeStatus["COMPLETED"] = "COMPLETED";
    GradeStatus["FAILED"] = "FAILED";
    GradeStatus["RETRY_ALLOWED"] = "RETRY_ALLOWED";
})(GradeStatus || (exports.GradeStatus = GradeStatus = {}));
var AuditAction;
(function (AuditAction) {
    AuditAction["CREATE"] = "CREATE";
    AuditAction["UPDATE"] = "UPDATE";
    AuditAction["DELETE"] = "DELETE";
    AuditAction["LOGIN"] = "LOGIN";
    AuditAction["LOGOUT"] = "LOGOUT";
    AuditAction["VIEW"] = "VIEW";
    AuditAction["DOWNLOAD"] = "DOWNLOAD";
    AuditAction["UPLOAD"] = "UPLOAD";
})(AuditAction || (exports.AuditAction = AuditAction = {}));
var AIProvider;
(function (AIProvider) {
    AIProvider["OPENAI"] = "OPENAI";
    AIProvider["CLAUDE"] = "CLAUDE";
    AIProvider["GOOGLE_PALM"] = "GOOGLE_PALM";
    AIProvider["CUSTOM"] = "CUSTOM";
})(AIProvider || (exports.AIProvider = AIProvider = {}));
//# sourceMappingURL=types.js.map
</file>

<file path="database/types.js.map">
{"version":3,"file":"types.js","sourceRoot":"","sources":["types.ts"],"names":[],"mappings":";;;AAQA,IAAY,QAIX;AAJD,WAAY,QAAQ;IAClB,+BAAmB,CAAA;IACnB,+BAAmB,CAAA;IACnB,2BAAe,CAAA;AACjB,CAAC,EAJW,QAAQ,wBAAR,QAAQ,QAInB;AAED,IAAY,UAKX;AALD,WAAY,UAAU;IACpB,+BAAiB,CAAA;IACjB,mCAAqB,CAAA;IACrB,qCAAuB,CAAA;IACvB,2DAA6C,CAAA;AAC/C,CAAC,EALW,UAAU,0BAAV,UAAU,QAKrB;AAED,IAAY,YAIX;AAJD,WAAY,YAAY;IACtB,+BAAe,CAAA;IACf,uCAAuB,CAAA;IACvB,qCAAqB,CAAA;AACvB,CAAC,EAJW,YAAY,4BAAZ,YAAY,QAIvB;AAED,IAAY,WAKX;AALD,WAAY,WAAW;IACrB,sCAAuB,CAAA;IACvB,wCAAyB,CAAA;IACzB,8BAAe,CAAA;IACf,8BAAe,CAAA;AACjB,CAAC,EALW,WAAW,2BAAX,WAAW,QAKtB;AAED,IAAY,YAOX;AAPD,WAAY,YAAY;IACtB,mDAAmC,CAAA;IACnC,yCAAyB,CAAA;IACzB,6CAA6B,CAAA;IAC7B,+CAA+B,CAAA;IAC/B,qCAAqB,CAAA;IACrB,qCAAqB,CAAA;AACvB,CAAC,EAPW,YAAY,4BAAZ,YAAY,QAOvB;AAED,IAAY,cAMX;AAND,WAAY,cAAc;IACxB,+CAA6B,CAAA;IAC7B,mDAAiC,CAAA;IACjC,uCAAqB,CAAA;IACrB,uCAAqB,CAAA;IACrB,mDAAiC,CAAA;AACnC,CAAC,EANW,cAAc,8BAAd,cAAc,QAMzB;AAED,IAAY,aAKX;AALD,WAAY,aAAa;IACvB,kCAAiB,CAAA;IACjB,kCAAiB,CAAA;IACjB,wCAAuB,CAAA;IACvB,wCAAuB,CAAA;AACzB,CAAC,EALW,aAAa,6BAAb,aAAa,QAKxB;AAED,IAAY,aAOX;AAPD,WAAY,aAAa;IACvB,4CAA2B,CAAA;IAC3B,wCAAuB,CAAA;IACvB,oCAAmB,CAAA;IACnB,wCAAuB,CAAA;IACvB,oCAAmB,CAAA;IACnB,oCAAmB,CAAA;AACrB,CAAC,EAPW,aAAa,6BAAb,aAAa,QAOxB;AAED,IAAY,WAKX;AALD,WAAY,WAAW;IACrB,0CAA2B,CAAA;IAC3B,sCAAuB,CAAA;IACvB,gCAAiB,CAAA;IACjB,8CAA+B,CAAA;AACjC,CAAC,EALW,WAAW,2BAAX,WAAW,QAKtB;AAED,IAAY,WASX;AATD,WAAY,WAAW;IACrB,gCAAiB,CAAA;IACjB,gCAAiB,CAAA;IACjB,gCAAiB,CAAA;IACjB,8BAAe,CAAA;IACf,gCAAiB,CAAA;IACjB,4BAAa,CAAA;IACb,oCAAqB,CAAA;IACrB,gCAAiB,CAAA;AACnB,CAAC,EATW,WAAW,2BAAX,WAAW,QAStB;AAED,IAAY,UAKX;AALD,WAAY,UAAU;IACpB,+BAAiB,CAAA;IACjB,+BAAiB,CAAA;IACjB,yCAA2B,CAAA;IAC3B,+BAAiB,CAAA;AACnB,CAAC,EALW,UAAU,0BAAV,UAAU,QAKrB"}
</file>

<file path="database/types.ts">
// Interactive Learning Platform Database Types
// TypeScript type definitions for the PostgreSQL schema
// Generated: 2025-08-07

// ========================================
// ENUM TYPES
// ========================================

export enum UserRole {
  STUDENT = 'STUDENT',
  TEACHER = 'TEACHER',
  ADMIN = 'ADMIN'
}

export enum UserStatus {
  ACTIVE = 'ACTIVE',
  INACTIVE = 'INACTIVE',
  SUSPENDED = 'SUSPENDED',
  PENDING_VERIFICATION = 'PENDING_VERIFICATION'
}

export enum LessonStatus {
  DRAFT = 'DRAFT',
  PUBLISHED = 'PUBLISHED',
  ARCHIVED = 'ARCHIVED'
}

export enum VideoStatus {
  UPLOADING = 'UPLOADING',
  PROCESSING = 'PROCESSING',
  READY = 'READY',
  ERROR = 'ERROR'
}

export enum QuestionType {
  MULTIPLE_CHOICE = 'MULTIPLE_CHOICE',
  TRUE_FALSE = 'TRUE_FALSE',
  SHORT_ANSWER = 'SHORT_ANSWER',
  FILL_IN_BLANK = 'FILL_IN_BLANK',
  MATCHING = 'MATCHING',
  ORDERING = 'ORDERING'
}

export enum QuestionStatus {
  AI_GENERATED = 'AI_GENERATED',
  PENDING_REVIEW = 'PENDING_REVIEW',
  APPROVED = 'APPROVED',
  REJECTED = 'REJECTED',
  NEEDS_REVISION = 'NEEDS_REVISION'
}

export enum SessionStatus {
  ACTIVE = 'ACTIVE',
  PAUSED = 'PAUSED',
  COMPLETED = 'COMPLETED',
  ABANDONED = 'ABANDONED'
}

export enum AttemptStatus {
  IN_PROGRESS = 'IN_PROGRESS',
  SUBMITTED = 'SUBMITTED',
  CORRECT = 'CORRECT',
  INCORRECT = 'INCORRECT',
  PARTIAL = 'PARTIAL',
  TIMEOUT = 'TIMEOUT'
}

export enum GradeStatus {
  IN_PROGRESS = 'IN_PROGRESS',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  RETRY_ALLOWED = 'RETRY_ALLOWED'
}

export enum AuditAction {
  CREATE = 'CREATE',
  UPDATE = 'UPDATE',
  DELETE = 'DELETE',
  LOGIN = 'LOGIN',
  LOGOUT = 'LOGOUT',
  VIEW = 'VIEW',
  DOWNLOAD = 'DOWNLOAD',
  UPLOAD = 'UPLOAD'
}

export enum AIProvider {
  OPENAI = 'OPENAI',
  CLAUDE = 'CLAUDE',
  GOOGLE_PALM = 'GOOGLE_PALM',
  CUSTOM = 'CUSTOM'
}

// ========================================
// BASE ENTITY INTERFACES
// ========================================

export interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface TimestampedEntity extends BaseEntity {
  createdAt: Date;
  updatedAt: Date;
}

// ========================================
// USER MANAGEMENT TYPES
// ========================================

export interface User extends TimestampedEntity {
  email: string;
  username?: string;
  firstName: string;
  lastName: string;
  avatar?: string;
  role: UserRole;
  status: UserStatus;
  passwordHash: string;
  emailVerified?: Date;
  lastLoginAt?: Date;
  tenantId?: string;
  metadata?: Record<string, any>;
}

export interface UserPreference extends TimestampedEntity {
  userId: string;
  autoplay: boolean;
  playbackSpeed: number;
  subtitles: boolean;
  theme: string;
  language: string;
  emailNotifications: boolean;
  progressNotifications: boolean;
  allowAnalytics: boolean;
  customSettings?: Record<string, any>;
}

// ========================================
// CONTENT HIERARCHY TYPES
// ========================================

export interface Lesson extends TimestampedEntity {
  title: string;
  description?: string;
  thumbnail?: string;
  status: LessonStatus;
  order?: number;
  tenantId?: string;
  createdById: string;
  objectives: string[];
  estimatedTime?: number;
  difficulty?: string;
  tags: string[];
  metadata?: Record<string, any>;
  publishedAt?: Date;
}

export interface VideoGroup extends TimestampedEntity {
  lessonId: string;
  title: string;
  description?: string;
  order: number;
}

export interface Video extends TimestampedEntity {
  videoGroupId: string;
  title: string;
  description?: string;
  order: number;
  status: VideoStatus;
  gcsPath?: string;
  gcsUrl?: string;
  duration?: number;
  size?: bigint;
  mimeType?: string;
  processingStatus?: string;
  thumbnailUrl?: string;
  metadata?: Record<string, any>;
  uploadedAt?: Date;
  processedAt?: Date;
}

export interface Milestone extends TimestampedEntity {
  videoId: string;
  timestamp: number;
  title: string;
  description?: string;
  order: number;
  isRequired: boolean;
  retryLimit: number;
}

// ========================================
// QUESTION MANAGEMENT TYPES
// ========================================

export interface QuestionData {
  // For Multiple Choice
  options?: Array<{
    id: string;
    text: string;
    isCorrect: boolean;
  }>;
  
  // For True/False
  correctAnswer?: boolean;
  
  // For Short Answer
  acceptedAnswers?: string[];
  caseSensitive?: boolean;
  
  // For Fill in the Blank
  blanks?: Array<{
    position: number;
    acceptedAnswers: string[];
  }>;
  
  // For Matching
  pairs?: Array<{
    left: string;
    right: string;
  }>;
  
  // For Ordering
  items?: Array<{
    id: string;
    text: string;
    correctOrder: number;
  }>;
  
  // Common fields
  maxAttempts?: number;
  timeLimit?: number; // in seconds
  partialCredit?: boolean;
}

export interface Question extends TimestampedEntity {
  milestoneId: string;
  type: QuestionType;
  status: QuestionStatus;
  text: string;
  explanation?: string;
  hints: string[];
  difficulty?: string;
  questionData: QuestionData;
  aiModel?: string;
  aiPrompt?: string;
  aiConfidence?: number;
  aiMetadata?: Record<string, any>;
  points: number;
  passThreshold: number;
  reviewedById?: string;
  reviewedAt?: Date;
  reviewNotes?: string;
}

// ========================================
// SESSION AND PROGRESS TYPES
// ========================================

export interface DeviceInfo {
  platform: string;
  browser: string;
  version: string;
  mobile: boolean;
  screenResolution?: string;
}

export interface BrowserInfo {
  name: string;
  version: string;
  engine: string;
  engineVersion: string;
}

export interface StudentSession extends TimestampedEntity {
  studentId: string;
  videoId: string;
  status: SessionStatus;
  currentPosition: number;
  lastMilestoneId?: string;
  completedMilestones: string[];
  deviceInfo?: DeviceInfo;
  browserInfo?: BrowserInfo;
  ipAddress?: string;
  userAgent?: string;
  sessionData?: Record<string, any>;
  startedAt: Date;
  lastSeenAt: Date;
  completedAt?: Date;
}

export interface ProgressData {
  milestoneProgress?: Record<string, {
    completed: boolean;
    attempts: number;
    score: number;
    timeSpent: number;
  }>;
  
  videoProgress?: Record<string, {
    watchTime: number;
    completionPercentage: number;
    lastPosition: number;
  }>;
  
  learningPath?: {
    currentStep: number;
    totalSteps: number;
    recommendedNext?: string[];
  };
  
  preferences?: {
    playbackSpeed: number;
    preferredQuestionTypes: QuestionType[];
  };
}

export interface StudentProgress extends TimestampedEntity {
  studentId: string;
  lessonId: string;
  isCompleted: boolean;
  completionPercent: number;
  totalTimeSpent: number;
  totalMilestones: number;
  completedMilestones: number;
  averageScore: number;
  totalAttempts: number;
  successfulAttempts: number;
  progressData?: ProgressData;
  startedAt: Date;
  completedAt?: Date;
}

// ========================================
// GRADING AND ASSESSMENT TYPES
// ========================================

export interface AttemptData {
  startTime: Date;
  endTime?: Date;
  hintsViewed: number;
  timeSpentReading: number;
  timeSpentAnswering: number;
  confidence?: number; // Self-reported confidence
  difficulty?: number; // Self-reported difficulty
}

export interface QuestionAttempt extends TimestampedEntity {
  studentId: string;
  questionId: string;
  status: AttemptStatus;
  attemptNumber: number;
  studentAnswer: Record<string, any>;
  isCorrect?: boolean;
  score: number;
  timeSpent: number;
  hintsUsed: string[];
  feedback?: string;
  attemptData?: AttemptData;
  submittedAt?: Date;
}

export interface GradeBreakdown {
  milestones?: Record<string, {
    totalPoints: number;
    earnedPoints: number;
    percentage: number;
    attempts: number;
  }>;
  
  questionTypes?: Record<QuestionType, {
    totalQuestions: number;
    correctAnswers: number;
    averageScore: number;
  }>;
  
  timeMetrics?: {
    totalTime: number;
    averageTimePerQuestion: number;
    efficiency: number;
  };
  
  difficultyAnalysis?: Record<string, {
    questions: number;
    averageScore: number;
    averageTime: number;
  }>;
}

export interface Grade extends TimestampedEntity {
  studentId: string;
  studentProgressId: string;
  totalPoints: number;
  earnedPoints: number;
  percentageScore: number;
  letterGrade?: string;
  status: GradeStatus;
  totalAttempts: number;
  remainingAttempts: number;
  gradeBreakdown?: GradeBreakdown;
  finalizedAt?: Date;
}

// ========================================
// ANALYTICS TYPES
// ========================================

export interface AnalyticsEventData {
  // Video events
  videoId?: string;
  position?: number;
  duration?: number;
  playbackSpeed?: number;
  quality?: string;
  
  // Question events
  questionId?: string;
  questionType?: QuestionType;
  attemptNumber?: number;
  correct?: boolean;
  timeSpent?: number;
  hintsUsed?: number;
  
  // Navigation events
  fromPage?: string;
  toPage?: string;
  navigationTime?: number;
  
  // Performance events
  loadTime?: number;
  errorType?: string;
  errorMessage?: string;
  
  // User interaction events
  clickTarget?: string;
  scrollDepth?: number;
  keyboardShortcut?: string;
}

export interface AnalyticsContext {
  sessionId?: string;
  deviceType: string;
  browserName: string;
  browserVersion: string;
  screenResolution: string;
  connectionType?: string;
  geolocation?: {
    country: string;
    region: string;
    city: string;
  };
  referrer?: string;
  experimentVariant?: string;
}

export interface AnalyticsEvent extends BaseEntity {
  userId?: string;
  sessionId?: string;
  eventType: string;
  eventData: AnalyticsEventData;
  context?: AnalyticsContext;
  timestamp: Date;
  processingTime?: number;
}

// ========================================
// SYSTEM ADMINISTRATION TYPES
// ========================================

export interface SystemConfig extends TimestampedEntity {
  key: string;
  value: Record<string, any>;
  description?: string;
  category?: string;
  isPublic: boolean;
}

export interface AuditChanges {
  before?: Record<string, any>;
  after?: Record<string, any>;
  fields?: string[];
}

export interface AuditMetadata {
  source: string;
  reason?: string;
  batchId?: string;
  ipAddress?: string;
  userAgent?: string;
  sessionId?: string;
}

export interface AuditLog extends BaseEntity {
  userId?: string;
  action: AuditAction;
  resource: string;
  resourceId?: string;
  changes?: AuditChanges;
  metadata?: AuditMetadata;
  ipAddress?: string;
  userAgent?: string;
  createdAt: Date;
}

// ========================================
// AI MANAGEMENT TYPES
// ========================================

export interface AIParameters {
  temperature?: number;
  maxTokens?: number;
  topP?: number;
  topK?: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
  stopSequences?: string[];
  model?: string;
  
  // Custom parameters for different providers
  custom?: Record<string, any>;
}

export interface AIConfiguration extends TimestampedEntity {
  provider: AIProvider;
  name: string;
  apiKey?: string;
  endpoint?: string;
  model: string;
  parameters?: AIParameters;
  isActive: boolean;
  rateLimit?: number;
  maxTokens?: number;
  costPerToken?: number;
  monthlyBudget?: number;
}

export interface AIUsageMetadata {
  requestId?: string;
  model?: string;
  context?: string;
  promptLength?: number;
  responseLength?: number;
  generationSettings?: AIParameters;
  qualityScore?: number;
}

export interface AIUsageLog extends BaseEntity {
  configurationId: string;
  requestType: string;
  prompt?: string;
  response?: string;
  tokensUsed: number;
  cost?: number;
  responseTime: number;
  success: boolean;
  errorMessage?: string;
  userId?: string;
  resourceId?: string;
  metadata?: AIUsageMetadata;
  createdAt: Date;
}

// ========================================
// UTILITY TYPES
// ========================================

export type Paginated<T> = {
  items: T[];
  totalCount: number;
  pageSize: number;
  currentPage: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
};

export type SortOrder = 'asc' | 'desc';

export interface PaginationParams {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: SortOrder;
}

export interface FilterParams {
  search?: string;
  status?: string[];
  dateFrom?: Date;
  dateTo?: Date;
  tags?: string[];
  [key: string]: any;
}

// ========================================
// API RESPONSE TYPES
// ========================================

export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
  timestamp: Date;
  requestId?: string;
}

export interface ValidationError {
  field: string;
  message: string;
  code: string;
}

export interface ApiError {
  code: string;
  message: string;
  details?: string;
  validationErrors?: ValidationError[];
  statusCode: number;
}

// ========================================
// RELATIONSHIP TYPES (for joins)
// ========================================

export interface UserWithPreferences extends User {
  userPreferences?: UserPreference;
}

export interface LessonWithDetails extends Lesson {
  createdBy: User;
  videoGroups: (VideoGroup & {
    videos: Video[];
  })[];
}

export interface VideoWithMilestones extends Video {
  milestones: (Milestone & {
    questions: Question[];
  })[];
}

export interface QuestionWithAttempts extends Question {
  attempts: QuestionAttempt[];
}

export interface StudentProgressWithGrades extends StudentProgress {
  grades: Grade[];
  lesson: Lesson;
}

export interface SessionWithVideo extends StudentSession {
  video: Video & {
    videoGroup: VideoGroup & {
      lesson: Lesson;
    };
  };
}

// ========================================
// DASHBOARD AND ANALYTICS TYPES
// ========================================

export interface TeacherDashboardData {
  totalLessons: number;
  publishedLessons: number;
  totalStudents: number;
  averageCompletion: number;
  recentActivity: AnalyticsEvent[];
  popularLessons: (Lesson & { studentCount: number; averageScore: number })[];
  questionApprovalQueue: Question[];
}

export interface StudentDashboardData {
  enrolledLessons: number;
  completedLessons: number;
  totalProgress: number;
  averageScore: number;
  recentSessions: StudentSession[];
  recommendations: Lesson[];
  achievements: any[];
}

export interface AdminDashboardData {
  totalUsers: Record<UserRole, number>;
  systemHealth: {
    activeUsers: number;
    activeSessions: number;
    systemLoad: number;
    errorRate: number;
  };
  contentStats: {
    totalLessons: number;
    totalVideos: number;
    totalQuestions: number;
    pendingReviews: number;
  };
  aiUsage: {
    monthlyTokens: number;
    monthlyCost: number;
    successRate: number;
    averageResponseTime: number;
  };
}

// ========================================
// EXPORT ALL TYPES
// ========================================

export type {
  // Re-export all interfaces and types for easier importing
  BaseEntity,
  TimestampedEntity,
  User,
  UserPreference,
  Lesson,
  VideoGroup,
  Video,
  Milestone,
  Question,
  QuestionData,
  StudentSession,
  StudentProgress,
  ProgressData,
  QuestionAttempt,
  Grade,
  GradeBreakdown,
  AnalyticsEvent,
  AnalyticsEventData,
  AnalyticsContext,
  SystemConfig,
  AuditLog,
  AuditChanges,
  AuditMetadata,
  AIConfiguration,
  AIParameters,
  AIUsageLog,
  AIUsageMetadata,
  Paginated,
  PaginationParams,
  FilterParams,
  ApiResponse,
  ApiError,
  ValidationError,
  UserWithPreferences,
  LessonWithDetails,
  VideoWithMilestones,
  QuestionWithAttempts,
  StudentProgressWithGrades,
  SessionWithVideo,
  TeacherDashboardData,
  StudentDashboardData,
  AdminDashboardData,
  DeviceInfo,
  BrowserInfo,
  AttemptData
};
</file>

<file path="docs/arch/authentication-architecture.md">
# Authentication System Architecture

## Overview

The authentication system provides secure, token-based authentication with automatic refresh, cross-tab synchronization, and comprehensive error handling. Built with JWT tokens, it supports role-based access control (RBAC) for Student, Teacher, and Admin users.

## Architecture Diagram

```mermaid
graph TB
    subgraph "Frontend Authentication Layer"
        subgraph "Entry Points"
            LP[LoginPage]
            RP[RegisterPage]
            APP[App.tsx]
        end
        
        subgraph "Auth Context & State"
            AC[AuthContext]
            AR[Auth Reducer]
            AS[Auth State]
        end
        
        subgraph "Token Management"
            TM[TokenManager]
            LS[LocalStorage]
            JWT[JWT Decoder]
        end
        
        subgraph "Route Protection"
            PR[ProtectedRoute]
            PUB[PublicRoute]
            RG[Role Guards]
        end
        
        subgraph "API Layer"
            API[ApiService]
            INT[Interceptors]
            RQ[Request Queue]
        end
        
        subgraph "Error Handling"
            EB[AuthErrorBoundary]
            EH[Error Handlers]
        end
        
        subgraph "UI Components"
            SI[StatusIndicator]
            LO[LoadingSpinner]
            EM[Error Messages]
        end
    end
    
    subgraph "Backend Authentication Layer"
        subgraph "API Endpoints"
            LOGIN[POST /auth/login]
            REG[POST /auth/register]
            REF[POST /auth/refresh]
            ME[GET /auth/me]
            LOGOUT[POST /auth/logout]
        end
        
        subgraph "Middleware"
            AM[Auth Middleware]
            VM[Validation]
            RL[Rate Limiting]
        end
        
        subgraph "Services"
            AS2[AuthService]
            JWS[JWT Service]
            US[UserService]
        end
        
        subgraph "Database"
            UM[User Model]
            SM[Session Model]
            TK[Token Storage]
        end
    end
    
    %% Frontend Flow
    LP --> AC
    RP --> AC
    AC --> AR
    AR --> AS
    AC --> TM
    TM --> LS
    TM --> JWT
    
    APP --> PR
    APP --> PUB
    PR --> AC
    PUB --> AC
    PR --> RG
    
    AC --> API
    API --> INT
    INT --> RQ
    INT --> TM
    
    APP --> EB
    EB --> EH
    EB --> AC
    
    AC --> SI
    AS --> LO
    EH --> EM
    
    %% Backend Flow
    API --> LOGIN
    API --> REG
    API --> REF
    API --> ME
    
    LOGIN --> VM
    VM --> AS2
    AS2 --> JWS
    AS2 --> US
    US --> UM
    
    REF --> AM
    AM --> JWS
    JWS --> TK
    
    %% Cross-layer
    INT --> REF
    TM --> REF
    
    classDef frontend fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef backend fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    classDef storage fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    classDef critical fill:#ffebee,stroke:#c62828,stroke-width:2px
    
    class LP,RP,APP,AC,AR,AS,TM,PR,PUB,RG,API,INT,RQ,EB,EH,SI,LO,EM frontend
    class LOGIN,REG,REF,ME,LOGOUT,AM,VM,RL,AS2,JWS,US backend
    class LS,UM,SM,TK storage
    class EB,AM,PR critical
```

## Component Architecture

### 1. Frontend Components

#### Core Authentication Components

```typescript
// Token Manager - Centralized token operations
class TokenManager {
  - setTokens(access: string, refresh: string): boolean
  - getAccessToken(): string | null
  - getRefreshToken(): string | null
  - isTokenValid(): boolean
  - shouldRefreshToken(): boolean
  - clearTokens(): void
  - scheduleTokenRefresh(): void
  - decodeJWT(token: string): JWTPayload
}

// Auth Context - State management
interface AuthState {
  user: User | null
  isAuthenticated: boolean
  isLoading: boolean
  isInitialized: boolean
  error: string | null
}

// Protected Route - Access control
interface ProtectedRouteProps {
  children: ReactNode
  requiredRole?: 'STUDENT' | 'TEACHER' | 'ADMIN'
  fallback?: ReactNode
  redirectTo?: string
}
```

#### Component Hierarchy

```text
App.tsx
├── AuthProvider
│   ├── AuthErrorBoundary
│   │   ├── Router
│   │   │   ├── PublicRoute
│   │   │   │   ├── LoginPage
│   │   │   │   └── RegisterPage
│   │   │   └── ProtectedRoute
│   │   │       ├── Layout
│   │   │       │   ├── Header (with AuthBadge)
│   │   │       │   ├── Sidebar
│   │   │       │   └── Content
│   │   │       │       ├── DashboardPage
│   │   │       │       ├── LessonsPage
│   │   │       │       └── [Other Protected Pages]
│   │   │       └── AuthStatusIndicator
│   │   └── VideoStateProvider
│   └── TokenRefreshListener
└── StorageSyncListener
```

### 2. Backend Components

#### API Structure

```typescript
// Auth Routes
router.post('/auth/login', validateLogin, authController.login)
router.post('/auth/register', validateRegister, authController.register)
router.post('/auth/refresh', authController.refreshToken)
router.get('/auth/me', authenticate, authController.getCurrentUser)
router.post('/auth/logout', authenticate, authController.logout)

// Middleware Stack
app.use(rateLimiter)
app.use(bodyParser)
app.use(cors)
app.use(authenticate) // JWT validation
app.use(authorize)    // Role checking
```

## Authentication Flows

### 1. Login Flow

```mermaid
sequenceDiagram
    participant U as User
    participant LP as LoginPage
    participant AC as AuthContext
    participant AS as AuthService
    participant TM as TokenManager
    participant API as API Service
    participant BE as Backend
    participant DB as Database
    
    U->>LP: Enter credentials
    LP->>AC: login(credentials)
    AC->>AS: authService.login()
    AS->>API: POST /auth/login
    API->>BE: Validate credentials
    BE->>DB: Check user
    DB-->>BE: User data
    BE->>BE: Generate JWT tokens
    BE-->>API: {user, tokens}
    API-->>AS: Response
    AS->>TM: setTokens(access, refresh)
    TM->>TM: Decode & store tokens
    TM->>TM: Schedule refresh
    AS-->>AC: Success
    AC->>AC: Update state
    AC-->>LP: Success
    LP->>U: Redirect to dashboard
```

### 2. Token Refresh Flow

```mermaid
sequenceDiagram
    participant TM as TokenManager
    participant API as ApiService
    participant INT as Interceptor
    participant BE as Backend
    participant Q as Request Queue
    
    Note over TM: Token expires in 5 min
    TM->>TM: Trigger refresh
    TM->>API: refreshToken()
    API->>BE: POST /auth/refresh
    BE->>BE: Validate refresh token
    BE->>BE: Generate new access token
    BE-->>API: New tokens
    API->>TM: setTokens()
    TM->>TM: Update storage
    
    Note over Q: Queued requests
    Q->>INT: Retry with new token
    INT->>BE: Original request
    BE-->>INT: Success
    INT-->>Q: Complete
```

### 3. Protected Route Access Flow

```mermaid
sequenceDiagram
    participant U as User
    participant B as Browser
    participant PR as ProtectedRoute
    participant AC as AuthContext
    participant TM as TokenManager
    participant API as API Service
    
    U->>B: Navigate to /dashboard
    B->>PR: Render ProtectedRoute
    PR->>AC: Check auth state
    
    alt Not Initialized
        PR->>PR: Show loading
        AC->>TM: Check stored token
        TM-->>AC: Token valid
        AC->>API: GET /auth/me
        API-->>AC: User data
        AC->>AC: Restore session
        AC-->>PR: Authenticated
        PR->>U: Show dashboard
    else No Token
        PR->>U: Redirect to /login
    else Token Invalid
        AC->>TM: Clear tokens
        PR->>U: Redirect to /login
    else Authenticated
        PR->>U: Show dashboard
    end
```

### 4. Cross-Tab Synchronization Flow

```mermaid
sequenceDiagram
    participant T1 as Tab 1
    participant LS as LocalStorage
    participant T2 as Tab 2
    participant AC2 as AuthContext (Tab 2)
    
    T1->>T1: User logs out
    T1->>LS: Remove tokens
    T1->>LS: Fire storage event
    
    LS-->>T2: Storage change event
    T2->>AC2: Handle storage change
    AC2->>AC2: Check token removed
    AC2->>T2: Dispatch LOGOUT
    T2->>T2: Redirect to /login
```

## State Management

### Auth State Machine

```mermaid
stateDiagram-v2
    [*] --> Initializing
    Initializing --> Unauthenticated: No valid token
    Initializing --> Authenticated: Valid token found
    
    Unauthenticated --> Authenticating: Login/Register
    Authenticating --> Authenticated: Success
    Authenticating --> Unauthenticated: Failure
    
    Authenticated --> Refreshing: Token expiring
    Refreshing --> Authenticated: Refresh success
    Refreshing --> Unauthenticated: Refresh failed
    
    Authenticated --> Unauthenticated: Logout
    Authenticated --> SessionExpired: Token expired
    SessionExpired --> Unauthenticated: Clear tokens
```

### Redux-like State Actions

```typescript
type AuthAction =
  | { type: 'LOGIN_START' }
  | { type: 'LOGIN_SUCCESS'; payload: User }
  | { type: 'LOGIN_ERROR'; payload: string }
  | { type: 'LOGOUT' }
  | { type: 'RESTORE_SESSION'; payload: User }
  | { type: 'SESSION_EXPIRED' }
  | { type: 'REFRESH_START' }
  | { type: 'REFRESH_SUCCESS'; payload: User }
  | { type: 'REFRESH_ERROR' }
  | { type: 'INITIALIZED' }
```

## Security Architecture

### Token Security

```yaml
Access Token:
  - Lifetime: 15 minutes
  - Storage: Memory + localStorage
  - Usage: API authentication
  - Refresh: Automatic before expiry

Refresh Token:
  - Lifetime: 7 days
  - Storage: httpOnly cookie (production) / localStorage (dev)
  - Usage: Get new access token
  - Rotation: New refresh token on use

Security Headers:
  - Authorization: Bearer <token>
  - X-CSRF-Token: CSRF protection
  - X-Request-ID: Request tracking
```

### Role-Based Access Control (RBAC)

```typescript
// Role Hierarchy
enum UserRole {
  ADMIN = 'ADMIN',       // Full system access
  TEACHER = 'TEACHER',   // Content creation, student management
  STUDENT = 'STUDENT'    // Content consumption, learning
}

// Permission Matrix
const permissions = {
  ADMIN: ['*'],
  TEACHER: [
    'lessons.create',
    'lessons.update',
    'lessons.delete',
    'students.view',
    'analytics.view'
  ],
  STUDENT: [
    'lessons.view',
    'lessons.enroll',
    'progress.update',
    'profile.update'
  ]
}
```

### Security Measures

1. **Token Validation**
   - JWT signature verification
   - Expiry checking
   - Issuer/Audience validation

2. **Request Security**
   - CORS configuration
   - Rate limiting
   - Request sanitization
   - SQL injection prevention

3. **Error Handling**
   - No sensitive data in errors
   - Generic error messages
   - Detailed logging server-side

4. **Session Security**
   - Automatic logout on inactivity
   - Token refresh rotation
   - Cross-tab logout sync

## Error Handling Architecture

### Error Boundary Hierarchy

```text
AuthErrorBoundary (Top Level)
├── Catches all auth-related errors
├── Clears invalid tokens
├── Redirects to login
└── Shows user-friendly messages

Component Error Boundaries
├── API call failures
├── Network errors
├── Validation errors
└── Unexpected errors
```

### Error Types and Handling

```typescript
// Error Classifications
enum AuthErrorType {
  INVALID_CREDENTIALS = 'INVALID_CREDENTIALS',
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',
  TOKEN_INVALID = 'TOKEN_INVALID',
  NETWORK_ERROR = 'NETWORK_ERROR',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  SESSION_EXPIRED = 'SESSION_EXPIRED',
  RATE_LIMITED = 'RATE_LIMITED'
}

// Error Handlers
const errorHandlers = {
  [AuthErrorType.INVALID_CREDENTIALS]: () => {
    showToast('Invalid email or password')
  },
  [AuthErrorType.TOKEN_EXPIRED]: () => {
    dispatch({ type: 'SESSION_EXPIRED' })
    redirect('/login')
  },
  [AuthErrorType.PERMISSION_DENIED]: () => {
    showToast('You don\'t have permission')
    redirect('/dashboard')
  }
}
```

## Performance Optimizations

### 1. Request Optimization

```typescript
// Request Deduplication
class RequestQueue {
  private pending: Map<string, Promise<any>>
  
  async execute(key: string, request: () => Promise<any>) {
    if (this.pending.has(key)) {
      return this.pending.get(key)
    }
    
    const promise = request()
    this.pending.set(key, promise)
    
    try {
      const result = await promise
      return result
    } finally {
      this.pending.delete(key)
    }
  }
}
```

### 2. Token Refresh Optimization

- **Proactive Refresh**: Refresh 5 minutes before expiry
- **Request Queuing**: Queue requests during refresh
- **Single Refresh**: Deduplicate concurrent refresh attempts
- **Background Refresh**: Non-blocking token refresh

### 3. Storage Optimization

- **Selective Storage**: Only store essential data
- **Compression**: Compress large payloads
- **Cleanup**: Remove expired data automatically
- **Indexing**: Use indexed keys for fast retrieval

## Monitoring & Analytics

### Auth Metrics

```typescript
// Track authentication events
interface AuthMetrics {
  loginAttempts: number
  loginSuccesses: number
  loginFailures: number
  tokenRefreshes: number
  sessionDurations: number[]
  errorRates: Map<string, number>
}

// Analytics Events
trackEvent('auth.login.success', { userId, role })
trackEvent('auth.token.refresh', { userId })
trackEvent('auth.session.expired', { userId, duration })
trackEvent('auth.error', { type, userId })
```

### Health Checks

```typescript
// Auth system health check
GET /health/auth
{
  "status": "healthy",
  "checks": {
    "database": "connected",
    "redis": "connected",
    "jwt": "valid",
    "rateLimit": "ok"
  },
  "metrics": {
    "activeUsers": 1234,
    "avgSessionDuration": 3600,
    "tokenRefreshRate": 0.85
  }
}
```

## Testing Strategy

### Unit Tests

```typescript
describe('TokenManager', () => {
  test('should validate token expiry', () => {
    const expired = createExpiredToken()
    expect(TokenManager.isTokenValid(expired)).toBe(false)
  })
  
  test('should schedule refresh correctly', () => {
    const token = createTokenExpiringIn(10 * 60 * 1000)
    TokenManager.setTokens(token, refresh)
    expect(TokenManager.shouldRefreshToken()).toBe(true)
  })
})
```

### Integration Tests

```typescript
describe('Auth Flow', () => {
  test('complete login flow', async () => {
    // Login
    await userEvent.type(emailInput, 'test@example.com')
    await userEvent.type(passwordInput, 'password')
    await userEvent.click(loginButton)
    
    // Verify redirect
    await waitFor(() => {
      expect(window.location.pathname).toBe('/dashboard')
    })
    
    // Verify token stored
    expect(TokenManager.isTokenValid()).toBe(true)
  })
})
```

### E2E Tests

```typescript
describe('Auth E2E', () => {
  test('cross-tab logout', async () => {
    // Login in tab 1
    const tab1 = await browser.newPage()
    await tab1.goto('/login')
    await login(tab1)
    
    // Open tab 2
    const tab2 = await browser.newPage()
    await tab2.goto('/dashboard')
    
    // Logout in tab 1
    await logout(tab1)
    
    // Verify tab 2 redirected
    await tab2.waitForNavigation()
    expect(tab2.url()).toContain('/login')
  })
})
```

## Migration Guide

### From Session-Based to Token-Based Auth

```typescript
// Old (Session-based)
app.use(session({
  secret: 'secret',
  cookie: { maxAge: 3600000 }
}))

// New (Token-based)
app.use(authenticate) // JWT middleware

// Migration steps:
1. Deploy token auth alongside sessions
2. Migrate users gradually
3. Monitor both systems
4. Deprecate sessions
5. Remove session code
```

## Best Practices

### Do's ✅

1. **Always use TokenManager** for token operations
2. **Wrap routes** with ProtectedRoute/PublicRoute
3. **Handle errors** at appropriate levels
4. **Log security events** for auditing
5. **Refresh tokens** proactively
6. **Clear tokens** on logout
7. **Validate roles** on frontend AND backend
8. **Use HTTPS** in production

### Don'ts ❌

1. **Don't store** sensitive data in localStorage
2. **Don't expose** tokens in URLs
3. **Don't trust** frontend validation alone
4. **Don't ignore** token expiry
5. **Don't hardcode** token lifetimes
6. **Don't skip** error boundaries
7. **Don't forget** cross-tab sync
8. **Don't log** tokens or passwords

## Troubleshooting Guide

### Common Issues

| Issue | Symptoms | Solution |
|-------|----------|----------|
| Infinite redirect loop | Login → Dashboard → Login | Check TokenManager.isTokenValid() |
| 401 after login | API calls fail immediately | Verify token in Authorization header |
| Lost auth on refresh | Logged out on page reload | Check localStorage persistence |
| Cross-tab sync fails | Logout doesn't affect other tabs | Verify storage event listeners |
| Token not refreshing | Session expires unexpectedly | Check refresh timer logic |
| Role check fails | Can't access authorized pages | Verify user.role matches requirement |

## Future Enhancements

1. **Multi-Factor Authentication (MFA)**
   - SMS/Email verification
   - Authenticator app support
   - Backup codes

2. **Single Sign-On (SSO)**
   - OAuth2 providers
   - SAML integration
   - Social login

3. **Advanced Security**
   - Device fingerprinting
   - Anomaly detection
   - IP allowlisting
   - Geolocation checks

4. **Session Management**
   - Active session list
   - Remote logout
   - Session hijacking prevention
   - Remember me functionality

5. **Audit & Compliance**
   - Detailed audit logs
   - GDPR compliance
   - Data retention policies
   - Security certifications
</file>

<file path="docs/arch/video-player-architecture-v2.md">
# Video Player System Architecture v2

## Overview

The Interactive Learning Platform's video player system is a sophisticated educational technology stack that provides milestone-based learning experiences with interactive questions, real-time progress tracking, and multi-device session persistence. This document reflects the current implementation as of the latest codebase updates.

## High-Level Architecture

```mermaid
graph TB
    subgraph "Frontend Layer"
        subgraph "Components"
            VPP[VideoPlayerPage]
            VP[VideoPlayer]
            QO[QuestionOverlay]
            MM[MilestoneMarkers]
            VC[VideoControls]
        end
        
        subgraph "State Management"
            VSM[VideoStateManager<br/>Singleton]
            VSC[VideoStateContext]
            UVS[useVideoState Hook]
            USS[useSessionState Hook]
        end
        
        subgraph "Services"
            VS[videoService]
            SS[sessionService]
            API[API Client]
        end
    end
    
    subgraph "Backend Layer"
        subgraph "API Routes"
            VR[Video Routes<br/>/api/videos/*]
            SR[Session Routes<br/>/api/sessions/*]
            MR[Milestone Routes<br/>/api/milestones/*]
            QR[Question Routes<br/>/api/questions/*]
            AR[Analytics Routes<br/>/api/analytics/*]
        end
        
        subgraph "Business Logic"
            VSB[VideoService]
            VSS[VideoSessionService]
            VPS[VideoProcessingService]
            AQS[AIQuestionService]
            AS[AnalyticsService]
        end
        
        subgraph "Storage"
            GCS[Google Cloud Storage]
            FS[Local File System]
        end
    end
    
    subgraph "Data Layer"
        PC[Prisma Client<br/>ORM]
        PG[(PostgreSQL<br/>Database)]
    end
    
    %% Frontend component connections
    VPP --> VP
    VP --> QO
    VP --> MM
    VP --> VC
    VP --> UVS
    VP --> VSM
    UVS --> VSC
    USS --> VSC
    VSC --> VSM
    
    %% Frontend service connections
    VP --> SS
    VP --> VS
    VSM --> VS
    VSM --> SS
    VS --> API
    SS --> API
    
    %% API Gateway connections (Frontend -> Backend)
    API -.->|HTTP/HTTPS| VR
    API -.->|HTTP/HTTPS| SR
    API -.->|HTTP/HTTPS| MR
    API -.->|HTTP/HTTPS| QR
    API -.->|HTTP/HTTPS| AR
    
    %% Backend route to service connections
    VR --> VSB
    SR --> VSS
    MR --> VSB
    QR --> VSB
    AR --> AS
    
    %% Backend service connections
    VSB --> VPS
    VSB --> GCS
    VPS --> FS
    VPS --> GCS
    
    %% Backend to Data Layer (Only backend accesses database)
    VSB --> PC
    VSS --> PC
    AS --> PC
    AQS --> PC
    PC --> PG
    
    %% Styling
    classDef frontend fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef state fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    classDef api fill:#fff3e0,stroke:#ff6f00,stroke-width:2px
    classDef backend fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    classDef data fill:#ffebee,stroke:#c62828,stroke-width:2px
    classDef storage fill:#f1f8e9,stroke:#33691e,stroke-width:2px
    
    class VPP,VP,QO,MM,VC,VS,SS,API frontend
    class VSM,VSC,UVS,USS state
    class VR,SR,MR,QR,AR api
    class VSB,VSS,VPS,AQS,AS backend
    class PC,PG data
    class GCS,FS storage
```

## Core Components

### Frontend Components

#### VideoPlayer (`frontend/src/components/video/VideoPlayer.tsx`)
The main video playback component that orchestrates the entire learning experience.

**Key Responsibilities:**
- Video playback control and state management
- Milestone detection and triggering (within 2-second tolerance)
- Session lifecycle management (start, progress, complete)
- Progress tracking with 5-second update intervals
- Question overlay display coordination

**State Management:**
- Uses `useVideoState` hook for unified video/milestone data
- Maintains local state for playback controls (play, pause, volume, etc.)
- Tracks watch time and session progress
- Manages milestone reached states to prevent duplicate triggers

**Key Features:**
- Automatic session resumption from last position
- Real-time milestone checking during playback
- Pause video automatically when questions appear
- Progress persistence across page refreshes

#### VideoStateManager (`frontend/src/stores/VideoStateManager.ts`)
Centralized singleton state manager for all video-related data.

**Core Functionality:**
- Caches video, milestone, and question data
- Manages session state and progress
- Provides subscription-based state updates
- Handles optimistic updates for better UX

**Data Structures:**
```typescript
VideoState {
  video: Video
  milestones: Milestone[]
  questions: Map<string, Question[]>
  metadata: {
    totalMilestones: number
    totalQuestions: number
    questionsPerMilestone: Map<string, number>
    lastUpdated: Date
    isLoading: boolean
    error: string | null
  }
}

SessionState {
  session: VideoSession
  milestoneProgress: Set<string>
  questionAnswers: Map<string, QuestionAnswer>
  currentMilestone: Milestone | null
  metadata: {
    correctAnswers: number
    totalAnswers: number
    completionPercentage: number
    lastUpdated: Date
  }
}
```

#### QuestionOverlay (`frontend/src/components/video/QuestionOverlay.tsx`)
Modal component for displaying and handling interactive questions.

**Features:**
- Supports multiple question types (Multiple Choice, True/False, Short Answer)
- Real-time answer validation
- Feedback display with explanations
- Progress tracking within question sets

#### MilestoneMarkers (`frontend/src/components/video/MilestoneMarkers.tsx`)
Visual timeline component showing milestone positions.

**Features:**
- Interactive timeline with clickable markers
- Visual indicators for reached/unreached milestones
- Color coding for different milestone types
- Hover tooltips with milestone details

#### VideoControls (`frontend/src/components/video/VideoControls.tsx`)
Custom video control bar with enhanced features.

**Controls:**
- Play/Pause toggle
- Seekable progress bar
- Volume control with mute
- Fullscreen toggle
- Time display (current/total)
- Playback speed adjustment

### Backend Services

#### VideoService (`src/services/VideoService.ts`)
Core service for video management operations.

**Responsibilities:**
- Video CRUD operations with multi-tenant support
- Integration with storage services (GCS/local)
- Metadata extraction via VideoProcessingService
- Access control and enrollment verification
- Streaming URL generation with authentication

#### VideoSessionService (`src/services/VideoSessionService.ts`)
Manages student learning sessions and progress tracking.

**Key Functions:**
- Session creation and resumption logic
- Progress tracking with automatic save
- Milestone achievement recording
- Question answer validation and scoring
- Session completion with metrics calculation

**Session Lifecycle:**
1. **Start/Resume**: Creates new or retrieves existing session
2. **Progress Update**: Saves position and watch time periodically
3. **Milestone Reached**: Records achievement with timestamp
4. **Question Submit**: Validates answers and updates scores
5. **Complete**: Finalizes session with completion metrics

#### AIQuestionService (`src/services/AIQuestionService.ts`)
AI-powered question generation service.

**Features:**
- Multi-provider support (OpenAI, Claude)
- Context-aware question generation
- Multiple question type generation
- Difficulty level customization
- Batch question creation for milestones

#### VideoProcessingService (`src/services/VideoProcessingService.ts`)
Handles video file processing and metadata extraction.

**Processing Pipeline:**
1. Upload validation (format, size)
2. Metadata extraction (FFprobe)
3. Thumbnail generation (FFmpeg)
4. Duration calculation
5. Database update with metadata

### Data Models

#### Core Video Models
```prisma
Video {
  id: String
  title: String
  description: String?
  videoGroupId: String
  uploadedBy: String
  uploadedAt: DateTime
  processedAt: DateTime?
  status: VideoStatus
  duration: Float?
  metadata: Json?
  storageUrl: String
  thumbnailUrl: String?
  milestones: Milestone[]
  studentSessions: StudentSession[]
}

Milestone {
  id: String
  videoId: String
  timestamp: Float
  type: MilestoneType
  title: String
  description: String?
  order: Int
  isRequired: Boolean
  retryLimit: Int
  questions: Question[]
}

Question {
  id: String
  milestoneId: String
  type: QuestionType
  text: String
  questionData: Json
  explanation: String?
  createdById: String
  options: QuestionOption[]
}
```

#### Progress Tracking Models
```prisma
StudentSession {
  id: String
  studentId: String
  videoId: String
  status: SessionStatus
  currentPosition: Float
  totalWatchTime: Float
  completedMilestones: String[]
  sessionData: Json?
  startedAt: DateTime
  completedAt: DateTime?
  lastSeenAt: DateTime
  milestoneProgress: MilestoneProgress[]
  questionAttempts: QuestionAttempt[]
}

MilestoneProgress {
  id: String
  sessionId: String
  milestoneId: String
  reachedAt: DateTime
  attemptNumber: Int
}

QuestionAttempt {
  id: String
  sessionId: String
  questionId: String
  milestoneId: String
  studentAnswer: String
  isCorrect: Boolean?
  score: Float?
  feedback: String?
  attemptedAt: DateTime
}
```

## Data Flow Patterns

### 1. Video Loading with State Management

```mermaid
sequenceDiagram
    participant User
    participant VPP as VideoPlayerPage
    participant Hook as useVideoState
    participant VSM as VideoStateManager
    participant VS as videoService
    participant API as API Client
    participant BE as Backend API
    participant DB as PostgreSQL

    User->>VPP: Navigate to video page
    VPP->>Hook: useVideoState(videoId)
    Hook->>VSM: getVideoState(videoId)
    
    alt Cache Hit (< 30s old)
        VSM-->>Hook: Return cached state
        Hook-->>VPP: Video data
    else Cache Miss or Stale
        VSM->>VS: getVideo(videoId)
        VS->>API: GET /api/videos/:id
        API->>BE: HTTP Request
        BE->>DB: Query video + milestones + questions
        DB-->>BE: Video data with relations
        BE-->>API: Video response
        API-->>VS: Video object
        VS-->>VSM: Video data
        VSM->>VSM: Update cache
        VSM->>VSM: Notify subscribers
        VSM-->>Hook: Video state
        Hook-->>VPP: Video data
    end
    
    VPP->>VPP: Render video player
```

### 2. Session Management Flow

```mermaid
sequenceDiagram
    participant User
    participant VP as VideoPlayer
    participant VSM as VideoStateManager
    participant SS as sessionService
    participant API as API Client
    participant BE as Backend API
    participant VSS as VideoSessionService
    participant DB as PostgreSQL

    User->>VP: Click play button
    VP->>VP: Check currentSession
    
    alt No existing session
        VP->>SS: startSession(videoId)
        SS->>API: POST /api/sessions/start
        API->>BE: HTTP Request
        BE->>VSS: startOrResumeSession()
        VSS->>DB: Check existing session
        
        alt Session exists
            DB-->>VSS: Existing session
            VSS->>VSS: Resume session
        else No session
            VSS->>DB: Create new session
            DB-->>VSS: New session
        end
        
        VSS->>DB: Load progress data
        DB-->>VSS: MilestoneProgress, QuestionAttempts
        VSS-->>BE: Session with progress
        BE-->>API: Session response
        API-->>SS: Session object
        SS-->>VP: Session data
        VP->>VSM: Update session state
        VSM->>VSM: Notify subscribers
    else Session exists
        VP->>VP: Use existing session
    end
    
    VP->>VP: video.play()
    VP->>VP: Start from currentPosition
```

### 3. Milestone Detection and Question Flow

```mermaid
sequenceDiagram
    participant V as Video Element
    participant VP as VideoPlayer
    participant VSM as VideoStateManager
    participant SS as sessionService
    participant QO as QuestionOverlay
    participant API as API Client
    participant BE as Backend API
    participant VSS as VideoSessionService
    participant DB as PostgreSQL

    V->>VP: timeupdate event
    VP->>VP: checkForMilestones(currentTime)
    VP->>VSM: Get milestones from state
    VSM-->>VP: Milestones array
    
    VP->>VP: Find milestone within 2s window
    VP->>VP: Check if not already reached
    
    alt Milestone found and not reached
        VP->>VP: Add to locallyReachedMilestones
        VP->>V: Pause video
        VP->>SS: markMilestoneReached(sessionId, milestoneId)
        SS->>API: POST /api/sessions/:id/milestone
        API->>BE: HTTP Request
        BE->>VSS: markMilestoneReached()
        VSS->>DB: Create MilestoneProgress record
        DB-->>VSS: Success
        VSS-->>BE: Updated session
        BE-->>API: Response
        API-->>SS: Success
        
        VP->>VP: setCurrentMilestone(milestone)
        VP->>VP: setShowQuestionOverlay(true)
        VP->>QO: Display questions
        
        loop For each question
            QO->>User: Show question
            User->>QO: Submit answer
            QO->>SS: submitAnswer(sessionId, questionId, answer)
            SS->>API: POST /api/sessions/:id/question
            API->>BE: HTTP Request
            BE->>VSS: submitAnswer()
            VSS->>DB: Validate answer
            DB-->>VSS: Correct answer
            VSS->>DB: Create QuestionAttempt
            DB-->>VSS: Success
            VSS-->>BE: Result with explanation
            BE-->>API: Answer result
            API-->>SS: Response
            SS-->>QO: {isCorrect, explanation}
            QO->>VSM: Update question answers
            QO->>User: Show feedback
        end
        
        QO->>VP: onComplete()
        VP->>VP: setShowQuestionOverlay(false)
        VP->>V: Resume video
    end
```

### 4. Progress Tracking Flow

```mermaid
sequenceDiagram
    participant Timer as Progress Timer
    participant VP as VideoPlayer
    participant V as Video Element
    participant SS as sessionService
    participant API as API Client
    participant BE as Backend API
    participant VSS as VideoSessionService
    participant DB as PostgreSQL
    participant VSM as VideoStateManager

    Note over Timer,VP: Every 5 seconds during playback
    
    Timer->>VP: Interval fires
    VP->>V: Get currentTime
    V-->>VP: Current position
    VP->>VP: Calculate totalWatchTime
    
    alt Significant change (>5s or >5 position)
        VP->>SS: updateProgress(sessionId, data)
        SS->>API: PUT /api/sessions/:id/progress
        API->>BE: HTTP Request with {currentTime, totalWatchTime}
        BE->>VSS: updateProgress()
        VSS->>DB: Update StudentSession
        DB-->>VSS: Updated session
        VSS->>DB: Update sessionData JSON
        DB-->>VSS: Success
        VSS-->>BE: Updated session
        BE-->>API: Response
        API-->>SS: Session data
        SS->>VSM: Update session state
        VSM->>VSM: Update cache
        VSM->>VSM: Notify subscribers
        VP->>VP: Update lastProgressUpdate
    else No significant change
        VP->>VP: Skip update
    end
```

### 5. Video Upload and Processing Flow

```mermaid
sequenceDiagram
    participant User
    participant VUF as VideoUploadForm
    participant VS as videoService
    participant API as API Client
    participant BE as Backend API
    participant VSB as VideoService
    participant VPS as VideoProcessingService
    participant GCS as Google Cloud Storage
    participant FFmpeg
    participant DB as PostgreSQL

    User->>VUF: Select video file
    VUF->>VUF: Validate file (type, size)
    VUF->>VS: uploadVideoFile(file, groupId)
    VS->>VS: Create FormData
    VS->>API: POST /api/videos/groups/:id/videos
    API->>BE: Multipart upload
    BE->>BE: Validate auth & permissions
    BE->>VSB: createVideo()
    VSB->>GCS: Upload video file
    GCS-->>VSB: Storage URL
    VSB->>DB: Create Video record (PROCESSING status)
    DB-->>VSB: Video ID
    
    VSB->>VPS: processVideo(videoId, filePath)
    VPS->>FFmpeg: Extract metadata
    FFmpeg-->>VPS: Duration, resolution, codec
    VPS->>FFmpeg: Generate thumbnail
    FFmpeg-->>VPS: Thumbnail image
    VPS->>GCS: Upload thumbnail
    GCS-->>VPS: Thumbnail URL
    VPS->>DB: Update Video (duration, metadata, thumbnail)
    DB-->>VPS: Success
    
    VPS-->>VSB: Processing complete
    VSB->>DB: Update status to READY
    DB-->>VSB: Success
    VSB-->>BE: Video object
    BE-->>API: Response
    API-->>VS: Video data
    VS-->>VUF: Upload complete
    VUF->>User: Show success
```

### 6. AI Question Generation Flow

```mermaid
sequenceDiagram
    participant Teacher
    participant AQG as AIQuestionGenerator
    participant AQS as AIQuestionService
    participant API as API Client
    participant BE as Backend API
    participant AQSB as AIQuestionService (Backend)
    participant AI as AI Provider (OpenAI/Claude)
    participant DB as PostgreSQL
    participant VSM as VideoStateManager

    Teacher->>AQG: Request question generation
    AQG->>AQG: Prepare context (video title, description, transcript)
    AQG->>API: POST /api/ai/generate-questions
    API->>BE: Request with context
    BE->>AQSB: generateQuestions(request)
    
    alt Provider is OpenAI
        AQSB->>AI: ChatGPT API call
    else Provider is Claude
        AQSB->>AI: Claude API call
    end
    
    AI-->>AQSB: Generated questions JSON
    AQSB->>AQSB: Parse and validate response
    
    loop For each question
        AQSB->>DB: Create Question record
        DB-->>AQSB: Question ID
        
        alt Question type is MULTIPLE_CHOICE
            AQSB->>DB: Create QuestionOption records
            DB-->>AQSB: Success
        end
    end
    
    AQSB->>DB: Link questions to milestone
    DB-->>AQSB: Success
    AQSB-->>BE: Questions created
    BE-->>API: Response with question IDs
    API-->>AQG: Success
    
    AQG->>VSM: addQuestions(videoId, milestoneId, questions)
    VSM->>VSM: Update cache
    VSM->>VSM: Notify subscribers
    AQG->>Teacher: Show generated questions
```

### 7. Session Recovery Flow

```mermaid
sequenceDiagram
    participant User
    participant Browser
    participant VPP as VideoPlayerPage
    participant Hook as useVideoState
    participant VSM as VideoStateManager
    participant SS as sessionService
    participant API as API Client
    participant BE as Backend API
    participant DB as PostgreSQL

    User->>Browser: Refresh page / Network recovery
    Browser->>VPP: Reload VideoPlayerPage
    VPP->>Hook: useVideoState(videoId)
    Hook->>VSM: Check for cached session
    
    alt Session in cache
        VSM-->>Hook: Cached session data
    else No cached session
        VSM->>SS: getActiveSession(videoId)
        SS->>API: GET /api/sessions/active?videoId=:id
        API->>BE: HTTP Request
        BE->>DB: Query active session for user
        DB-->>BE: Session with progress
        BE-->>API: Session data
        API-->>SS: Session object
        SS-->>VSM: Session data
        VSM->>VSM: Update cache
    end
    
    VSM-->>Hook: Session state
    Hook-->>VPP: Session data
    VPP->>VPP: Initialize video at currentPosition
    VPP->>VPP: Restore milestone progress
    VPP->>VPP: Show completion status
    VPP->>User: Resumed session
```

## Key Features Implementation

### Milestone Tolerance System
- Milestones trigger within a 2-second window of their timestamp
- Prevents duplicate triggers using local and server tracking
- Immediately adds to local state to prevent re-triggering

### Session Persistence
- Sessions saved to database with current position
- Automatic resumption on page reload
- Cross-device continuation support
- Session recovery after network failures

### Progress Calculation
- Real-time completion percentage
- Watch time tracking (actual time watched, not video duration)
- Milestone achievement tracking
- Question answer statistics

### State Synchronization
- VideoStateManager acts as single source of truth
- Subscription-based updates for reactive UI
- Optimistic updates for better perceived performance
- Cache invalidation after 30 seconds

## Performance Optimizations

### Frontend
1. **Debounced Progress Updates**: Updates sent every 5 seconds
2. **State Caching**: 30-second cache for video data
3. **Lazy Loading**: Components loaded on demand
4. **Optimistic UI Updates**: Immediate local state updates

### Backend
1. **Database Indexing**: Optimized queries on frequently accessed fields
2. **Streaming Responses**: Video served with range requests
3. **Connection Pooling**: Prisma connection management
4. **Query Optimization**: Selective field loading with Prisma select

## Security Measures

### Authentication & Authorization
- JWT-based authentication for all API calls
- Role-based access control (Student, Teacher, Admin)
- Enrollment verification for video access
- Token refresh mechanism for long sessions

### Data Protection
- Input validation on all endpoints
- SQL injection prevention via Prisma parameterized queries
- XSS protection through React's automatic escaping
- CORS configuration for API security

### Video Security
- Signed URLs for video streaming
- Access token validation on stream requests
- Rate limiting on API endpoints
- File upload validation and sanitization

## Error Handling Strategy

### Frontend Error Recovery
- Network failure retry with exponential backoff
- Graceful degradation for missing features
- User-friendly error messages
- Automatic session recovery

### Backend Error Handling
- Structured error responses with error codes
- Detailed logging for debugging
- Transaction rollback on failures
- Circuit breaker pattern for external services

## Testing Considerations

### Unit Testing
- Component testing with React Testing Library
- Service layer testing with mocked dependencies
- State manager testing with various scenarios

### Integration Testing
- API endpoint testing with supertest
- Database integration tests with test database
- Video processing pipeline testing

### E2E Testing
- Full user journey testing
- Cross-browser compatibility
- Mobile responsiveness
- Performance testing under load

## Future Enhancements

### Planned Features
1. **Adaptive Bitrate Streaming**: Quality adjustment based on bandwidth
2. **Offline Mode**: Download videos for offline viewing
3. **Collaborative Features**: Shared watching sessions
4. **Advanced Analytics**: Detailed learning analytics dashboard
5. **AI-Powered Recommendations**: Personalized learning paths

### Technical Improvements
1. **WebSocket Integration**: Real-time progress sync
2. **CDN Integration**: Global video delivery
3. **Microservices Architecture**: Service decomposition
4. **GraphQL API**: More efficient data fetching
5. **Server-Side Rendering**: Improved SEO and performance

## Deployment Considerations

### Infrastructure Requirements
- Node.js 18+ for backend
- PostgreSQL 14+ for database
- Redis for session caching (optional)
- FFmpeg for video processing
- Google Cloud Storage for video storage

### Scaling Strategy
- Horizontal scaling for API servers
- Read replicas for database
- CDN for static assets and videos
- Queue system for video processing
- Load balancing with health checks

## Monitoring & Observability

### Metrics to Track
- Video loading times
- Session creation success rate
- Question answer submission latency
- Progress update frequency
- Error rates by endpoint

### Logging Strategy
- Structured logging with correlation IDs
- Error tracking with stack traces
- Performance metrics logging
- User action audit trail
- Security event logging

## Conclusion

The video player system architecture provides a robust foundation for interactive video-based learning. The combination of real-time state management, milestone-based interactions, and comprehensive progress tracking creates an engaging educational experience. The modular design allows for easy extension and maintenance while maintaining high performance and reliability standards.
</file>

<file path="docs/plans/LESSON_SERVICE_REFACTORING_PLAN.md">
# Lesson Service Refactoring Plan

## Executive Summary
This document outlines the plan to unify the Lessons service architecture, eliminating fragmentation between teacher and student implementations. The new architecture is based on the teacher's proven working pattern where lesson data includes embedded video groups in a single API response.

## Current Problems

### 1. Fragmented Data Fetching
- **Teacher Implementation:** Single API call - lesson response includes videoGroups
- **Student Implementation:** Multiple API calls - lesson, then separate video fetching
- **Result:** Inconsistent patterns, duplicate code, maintenance burden

### 2. API Response Inconsistencies
- `/api/videos` returns different formats (array vs paginated)
- Type definitions don't match actual API responses
- Missing proper TypeScript typing for different response formats

### 3. Duplicate Logic
- Video loading logic duplicated across components
- Different approaches to handling lesson + video data
- No shared state management pattern for lesson/video data

## Core Principle: Teacher Pattern as Standard

The teacher's implementation works reliably because:
1. **Backend includes videoGroups in lesson response** - Single API call
2. **LessonManagementPage expects embedded data** - No separate video fetching  
3. **VideoStateManager handles video details** - Centralized state management
4. **Clear data flow** - Lesson → VideoGroups → Videos → Milestones

**This pattern will become the standard for ALL lesson/video handling.**

## New Unified Architecture

### 1. Backend Standardization

#### 1.1 Unified Lesson Response Structure
```typescript
// ALL roles get the same response structure
// Role-based filtering happens within the query
interface LessonResponse {
  success: true;
  data: {
    id: string;
    title: string;
    description: string;
    status: 'DRAFT' | 'PUBLISHED' | 'ARCHIVED';
    // ALWAYS includes videoGroups
    videoGroups: VideoGroup[];
    createdBy: User;
    studentProgress?: StudentProgress[]; // Only for students
    _count: {
      videoGroups: number;
      studentProgress: number;
    };
  };
}
```

#### 1.2 getLessonById Implementation
```typescript
async getLessonById(req: AuthenticatedRequest, res: Response) {
  const { id } = req.params;
  const user = req.user!;

  const lesson = await prisma.lesson.findFirst({
    where: { 
      id,
      // Role-based filtering
      ...(user.role === 'STUDENT' ? { status: 'PUBLISHED' } : {})
    },
    include: {
      // ALWAYS include videoGroups - the teacher pattern
      videoGroups: {
        orderBy: { order: 'asc' },
        include: {
          videos: {
            orderBy: { order: 'asc' },
            // Role-based video filtering
            where: user.role === 'STUDENT' 
              ? { status: 'READY' }
              : {}, // Teachers see all videos
            select: {
              // Core fields for all roles
              id: true,
              title: true,
              description: true,
              order: true,
              status: true,
              duration: true,
              thumbnailPath: true,
              // Sensitive fields only for teachers
              filePath: user.role === 'TEACHER' || user.role === 'ADMIN',
              processingStatus: user.role === 'TEACHER' || user.role === 'ADMIN',
              _count: {
                select: { milestones: true }
              }
            }
          }
        }
      },
      // Student-specific includes
      ...(user.role === 'STUDENT' ? {
        studentProgress: {
          where: { studentId: user.id }
        }
      } : {})
    }
  });

  res.json({ success: true, data: lesson });
}
```

### 2. Frontend Unified Service

#### 2.1 Single Lesson Service
```typescript
// frontend/src/services/lesson.ts
export const lessonService = {
  // Single method for all roles - returns lesson with embedded videos
  async getLesson(lessonId: string): Promise<LessonWithVideos> {
    const response = await apiService.get(`/lessons/${lessonId}`);
    return response.data; // ALWAYS includes videoGroups
  },

  // Keep existing methods for teachers
  async createLesson(data: CreateLessonData): Promise<Lesson> { /* ... */ },
  async updateLesson(id: string, data: UpdateLessonData): Promise<Lesson> { /* ... */ },
  async publishLesson(id: string): Promise<Lesson> { /* ... */ },
  async deleteLesson(id: string): Promise<void> { /* ... */ }
};
```

#### 2.2 Video Service Cleanup
```typescript
// frontend/src/services/video.ts
export const videoService = {
  // REMOVE: getVideoGroupsByLesson() - no longer needed
  
  // Keep video-specific operations
  async getVideo(videoId: string): Promise<Video> { /* ... */ },
  async createVideoGroup(data: CreateVideoGroupData): Promise<VideoGroup> { /* ... */ },
  async uploadVideo(groupId: string, file: File, data: VideoData): Promise<Video> { /* ... */ },
  getStreamingUrl(videoId: string): string { /* ... */ }
};
```

### 3. Shared Component Architecture

#### 3.1 Base Lesson Page Component
```typescript
// frontend/src/components/lessons/BaseLessonPage.tsx
export function BaseLessonPage({ lessonId, role, children }) {
  const [lesson, setLesson] = useState<LessonWithVideos | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadLesson();
  }, [lessonId]);

  const loadLesson = async () => {
    try {
      // Single API call for ALL roles
      const lessonData = await lessonService.getLesson(lessonId);
      setLesson(lessonData);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  // Render children with lesson data
  return children({ lesson, videoGroups: lesson?.videoGroups || [] });
}
```

#### 3.2 Shared Video Components
- `VideoList` - Display list of videos (used by both roles)
- `VideoCard` - Individual video display
- `VideoThumbnailCard` - Grid view video card
- `LessonHeader` - Lesson metadata display
- `ProgressBar` - Student progress tracking

### 4. Page Implementations

#### 4.1 Teacher Lesson Management
```typescript
export default function LessonManagementPage() {
  return (
    <BaseLessonPage lessonId={lessonId} role="TEACHER">
      {({ lesson, videoGroups }) => (
        // Teacher-specific UI with management features
      )}
    </BaseLessonPage>
  );
}
```

#### 4.2 Student Lesson Detail
```typescript
export default function LessonDetailPage() {
  return (
    <BaseLessonPage lessonId={id} role="STUDENT">
      {({ lesson, videoGroups }) => (
        // Student-specific UI with learning features
      )}
    </BaseLessonPage>
  );
}
```

## Implementation Plan

### Phase 1: Backend Updates (Week 1)
1. Update `getLessonById` to always include videoGroups
2. Add role-based filtering within Prisma queries
3. Ensure consistent response structure
4. Test with different user roles

### Phase 2: Frontend Service Layer (Week 1-2)
1. Update lesson service to expect embedded videoGroups
2. Remove redundant video fetching methods
3. Update TypeScript interfaces to match new structure
4. Add proper error handling

### Phase 3: Shared Components (Week 2)
1. Create `BaseLessonPage` component
2. Build shared video display components
3. Create role-specific wrapper components
4. Implement consistent styling

### Phase 4: Page Migration (Week 2-3)
1. Migrate TeacherLessonManagementPage
2. Migrate StudentLessonDetailPage
3. Update any other lesson-related pages
4. Ensure VideoStateManager integration works

### Phase 5: Testing & Cleanup (Week 3)
1. Comprehensive testing of all user flows
2. Remove deprecated code
3. Update API documentation
4. Performance optimization

## Success Metrics

1. **Single API Call:** Both teachers and students load lesson data in one request
2. **Code Reduction:** 40-50% reduction in lesson/video related code
3. **Type Safety:** 100% TypeScript coverage for lesson/video types
4. **Performance:** Reduced page load time by eliminating sequential API calls
5. **Maintainability:** Single pattern for all lesson/video operations

## Risk Mitigation

1. **Feature Flags:** Deploy changes behind feature flags for gradual rollout
2. **Backward Compatibility:** Keep old endpoints during transition period
3. **Comprehensive Testing:** Unit, integration, and E2E tests for all changes
4. **Rollback Plan:** Git branches and deployment tags for quick reversion
5. **Monitoring:** Track API performance and error rates during rollout

## Technical Decisions

### Why Teacher Pattern?
- Already working in production
- Simpler data flow (single API call)
- Better performance (no waterfall requests)
- Easier to maintain (one pattern)

### Why Embedded VideoGroups?
- Reduces API calls
- Simplifies frontend state management
- Ensures data consistency
- Natural data hierarchy (Lesson → VideoGroups → Videos)

### Why Role-Based Filtering at Backend?
- Security (students can't access draft content)
- Performance (less data transferred)
- Consistency (single source of truth)
- Flexibility (easy to adjust permissions)

## Expected Outcomes

1. **Unified Codebase:** Single pattern for all lesson/video operations
2. **Improved Performance:** Faster page loads with fewer API calls
3. **Better Maintainability:** Less code, clearer patterns
4. **Enhanced Type Safety:** Consistent types across frontend/backend
5. **Scalability:** Easier to add new features with clear patterns

## Future Enhancements

Once the unified architecture is in place:
1. Add caching layer for lesson data
2. Implement optimistic updates for better UX
3. Add real-time collaboration features
4. Enhance progress tracking granularity
5. Build offline support for video content

## Conclusion

This refactoring eliminates the fragmentation between teacher and student implementations by standardizing on the teacher's proven pattern. The result will be a more maintainable, performant, and consistent codebase that provides a better experience for all users.

---

*Document Version: 1.0*  
*Created: January 2025*  
*Status: Approved for Implementation*
</file>

<file path="frontend/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="frontend/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="frontend/src/components/auth/AuthErrorBoundary.tsx">
import { Component } from 'react'
import type { ErrorInfo, ReactNode } from 'react'
import TokenManager from '../../services/tokenManager'

interface Props {
  children: ReactNode
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error: Error | null
  errorInfo: ErrorInfo | null
}

export class AuthErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    }
  }

  static getDerivedStateFromError(error: Error): State {
    // Update state so the next render will show the fallback UI
    return {
      hasError: true,
      error,
      errorInfo: null
    }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Auth Error Boundary caught:', error, errorInfo)
    
    // Store error info in state
    this.setState({
      error,
      errorInfo
    })

    // Check if it's an auth-related error
    const isAuthError = 
      error.message.includes('401') ||
      error.message.includes('Unauthorized') ||
      error.message.includes('token') ||
      error.message.includes('auth')

    if (isAuthError) {
      console.log('Auth error detected, clearing tokens and redirecting...')
      
      // Clear tokens and redirect to login
      TokenManager.clearTokens()
      
      // Small delay to ensure state updates
      setTimeout(() => {
        window.location.href = '/login?error=session_error'
      }, 100)
    }
  }

  handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    })
  }

  render() {
    if (this.state.hasError) {
      // Custom fallback UI
      if (this.props.fallback) {
        return <>{this.props.fallback}</>
      }

      // Default error UI
      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50">
          <div className="max-w-md w-full p-6 bg-white rounded-lg shadow-lg">
            <div className="text-center">
              <svg
                className="mx-auto h-12 w-12 text-red-500 mb-4"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
                />
              </svg>
              
              <h2 className="text-2xl font-bold text-gray-900 mb-2">
                Something went wrong
              </h2>
              
              <p className="text-gray-600 mb-6">
                {this.state.error?.message || 'An unexpected error occurred'}
              </p>

              <div className="space-y-3">
                <button
                  onClick={this.handleReset}
                  className="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                >
                  Try Again
                </button>
                
                <button
                  onClick={() => window.location.href = '/'}
                  className="w-full px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition-colors"
                >
                  Go to Home
                </button>
              </div>

              {process.env.NODE_ENV === 'development' && this.state.errorInfo && (
                <details className="mt-6 text-left">
                  <summary className="cursor-pointer text-sm text-gray-500 hover:text-gray-700">
                    Error Details (Development Only)
                  </summary>
                  <pre className="mt-2 text-xs bg-gray-100 p-2 rounded overflow-auto max-h-40">
                    {this.state.error?.stack}
                    {this.state.errorInfo.componentStack}
                  </pre>
                </details>
              )}
            </div>
          </div>
        </div>
      )
    }

    return this.props.children
  }
}
</file>

<file path="frontend/src/components/auth/AuthStatusIndicator.tsx">
import { useEffect, useState } from 'react'
import { useAuthStatus } from '../../contexts/AuthContext'
import TokenManager from '../../services/tokenManager'

export function AuthStatusIndicator() {
  const { isAuthenticated, user } = useAuthStatus()
  const [timeUntilExpiry, setTimeUntilExpiry] = useState<number>(0)
  const [showWarning, setShowWarning] = useState(false)

  useEffect(() => {
    if (!isAuthenticated) return

    const updateExpiry = () => {
      const time = TokenManager.getTimeUntilExpiry()
      setTimeUntilExpiry(time)
      
      // Show warning if less than 5 minutes
      setShowWarning(time > 0 && time < 5 * 60 * 1000)
    }

    // Update immediately
    updateExpiry()

    // Update every second
    const interval = setInterval(updateExpiry, 1000)

    return () => clearInterval(interval)
  }, [isAuthenticated])

  if (!isAuthenticated || !user) return null

  const formatTime = (ms: number): string => {
    const seconds = Math.floor(ms / 1000)
    const minutes = Math.floor(seconds / 60)
    const hours = Math.floor(minutes / 60)

    if (hours > 0) {
      return `${hours}h ${minutes % 60}m`
    }
    if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`
    }
    return `${seconds}s`
  }

  return (
    <div className="fixed bottom-4 right-4 z-50">
      {/* Normal status indicator */}
      <div className="bg-white rounded-lg shadow-lg p-3 border border-gray-200">
        <div className="flex items-center space-x-3">
          <div className="flex-shrink-0">
            <div className={`h-3 w-3 rounded-full ${isAuthenticated ? 'bg-green-500' : 'bg-gray-400'} animate-pulse`} />
          </div>
          <div className="flex-1 min-w-0">
            <p className="text-sm font-medium text-gray-900 truncate">
              {user.firstName} {user.lastName}
            </p>
            <p className="text-xs text-gray-500">
              {user.role} • {user.email}
            </p>
          </div>
        </div>

        {/* Session expiry warning */}
        {showWarning && (
          <div className="mt-2 pt-2 border-t border-gray-200">
            <div className="flex items-center text-amber-600">
              <svg className="h-4 w-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
              </svg>
              <span className="text-xs font-medium">
                Session expires in {formatTime(timeUntilExpiry)}
              </span>
            </div>
            <button
              onClick={() => window.dispatchEvent(new CustomEvent('auth:token-refresh-needed'))}
              className="mt-1 text-xs text-blue-600 hover:text-blue-800 underline"
            >
              Extend session
            </button>
          </div>
        )}
      </div>
    </div>
  )
}

// Minimal auth indicator for navbar
export function AuthBadge() {
  const { isAuthenticated, user } = useAuthStatus()
  const [isExpiringSoon, setIsExpiringSoon] = useState(false)

  useEffect(() => {
    if (!isAuthenticated) return

    const checkExpiry = () => {
      const time = TokenManager.getTimeUntilExpiry()
      setIsExpiringSoon(time > 0 && time < 5 * 60 * 1000)
    }

    checkExpiry()
    const interval = setInterval(checkExpiry, 10000) // Check every 10 seconds

    return () => clearInterval(interval)
  }, [isAuthenticated])

  if (!isAuthenticated || !user) return null

  return (
    <div className="flex items-center space-x-2">
      <div className={`h-2 w-2 rounded-full ${isExpiringSoon ? 'bg-amber-500 animate-pulse' : 'bg-green-500'}`} />
      <span className="text-sm text-gray-700">{user.firstName}</span>
      <span className="text-xs text-gray-500">({user.role})</span>
    </div>
  )
}
</file>

<file path="frontend/src/components/dashboard/StudentDashboard.tsx">
import { useState, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import type { User } from '../../types/auth'

interface StudentDashboardProps {
  user: User
}

interface DashboardStats {
  lessonsEnrolled: number
  lessonsCompleted: number
  totalWatchTime: number
  averageScore: number
  streak: number
  recentProgress: Array<{
    lessonTitle: string
    videoTitle: string
    progress: number
    timestamp: string
  }>
  achievements: Array<{
    title: string
    description: string
    earnedAt: string
  }>
}

export function StudentDashboard({ user }: StudentDashboardProps) {
  const navigate = useNavigate()
  const [stats, setStats] = useState<DashboardStats | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    loadDashboardData()
  }, [])

  const loadDashboardData = async () => {
    try {
      // This would normally fetch from API
      // For now, using mock data
      setStats({
        lessonsEnrolled: 5,
        lessonsCompleted: 2,
        totalWatchTime: 1850, // seconds
        averageScore: 85.5,
        streak: 3,
        recentProgress: [
          {
            lessonTitle: 'Introduction to React',
            videoTitle: 'Components and Props',
            progress: 75,
            timestamp: '2024-01-15T10:30:00Z'
          },
          {
            lessonTitle: 'JavaScript Fundamentals',
            videoTitle: 'Async Programming',
            progress: 100,
            timestamp: '2024-01-14T15:45:00Z'
          }
        ],
        achievements: [
          {
            title: 'First Lesson Complete',
            description: 'Completed your first lesson',
            earnedAt: '2024-01-10T12:00:00Z'
          },
          {
            title: 'High Scorer',
            description: 'Achieved over 80% average score',
            earnedAt: '2024-01-12T16:30:00Z'
          }
        ]
      })
    } catch (error) {
      console.error('Error loading dashboard data:', error)
    } finally {
      setLoading(false)
    }
  }

  const formatWatchTime = (seconds: number) => {
    const hours = Math.floor(seconds / 3600)
    const minutes = Math.floor((seconds % 3600) / 60)
    if (hours > 0) {
      return `${hours}h ${minutes}m`
    }
    return `${minutes}m`
  }

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString()
  }

  if (loading) {
    return (
      <div className="p-6">
        <div className="flex items-center justify-center h-64">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading dashboard...</p>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="p-6">
      <div className="mb-8">
        <h1 className="text-2xl font-bold text-gray-900">
          Welcome back, {user.firstName}!
        </h1>
        <p className="text-gray-600">
          Continue your learning journey and track your progress.
        </p>
      </div>

      {/* Stats Overview */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <div className="card text-center">
          <div className="text-3xl font-bold text-blue-600 mb-2">
            {stats?.lessonsEnrolled || 0}
          </div>
          <div className="text-sm text-gray-600">Lessons Enrolled</div>
        </div>
        
        <div className="card text-center">
          <div className="text-3xl font-bold text-green-600 mb-2">
            {stats?.lessonsCompleted || 0}
          </div>
          <div className="text-sm text-gray-600">Lessons Completed</div>
        </div>
        
        <div className="card text-center">
          <div className="text-3xl font-bold text-purple-600 mb-2">
            {stats ? formatWatchTime(stats.totalWatchTime) : '0m'}
          </div>
          <div className="text-sm text-gray-600">Watch Time</div>
        </div>
        
        <div className="card text-center">
          <div className="text-3xl font-bold text-yellow-600 mb-2">
            {stats?.averageScore.toFixed(1) || 0}%
          </div>
          <div className="text-sm text-gray-600">Average Score</div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        {/* Recent Progress */}
        <div className="card">
          <h3 className="text-lg font-semibold text-gray-900 mb-4">
            Recent Progress
          </h3>
          
          {stats?.recentProgress && stats.recentProgress.length > 0 ? (
            <div className="space-y-4">
              {stats.recentProgress.map((item, index) => (
                <div key={index} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                  <div className="flex-1">
                    <h4 className="font-medium text-gray-900">{item.lessonTitle}</h4>
                    <p className="text-sm text-gray-600">{item.videoTitle}</p>
                    <div className="mt-2">
                      <div className="w-full bg-gray-200 rounded-full h-2">
                        <div 
                          className="bg-blue-600 h-2 rounded-full" 
                          style={{ width: `${item.progress}%` }}
                        ></div>
                      </div>
                      <div className="text-xs text-gray-500 mt-1">
                        {item.progress}% complete
                      </div>
                    </div>
                  </div>
                  <div className="text-sm text-gray-500 ml-4">
                    {formatDate(item.timestamp)}
                  </div>
                </div>
              ))}
              
              <button
                onClick={() => navigate('/lessons')}
                className="w-full mt-4 btn-primary"
              >
                Browse All Lessons
              </button>
            </div>
          ) : (
            <div className="text-center py-8">
              <svg className="w-12 h-12 text-gray-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
              </svg>
              <p className="text-gray-500 mb-4">No lessons started yet</p>
              <button
                onClick={() => navigate('/lessons')}
                className="btn-primary"
              >
                Start Learning
              </button>
            </div>
          )}
        </div>

        {/* Achievements & Streak */}
        <div className="space-y-6">
          {/* Learning Streak */}
          <div className="card">
            <h3 className="text-lg font-semibold text-gray-900 mb-4">
              Learning Streak
            </h3>
            <div className="text-center">
              <div className="text-4xl font-bold text-orange-600 mb-2">
                🔥 {stats?.streak || 0}
              </div>
              <div className="text-sm text-gray-600">
                {stats?.streak ? `${stats.streak} days in a row!` : 'Start your streak today!'}
              </div>
            </div>
          </div>

          {/* Achievements */}
          <div className="card">
            <h3 className="text-lg font-semibold text-gray-900 mb-4">
              Achievements
            </h3>
            
            {stats?.achievements && stats.achievements.length > 0 ? (
              <div className="space-y-3">
                {stats.achievements.map((achievement, index) => (
                  <div key={index} className="flex items-center p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                    <div className="text-2xl mr-3">🏆</div>
                    <div className="flex-1">
                      <h4 className="font-medium text-gray-900">{achievement.title}</h4>
                      <p className="text-sm text-gray-600">{achievement.description}</p>
                      <p className="text-xs text-gray-500 mt-1">
                        Earned {formatDate(achievement.earnedAt)}
                      </p>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-center py-4">
                <div className="text-4xl mb-2">🏆</div>
                <p className="text-gray-500">No achievements yet</p>
                <p className="text-sm text-gray-400 mt-1">
                  Complete lessons to earn achievements!
                </p>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Quick Actions */}
      <div className="mt-8">
        <h2 className="text-xl font-bold text-gray-900 mb-4">Quick Actions</h2>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <button
            onClick={() => navigate('/lessons')}
            className="card hover:bg-gray-50 transition-colors text-center p-6"
          >
            <div className="text-3xl mb-2">📚</div>
            <div className="font-medium text-gray-900">Browse Lessons</div>
            <div className="text-sm text-gray-600 mt-1">Discover new content</div>
          </button>
          
          <button
            onClick={() => {
              // Navigate to most recent lesson
              if (stats?.recentProgress && stats.recentProgress.length > 0) {
                // This would navigate to the specific video
                navigate('/lessons')
              } else {
                navigate('/lessons')
              }
            }}
            className="card hover:bg-gray-50 transition-colors text-center p-6"
          >
            <div className="text-3xl mb-2">▶️</div>
            <div className="font-medium text-gray-900">Continue Learning</div>
            <div className="text-sm text-gray-600 mt-1">Pick up where you left off</div>
          </button>
          
          <button
            onClick={() => {
              // This would show progress/statistics page
              navigate('/lessons')
            }}
            className="card hover:bg-gray-50 transition-colors text-center p-6"
          >
            <div className="text-3xl mb-2">📊</div>
            <div className="font-medium text-gray-900">View Progress</div>
            <div className="text-sm text-gray-600 mt-1">Track your learning</div>
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/lessons/VideoList.tsx">
import { type VideoGroup, type Video } from '../../services/lesson'

interface VideoListProps {
  videoGroups: VideoGroup[]
  selectedVideoId?: string | null
  onVideoSelect: (video: Video) => void
  showManageButtons?: boolean // For teachers
  onUploadClick?: () => void
}

export function VideoList({ 
  videoGroups, 
  selectedVideoId, 
  onVideoSelect,
  showManageButtons = false,
  onUploadClick
}: VideoListProps) {
  const allVideos = videoGroups.flatMap(g => g.videos || [])
  
  if (allVideos.length === 0) {
    return (
      <div className="text-center py-8">
        <svg className="w-12 h-12 text-gray-400 mx-auto mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
        </svg>
        <p className="text-gray-500 mb-4">No videos added yet</p>
        {showManageButtons && onUploadClick && (
          <button
            onClick={onUploadClick}
            className="btn-primary"
          >
            Upload First Video
          </button>
        )}
      </div>
    )
  }

  return (
    <div className="space-y-3">
      {allVideos.map((video, index) => (
        <VideoCard
          key={video.id}
          video={video}
          index={index}
          isSelected={selectedVideoId === video.id}
          onClick={() => onVideoSelect(video)}
        />
      ))}
    </div>
  )
}

interface VideoCardProps {
  video: Video
  index: number
  isSelected: boolean
  onClick: () => void
}

function VideoCard({ video, index, isSelected, onClick }: VideoCardProps) {
  const formatDuration = (seconds: number | null) => {
    if (!seconds) return 'Unknown'
    const mins = Math.floor(seconds / 60)
    const secs = seconds % 60
    return `${mins}:${secs.toString().padStart(2, '0')}`
  }

  return (
    <div
      onClick={onClick}
      className={`p-3 border rounded-lg cursor-pointer transition-colors ${
        isSelected
          ? 'border-blue-500 bg-blue-50'
          : 'border-gray-300 hover:border-gray-400 hover:bg-gray-50'
      }`}
    >
      <div className="flex items-center">
        <div className="flex-shrink-0 w-12 h-8 bg-gray-300 rounded overflow-hidden mr-3">
          {video.thumbnailPath || video.thumbnailUrl ? (
            <img
              src={video.thumbnailUrl || `/api/v1/videos/${video.id}/thumbnail`}
              alt={video.title}
              className="w-full h-full object-cover"
              onError={(e) => {
                // Fallback to placeholder on error
                const target = e.target as HTMLImageElement
                target.style.display = 'none'
                target.parentElement!.innerHTML = `
                  <div class="w-full h-full flex items-center justify-center">
                    <svg class="w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                  </div>
                `
              }}
            />
          ) : (
            <div className="w-full h-full flex items-center justify-center">
              <svg className="w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
              </svg>
            </div>
          )}
        </div>
        
        <div className="flex-1 min-w-0">
          <h4 className="font-medium text-gray-900 truncate">
            {index + 1}. {video.title}
          </h4>
          <div className="text-sm text-gray-500">
            {formatDuration(video.duration)}
            {video._count && video._count.milestones > 0 && (
              <span className="ml-2">• {video._count.milestones} milestones</span>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/__tests__/LoadingSpinner.test.tsx">
import { describe, it, expect } from 'vitest';
import { screen } from '@testing-library/react';
import { render } from '../../../test/utils';
import LoadingSpinner from '../LoadingSpinner';

describe('LoadingSpinner', () => {
  it('renders with default size', () => {
    render(<LoadingSpinner />);
    
    const spinner = screen.getByTestId('loading-spinner');
    expect(spinner).toBeInTheDocument();
    expect(spinner).toHaveClass('w-8', 'h-8'); // Default medium size
  });

  it('renders with small size', () => {
    render(<LoadingSpinner size="sm" />);
    
    const spinner = screen.getByTestId('loading-spinner');
    expect(spinner).toHaveClass('w-4', 'h-4');
  });

  it('renders with large size', () => {
    render(<LoadingSpinner size="lg" />);
    
    const spinner = screen.getByTestId('loading-spinner');
    expect(spinner).toHaveClass('w-12', 'h-12');
  });

  it('applies custom className', () => {
    render(<LoadingSpinner className="custom-class" />);
    
    const spinner = screen.getByTestId('loading-spinner');
    expect(spinner).toHaveClass('custom-class');
  });

  it('renders with custom color', () => {
    render(<LoadingSpinner className="text-red-500" />);
    
    const spinner = screen.getByTestId('loading-spinner');
    expect(spinner).toHaveClass('text-red-500');
  });

  it('has proper accessibility attributes', () => {
    render(<LoadingSpinner />);
    
    const spinner = screen.getByTestId('loading-spinner');
    expect(spinner).toHaveAttribute('role', 'status');
    expect(spinner).toHaveAttribute('aria-live', 'polite');
    
    // Check for screen reader text
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });

  it('is visible and animating', () => {
    render(<LoadingSpinner />);
    
    const spinner = screen.getByTestId('loading-spinner');
    expect(spinner).toBeVisible();
    expect(spinner).toHaveClass('animate-spin');
  });

  it('renders center aligned by default', () => {
    render(<LoadingSpinner />);
    
    const container = screen.getByTestId('loading-spinner').parentElement;
    expect(container).toHaveClass('flex', 'justify-center', 'items-center');
  });

  it('can be rendered inline', () => {
    render(<LoadingSpinner inline />);
    
    const spinner = screen.getByTestId('loading-spinner');
    expect(spinner).not.toHaveClass('flex', 'justify-center', 'items-center');
  });

  it('supports different themes', () => {
    const { rerender } = render(<LoadingSpinner />);
    
    // Default theme
    let spinner = screen.getByTestId('loading-spinner');
    expect(spinner).toHaveClass('text-primary-600');
    
    // Light theme
    rerender(<LoadingSpinner theme="light" />);
    spinner = screen.getByTestId('loading-spinner');
    expect(spinner).toHaveClass('text-white');
    
    // Dark theme
    rerender(<LoadingSpinner theme="dark" />);
    spinner = screen.getByTestId('loading-spinner');
    expect(spinner).toHaveClass('text-gray-800');
  });
});
</file>

<file path="frontend/src/pages/auth/__tests__/LoginPage.test.tsx">
import { describe, it, expect, vi } from 'vitest';
import { screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { render } from '../../../test/utils';
import LoginPage from '../LoginPage';
import { server } from '../../../test/mocks/server';
import { http, HttpResponse } from 'msw';

describe('LoginPage', () => {
  it('renders login form correctly', () => {
    render(<LoginPage />);
    
    expect(screen.getByRole('heading', { name: /sign in to your account/i })).toBeInTheDocument();
    expect(screen.getByLabelText(/email address/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /sign in/i })).toBeInTheDocument();
    expect(screen.getByText(/create a new account/i)).toBeInTheDocument();
  });

  it('displays demo credentials', () => {
    render(<LoginPage />);
    
    expect(screen.getByText(/demo credentials:/i)).toBeInTheDocument();
    expect(screen.getByText(/teacher@example\.com/)).toBeInTheDocument();
    expect(screen.getByText(/student@example\.com/)).toBeInTheDocument();
  });

  it('validates email field', async () => {
    const user = userEvent.setup();
    render(<LoginPage />);
    
    const emailField = screen.getByLabelText(/email address/i);
    const submitButton = screen.getByRole('button', { name: /sign in/i });
    
    // Try to submit without email
    await user.click(submitButton);
    
    await waitFor(() => {
      expect(screen.getByText(/email is required/i)).toBeInTheDocument();
    });
    
    // Try with invalid email
    await user.type(emailField, 'invalid-email');
    await user.click(submitButton);
    
    await waitFor(() => {
      expect(screen.getByText(/please enter a valid email address/i)).toBeInTheDocument();
    });
  });

  it('validates password field', async () => {
    const user = userEvent.setup();
    render(<LoginPage />);
    
    const emailField = screen.getByLabelText(/email address/i);
    const submitButton = screen.getByRole('button', { name: /sign in/i });
    
    await user.type(emailField, 'test@example.com');
    await user.click(submitButton);
    
    await waitFor(() => {
      expect(screen.getByText(/password is required/i)).toBeInTheDocument();
    });
  });

  it('submits form with valid credentials', async () => {
    const user = userEvent.setup();
    const mockLogin = vi.fn();
    
    render(<LoginPage />, {
      authStore: { login: mockLogin }
    });
    
    const emailField = screen.getByLabelText(/email address/i);
    const passwordField = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole('button', { name: /sign in/i });
    
    await user.type(emailField, 'teacher@example.com');
    await user.type(passwordField, 'TestPassword123!');
    await user.click(submitButton);
    
    await waitFor(() => {
      expect(mockLogin).toHaveBeenCalledWith({
        email: 'teacher@example.com',
        password: 'TestPassword123!'
      });
    });
  });

  it('displays error message on login failure', async () => {
    const user = userEvent.setup();
    
    // Mock API to return error
    server.use(
      http.post('http://localhost:3000/api/auth/login', () => {
        return HttpResponse.json(
          { error: 'Invalid credentials' },
          { status: 401 }
        );
      })
    );
    
    const mockLogin = vi.fn().mockRejectedValue(new Error('Invalid credentials'));
    
    render(<LoginPage />, {
      authStore: { login: mockLogin }
    });
    
    const emailField = screen.getByLabelText(/email address/i);
    const passwordField = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole('button', { name: /sign in/i });
    
    await user.type(emailField, 'wrong@example.com');
    await user.type(passwordField, 'wrongpassword');
    await user.click(submitButton);
    
    await waitFor(() => {
      expect(screen.getByText(/invalid credentials/i)).toBeInTheDocument();
    });
  });

  it('shows loading state during login', async () => {
    const user = userEvent.setup();
    
    // Create a delayed login mock
    const mockLogin = vi.fn(() => new Promise(resolve => setTimeout(resolve, 100)));
    
    render(<LoginPage />, {
      authStore: { login: mockLogin }
    });
    
    const emailField = screen.getByLabelText(/email address/i);
    const passwordField = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole('button', { name: /sign in/i });
    
    await user.type(emailField, 'teacher@example.com');
    await user.type(passwordField, 'TestPassword123!');
    await user.click(submitButton);
    
    // Should show loading spinner
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();
    expect(submitButton).toBeDisabled();
    
    await waitFor(() => {
      expect(screen.queryByTestId('loading-spinner')).not.toBeInTheDocument();
    }, { timeout: 200 });
  });

  it('navigates to register page', async () => {
    const user = userEvent.setup();
    
    render(<LoginPage />, {
      routerProps: { initialEntries: ['/login'] }
    });
    
    const registerLink = screen.getByText(/create a new account/i);
    await user.click(registerLink);
    
    // This would be tested with actual router integration
    expect(registerLink.closest('a')).toHaveAttribute('href', '/register');
  });

  it('handles form reset on unmount', () => {
    const { unmount } = render(<LoginPage />);
    
    const emailField = screen.getByLabelText(/email address/i);
    const passwordField = screen.getByLabelText(/password/i);
    
    // Fill form
    userEvent.type(emailField, 'test@example.com');
    userEvent.type(passwordField, 'password');
    
    // Unmount component
    unmount();
    
    // Remount and verify fields are empty
    render(<LoginPage />);
    
    const newEmailField = screen.getByLabelText(/email address/i);
    const newPasswordField = screen.getByLabelText(/password/i);
    
    expect(newEmailField).toHaveValue('');
    expect(newPasswordField).toHaveValue('');
  });

  it('is accessible', () => {
    render(<LoginPage />);
    
    // Check for proper form labels
    expect(screen.getByLabelText(/email address/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();
    
    // Check for proper heading hierarchy
    expect(screen.getByRole('heading', { level: 2 })).toBeInTheDocument();
    
    // Check for proper button role
    expect(screen.getByRole('button', { name: /sign in/i })).toBeInTheDocument();
    
    // Check for proper form structure
    const form = screen.getByRole('form');
    expect(form).toBeInTheDocument();
  });

  it('prefills form with demo credentials when clicked', async () => {
    const user = userEvent.setup();
    render(<LoginPage />);
    
    // This would require implementing click handlers for demo credentials
    // For now, we just verify the demo credentials are displayed
    expect(screen.getByText(/teacher@example\.com/)).toBeInTheDocument();
    expect(screen.getByText(/Demo123!/)).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/pages/auth/RegisterPage.tsx">
export default function RegisterPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full">
        <h1 className="text-3xl font-bold text-center text-gray-900 mb-8">
          Register Page
        </h1>
        <p className="text-center text-gray-600">
          Registration form coming soon...
        </p>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/pages/dashboard/DashboardPage.tsx">
import { useAuth } from '../../hooks/useAuth'
import { StudentDashboard } from '../../components/dashboard/StudentDashboard'
import { TeacherDashboard } from '../../components/dashboard/TeacherDashboard'
import { AdminDashboard } from '../../components/dashboard/AdminDashboard'

export default function DashboardPage() {
  const { user } = useAuth()

  if (!user) {
    return (
      <div className="p-6">
        <div className="flex items-center justify-center h-64">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading...</p>
          </div>
        </div>
      </div>
    )
  }

  // Render role-based dashboard
  switch (user.role) {
    case 'ADMIN':
      return <AdminDashboard user={user} />
    case 'TEACHER':
      return <TeacherDashboard user={user} />
    case 'STUDENT':
    default:
      return <StudentDashboard user={user} />
  }
}
</file>

<file path="frontend/src/services/ai.ts">
import { apiService } from './api'
import type { ApiResponse } from './video'

export interface GeneratedQuestion {
  type: 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'SHORT_ANSWER'
  question: string
  options?: string[]
  correctAnswer: string
  explanation?: string
  suggestedTimestamp?: number
}

export interface GenerateQuestionsRequest {
  videoTitle: string
  videoDescription?: string
  content: string
  questionCount?: number
  questionTypes?: ('MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'SHORT_ANSWER')[]
  difficulty?: 'EASY' | 'MEDIUM' | 'HARD'
  provider?: 'OPENAI' | 'CLAUDE'
}

export interface GenerateQuestionsResponse {
  milestoneTitle: string
  milestoneDescription?: string
  questions: GeneratedQuestion[]
}

export interface AIProvidersResponse {
  providers: string[]
  hasAISupport: boolean
}

export const aiService = {
  // Get available AI providers
  async getProviders() {
    const response = await apiService.get<ApiResponse<AIProvidersResponse>>('/ai/providers')
    return response.data
  },

  // Generate questions from content
  async generateQuestions(request: GenerateQuestionsRequest): Promise<GenerateQuestionsResponse> {
    const response = await apiService.post<ApiResponse<GenerateQuestionsResponse>>('/ai/generate-questions', request)
    
    if (!response.success) {
      throw new Error(response.error || 'Failed to generate questions')
    }
    
    return response.data
  },

  // Generate questions for existing milestone
  async generateQuestionsForMilestone(milestoneId: string, request: {
    content?: string
    questionCount?: number
    questionTypes?: ('MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'SHORT_ANSWER')[]
    difficulty?: 'EASY' | 'MEDIUM' | 'HARD'
    provider?: 'OPENAI' | 'CLAUDE'
  }) {
    const response = await apiService.post<ApiResponse<{ questionsAdded: number; milestone: any }>>(`/ai/generate-for-milestone/${milestoneId}`, request)
    
    if (!response.success) {
      throw new Error(response.error || 'Failed to generate questions for milestone')
    }
    
    return response.data
  },

  // Generate milestone with questions
  async generateMilestoneWithQuestions(videoId: string, request: GenerateQuestionsRequest) {
    const response = await apiService.post<ApiResponse<{ milestone: any; questionsAdded: number }>>(`/ai/generate-milestone-with-questions/${videoId}`, request)
    
    if (!response.success) {
      throw new Error(response.error || 'Failed to generate milestone with questions')
    }
    
    return response.data
  }
}
</file>

<file path="frontend/src/stores/README.md">
# VideoStateManager - Unified State Management

## Overview
The VideoStateManager is a centralized state management solution that eliminates desynchronization issues between components by providing a single source of truth for all video, milestone, and question data.

## Problem Solved
Previously, multiple components maintained their own local copies of state:
- LessonManagementPage had its own video/milestone state
- VideoPlayer had separate milestone tracking
- QuestionEditor managed questions locally without syncing
- AIQuestionGenerator didn't propagate generated questions
- Counts would become stale after adding/editing content

## Solution Architecture

### Core Components

1. **VideoStateManager** (`stores/VideoStateManager.ts`)
   - Singleton class managing all video states
   - Observable pattern for real-time updates
   - Intelligent caching with TTL
   - Optimistic updates for immediate UI feedback

2. **VideoStateContext** (`contexts/VideoStateContext.tsx`)
   - React Context providing manager instance
   - Available throughout the component tree

3. **useVideoState Hook** (`hooks/useVideoState.ts`)
   - React hook for accessing video state
   - Automatic subscription to updates
   - Returns video, milestones, questions, and metadata

## Key Features

### Real-time Synchronization
When any component updates data (add question, create milestone), ALL subscribed components immediately receive the update:
```typescript
// In QuestionEditor - adds question
await manager.addQuestion(videoId, milestoneId, question)
// LessonManagementPage automatically shows new count
// VideoPlayer sees the new question
// No manual refresh needed!
```

### Unified Metadata
Centralized tracking of:
- Total milestones per video
- Total questions per video
- Questions per milestone
- Completion percentages
- Last update timestamps

### Smart Caching
- 30-second cache for video data
- Automatic invalidation on updates
- Force refresh option available
- Background sync with backend

## Usage Examples

### Adding a Question
```typescript
// Old way - local state only
setQuestions(prev => [...prev, newQuestion])

// New way - updates all subscribers
await manager.addQuestion(videoId, milestoneId, newQuestion)
```

### Getting Current State
```typescript
// In any component
const { video, milestones, metadata } = useVideoState(videoId)

// metadata includes:
// - totalMilestones
// - totalQuestions  
// - questionsPerMilestone (Map)
```

### Subscribing to Changes
```typescript
// Automatic in components
const { state } = useVideoState(videoId) // Auto-subscribes

// Manual subscription
const unsubscribe = manager.subscribeToVideo(videoId, (id, state) => {
  console.log('Video updated:', state)
})
```

## Components Updated

1. **LessonManagementPage**
   - Uses `useVideoState` for selected video
   - No more manual milestone array updates
   - Counts always accurate

2. **VideoPlayer**
   - Subscribes to milestone updates
   - Shows real-time question counts
   - Unified progress tracking

3. **QuestionEditor**
   - Adds questions through manager
   - No local question array
   - Changes propagate instantly

4. **AIQuestionGenerator**
   - Batch adds questions through manager
   - No need for parent refresh
   - Immediate count updates

5. **VideoPlayerPage**
   - Uses unified session state
   - Consistent progress metrics
   - Real-time milestone tracking

## Benefits

1. **No More Desynchronization**
   - Single source of truth
   - All components see same data
   - Updates propagate instantly

2. **Reduced API Calls**
   - Smart caching reduces backend load
   - Only fetches when necessary
   - Optimistic updates for speed

3. **Better Developer Experience**
   - Simple API: `addQuestion`, `addMilestone`
   - Automatic subscriptions in React
   - TypeScript types throughout

4. **Improved User Experience**
   - Instant UI updates
   - No loading states for local changes
   - Consistent data everywhere

## Migration Guide

### Before (Local State)
```typescript
const [selectedVideo, setSelectedVideo] = useState(null)
const [questions, setQuestions] = useState([])

// Manual updates
setSelectedVideo(prev => ({
  ...prev,
  milestones: [...prev.milestones, newMilestone]
}))
```

### After (Unified State)
```typescript
const { video, milestones, questions } = useVideoState(videoId)
const manager = useVideoStateManager()

// Automatic updates
await manager.addMilestone(videoId, newMilestone)
// All components updated!
```

## Testing
The VideoStateManager ensures:
- Question counts update immediately when added
- Milestone counts reflect current state
- Preview shows same data as management view
- No stale data after edits
- Session progress syncs across components
</file>

<file path="frontend/src/test/mocks/handlers.ts">
import { http, HttpResponse } from 'msw';
import { User, LoginCredentials, RegisterData } from '../../types/auth';
import { createTestUser, createTestTeacher, createTestStudent } from '../utils';

const API_BASE_URL = 'http://localhost:3000/api';

// Mock users database
const mockUsers: User[] = [
  createTestTeacher({ 
    id: 'teacher-1', 
    email: 'teacher@example.com',
    firstName: 'John',
    lastName: 'Teacher'
  }),
  createTestStudent({ 
    id: 'student-1', 
    email: 'student@example.com',
    firstName: 'Jane',
    lastName: 'Student'
  }),
];

// Mock tokens
const generateMockToken = (userId: string) => `mock-jwt-token-${userId}`;

export const handlers = [
  // Authentication endpoints
  http.post(`${API_BASE_URL}/auth/register`, async ({ request }) => {
    const body = await request.json() as RegisterData;
    
    // Check if user already exists
    const existingUser = mockUsers.find(u => u.email === body.email);
    if (existingUser) {
      return HttpResponse.json(
        { error: 'User with this email already exists' },
        { status: 409 }
      );
    }

    // Create new user
    const newUser = createTestUser({
      id: `user-${mockUsers.length + 1}`,
      email: body.email,
      firstName: body.firstName,
      lastName: body.lastName,
      role: body.role
    });
    
    mockUsers.push(newUser);

    return HttpResponse.json({
      user: newUser,
      accessToken: generateMockToken(newUser.id),
      refreshToken: `refresh-${newUser.id}`
    }, { status: 201 });
  }),

  http.post(`${API_BASE_URL}/auth/login`, async ({ request }) => {
    const body = await request.json() as LoginCredentials;
    
    // Find user by email
    const user = mockUsers.find(u => u.email === body.email);
    if (!user || body.password !== 'TestPassword123!') {
      return HttpResponse.json(
        { error: 'Invalid credentials' },
        { status: 401 }
      );
    }

    return HttpResponse.json({
      user,
      accessToken: generateMockToken(user.id),
      refreshToken: `refresh-${user.id}`
    });
  }),

  http.post(`${API_BASE_URL}/auth/refresh`, async ({ request }) => {
    const body = await request.json() as { refreshToken: string };
    
    if (!body.refreshToken || !body.refreshToken.startsWith('refresh-')) {
      return HttpResponse.json(
        { error: 'Invalid refresh token' },
        { status: 401 }
      );
    }

    const userId = body.refreshToken.replace('refresh-', '');
    const user = mockUsers.find(u => u.id === userId);
    
    if (!user) {
      return HttpResponse.json(
        { error: 'Invalid refresh token' },
        { status: 401 }
      );
    }

    return HttpResponse.json({
      accessToken: generateMockToken(userId),
      refreshToken: `refresh-${userId}-new`
    });
  }),

  http.post(`${API_BASE_URL}/auth/logout`, () => {
    return HttpResponse.json({ message: 'Logged out successfully' });
  }),

  // User endpoints
  http.get(`${API_BASE_URL}/users/me`, ({ request }) => {
    const authHeader = request.headers.get('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return HttpResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const token = authHeader.replace('Bearer ', '');
    const userId = token.replace('mock-jwt-token-', '');
    const user = mockUsers.find(u => u.id === userId);

    if (!user) {
      return HttpResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    return HttpResponse.json(user);
  }),

  // Lessons endpoints
  http.get(`${API_BASE_URL}/lessons`, ({ request }) => {
    const url = new URL(request.url);
    const page = parseInt(url.searchParams.get('page') || '1');
    const limit = parseInt(url.searchParams.get('limit') || '10');
    const search = url.searchParams.get('search');

    // Mock lessons data
    let lessons = [
      {
        id: '1',
        title: 'Introduction to React',
        description: 'Learn the basics of React framework',
        thumbnail: 'https://example.com/thumb1.jpg',
        duration: 1800,
        difficulty: 'beginner',
        tags: ['react', 'javascript'],
        createdBy: mockUsers[0],
        createdAt: '2023-01-01T00:00:00.000Z',
        updatedAt: '2023-01-01T00:00:00.000Z'
      },
      {
        id: '2',
        title: 'Advanced TypeScript',
        description: 'Master advanced TypeScript concepts',
        thumbnail: 'https://example.com/thumb2.jpg',
        duration: 2400,
        difficulty: 'advanced',
        tags: ['typescript', 'javascript'],
        createdBy: mockUsers[0],
        createdAt: '2023-01-02T00:00:00.000Z',
        updatedAt: '2023-01-02T00:00:00.000Z'
      }
    ];

    // Apply search filter
    if (search) {
      lessons = lessons.filter(lesson => 
        lesson.title.toLowerCase().includes(search.toLowerCase()) ||
        lesson.description.toLowerCase().includes(search.toLowerCase())
      );
    }

    // Apply pagination
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedLessons = lessons.slice(startIndex, endIndex);

    return HttpResponse.json({
      lessons: paginatedLessons,
      pagination: {
        page,
        limit,
        total: lessons.length,
        totalPages: Math.ceil(lessons.length / limit)
      }
    });
  }),

  http.get(`${API_BASE_URL}/lessons/:id`, ({ params }) => {
    const lessonId = params.id as string;
    
    const lesson = {
      id: lessonId,
      title: 'Introduction to React',
      description: 'Learn the basics of React framework',
      thumbnail: 'https://example.com/thumb1.jpg',
      duration: 1800,
      difficulty: 'beginner',
      tags: ['react', 'javascript'],
      objectives: ['Learn JSX', 'Understand components', 'Master hooks'],
      createdBy: mockUsers[0],
      videoGroups: [
        {
          id: 'vg-1',
          title: 'Getting Started',
          videos: [
            {
              id: 'video-1',
              title: 'What is React?',
              duration: 300,
              thumbnail: 'https://example.com/video-thumb1.jpg',
              url: 'https://example.com/video1.mp4'
            }
          ]
        }
      ],
      createdAt: '2023-01-01T00:00:00.000Z',
      updatedAt: '2023-01-01T00:00:00.000Z'
    };

    return HttpResponse.json(lesson);
  }),

  // Video endpoints
  http.get(`${API_BASE_URL}/videos/:id`, ({ params }) => {
    const videoId = params.id as string;
    
    const video = {
      id: videoId,
      title: 'What is React?',
      description: 'Introduction to React framework',
      duration: 300,
      url: 'https://example.com/video1.mp4',
      thumbnail: 'https://example.com/video-thumb1.jpg',
      milestones: [
        {
          id: 'milestone-1',
          type: 'QUIZ',
          timestamp: 30,
          title: 'Quick Check',
          questions: [
            {
              id: 'q1',
              type: 'MULTIPLE_CHOICE',
              question: 'What is React?',
              options: ['Library', 'Framework', 'Language', 'Database'],
              correctAnswer: 'Library'
            }
          ]
        }
      ],
      createdAt: '2023-01-01T00:00:00.000Z',
      updatedAt: '2023-01-01T00:00:00.000Z'
    };

    return HttpResponse.json(video);
  }),

  // Progress endpoints
  http.get(`${API_BASE_URL}/progress/lessons/:id`, ({ params }) => {
    const lessonId = params.id as string;
    
    return HttpResponse.json({
      lessonId,
      progress: 0.65,
      completedVideos: 2,
      totalVideos: 5,
      watchTime: 1200,
      lastAccessedAt: '2023-01-03T10:00:00.000Z'
    });
  }),

  http.post(`${API_BASE_URL}/sessions/start`, async ({ request }) => {
    const body = await request.json() as { videoId: string };
    
    return HttpResponse.json({
      sessionId: `session-${Date.now()}`,
      videoId: body.videoId,
      startTime: new Date().toISOString()
    }, { status: 201 });
  }),

  http.put(`${API_BASE_URL}/sessions/:id/progress`, async ({ params, request }) => {
    const sessionId = params.id as string;
    const body = await request.json() as { currentTime: number; totalWatchTime: number };
    
    return HttpResponse.json({
      sessionId,
      currentTime: body.currentTime,
      totalWatchTime: body.totalWatchTime,
      updatedAt: new Date().toISOString()
    });
  }),

  // Questions and answers
  http.post(`${API_BASE_URL}/answers`, async ({ request }) => {
    const body = await request.json() as { questionId: string; answer: string; milestoneId: string };
    
    // Simple correct/incorrect logic for testing
    const isCorrect = body.answer === 'Library';
    
    return HttpResponse.json({
      id: `answer-${Date.now()}`,
      questionId: body.questionId,
      milestoneId: body.milestoneId,
      isCorrect,
      score: isCorrect ? 10 : 0,
      explanation: isCorrect 
        ? 'Correct! React is a JavaScript library.'
        : 'Incorrect. React is a JavaScript library, not a framework.',
      submittedAt: new Date().toISOString()
    }, { status: 201 });
  }),

  // Error handler for unhandled requests
  http.all('*', ({ request }) => {
    console.warn(`Unhandled ${request.method} request to ${request.url}`);
    return HttpResponse.json(
      { error: 'Not found' },
      { status: 404 }
    );
  })
];

// Additional handlers for specific test scenarios
export const errorHandlers = [
  // Server error scenarios
  http.post(`${API_BASE_URL}/auth/login`, () => {
    return HttpResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }),

  // Network error scenarios
  http.get(`${API_BASE_URL}/lessons`, () => {
    return HttpResponse.error();
  }),
];

// Delayed response handlers for loading state testing
export const delayedHandlers = [
  http.get(`${API_BASE_URL}/lessons`, async () => {
    await new Promise(resolve => setTimeout(resolve, 2000));
    return HttpResponse.json({ lessons: [], pagination: { page: 1, limit: 10, total: 0, totalPages: 0 } });
  }),
];
</file>

<file path="frontend/src/test/mocks/server.ts">
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

// Setup mock service worker server for Node.js environment (tests)
export const server = setupServer(...handlers);

// Export handlers for individual test customization
export { handlers } from './handlers';
export * from './handlers';
</file>

<file path="frontend/src/test/setup.ts">
import '@testing-library/jest-dom';
import { vi } from 'vitest';
import { cleanup } from '@testing-library/react';
import { server } from './mocks/server';

// Mock environment variables
Object.defineProperty(window, 'ENV', {
  value: {
    API_URL: 'http://localhost:3000/api',
    NODE_ENV: 'test'
  },
  writable: true
});

// Mock fetch globally
global.fetch = vi.fn();

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(), // deprecated
    removeListener: vi.fn(), // deprecated
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});

// Mock IntersectionObserver
class MockIntersectionObserver {
  observe = vi.fn();
  disconnect = vi.fn();
  unobserve = vi.fn();
}

Object.defineProperty(window, 'IntersectionObserver', {
  writable: true,
  configurable: true,
  value: MockIntersectionObserver,
});

Object.defineProperty(global, 'IntersectionObserver', {
  writable: true,
  configurable: true,
  value: MockIntersectionObserver,
});

// Mock ResizeObserver
class MockResizeObserver {
  observe = vi.fn();
  disconnect = vi.fn();
  unobserve = vi.fn();
}

Object.defineProperty(window, 'ResizeObserver', {
  writable: true,
  configurable: true,
  value: MockResizeObserver,
});

// Mock HTMLMediaElement
Object.defineProperty(HTMLMediaElement.prototype, 'play', {
  writable: true,
  value: vi.fn().mockImplementation(() => Promise.resolve()),
});

Object.defineProperty(HTMLMediaElement.prototype, 'pause', {
  writable: true,
  value: vi.fn(),
});

Object.defineProperty(HTMLMediaElement.prototype, 'load', {
  writable: true,
  value: vi.fn(),
});

// Mock react-player
vi.mock('react-player', () => ({
  default: vi.fn(({ onReady, onProgress, onDuration, onPlay, onPause }) => {
    // Simulate player events for testing
    if (onReady) setTimeout(() => onReady(), 100);
    if (onDuration) setTimeout(() => onDuration(300), 100);
    
    return (
      <div data-testid="react-player">
        <button onClick={() => onPlay && onPlay()} data-testid="play-button">
          Play
        </button>
        <button onClick={() => onPause && onPause()} data-testid="pause-button">
          Pause
        </button>
        <div data-testid="progress" onClick={() => onProgress && onProgress({ playedSeconds: 150, played: 0.5 })}>
          Progress
        </div>
      </div>
    );
  })
}));

// Mock axios
vi.mock('axios', () => ({
  default: {
    create: vi.fn(() => ({
      get: vi.fn(),
      post: vi.fn(),
      put: vi.fn(),
      delete: vi.fn(),
      patch: vi.fn(),
      interceptors: {
        request: { use: vi.fn() },
        response: { use: vi.fn() }
      }
    })),
    get: vi.fn(),
    post: vi.fn(),
    put: vi.fn(),
    delete: vi.fn(),
    patch: vi.fn()
  }
}));

// Mock zustand stores
vi.mock('../stores/authStore', () => ({
  useAuthStore: vi.fn(() => ({
    user: null,
    token: null,
    isAuthenticated: false,
    login: vi.fn(),
    logout: vi.fn(),
    setUser: vi.fn()
  }))
}));

// Setup MSW server
beforeAll(() => server.listen({ onUnhandledRequest: 'error' }));
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

// Clean up DOM after each test
afterEach(() => {
  cleanup();
  vi.clearAllMocks();
});
</file>

<file path="frontend/src/types/auth.ts">
export interface User {
  id: string
  email: string
  username?: string
  firstName: string
  lastName: string
  avatar?: string
  role: 'STUDENT' | 'TEACHER' | 'ADMIN'
  status: 'ACTIVE' | 'INACTIVE' | 'SUSPENDED' | 'PENDING_VERIFICATION'
  tenantId?: string
  lastLoginAt?: string
  emailVerified?: string
  createdAt: string
}

export interface LoginCredentials {
  email: string
  password: string
}

export interface RegisterData {
  email: string
  password: string
  firstName: string
  lastName: string
  username?: string
  role?: 'STUDENT' | 'TEACHER'
}

export interface AuthTokens {
  accessToken: string
  refreshToken: string
}

export interface AuthResponse {
  success: boolean
  data?: {
    user: User
    tokens: AuthTokens
  }
  error?: string
}

export interface AuthContextType {
  user: User | null
  tokens: AuthTokens | null
  isLoading: boolean
  login: (credentials: LoginCredentials) => Promise<void>
  register: (data: RegisterData) => Promise<void>
  logout: () => void
  refreshToken: () => Promise<void>
}
</file>

<file path="frontend/src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="frontend/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  html {
    font-family: 'Inter', system-ui, sans-serif;
  }
  
  body {
    margin: 0;
    min-height: 100vh;
    background-color: #f8fafc;
  }
}

@layer components {
  .btn-primary {
    @apply bg-primary-600 hover:bg-primary-700 text-white font-medium py-2 px-4 rounded-md transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed;
  }
  
  .btn-secondary {
    @apply bg-gray-200 hover:bg-gray-300 text-gray-900 font-medium py-2 px-4 rounded-md transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed;
  }
  
  .btn-danger {
    @apply bg-red-600 hover:bg-red-700 text-white font-medium py-2 px-4 rounded-md transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed;
  }
  
  .input-field {
    @apply border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent disabled:bg-gray-100 disabled:cursor-not-allowed;
  }
  
  .card {
    @apply bg-white rounded-lg shadow-md border border-gray-200 p-6;
  }
  
  .video-container {
    @apply relative bg-black rounded-lg overflow-hidden aspect-video;
  }
  
  .question-overlay {
    @apply absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-10;
  }
  
  .progress-bar {
    @apply w-full bg-gray-200 rounded-full h-2;
  }
  
  .progress-fill {
    @apply bg-primary-600 h-2 rounded-full transition-all duration-300;
  }
  
  .navbar {
    @apply bg-white shadow-sm border-b border-gray-200 px-4 py-3;
  }
  
  .sidebar {
    @apply bg-white shadow-lg border-r border-gray-200 h-full;
  }
}
</file>

<file path="frontend/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="frontend/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { globalIgnores } from 'eslint/config'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="frontend/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="frontend/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      ...tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      ...tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      ...tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#eff6ff',
          100: '#dbeafe',
          200: '#bfdbfe',
          300: '#93c5fd',
          400: '#60a5fa',
          500: '#3b82f6',
          600: '#2563eb',
          700: '#1d4ed8',
          800: '#1e40af',
          900: '#1e3a8a',
        },
        secondary: {
          50: '#f0fdf4',
          100: '#dcfce7',
          200: '#bbf7d0',
          300: '#86efac',
          400: '#4ade80',
          500: '#22c55e',
          600: '#16a34a',
          700: '#15803d',
          800: '#166534',
          900: '#14532d',
        },
      },
    },
  },
  plugins: [],
}
</file>

<file path="frontend/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="frontend/vitest.config.ts">
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    css: true,
    include: ['src/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
    exclude: ['node_modules', 'dist', '.idea', '.git', '.cache'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['src/**/*.{ts,tsx}'],
      exclude: [
        'src/**/*.{test,spec}.{ts,tsx}',
        'src/test/**/*',
        'src/**/*.d.ts',
        'src/main.tsx',
        'src/vite-env.d.ts'
      ],
      thresholds: {
        global: {
          branches: 70,
          functions: 75,
          lines: 80,
          statements: 80
        }
      }
    },
    testTimeout: 10000,
    hookTimeout: 10000
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@components': path.resolve(__dirname, './src/components'),
      '@pages': path.resolve(__dirname, './src/pages'),
      '@hooks': path.resolve(__dirname, './src/hooks'),
      '@utils': path.resolve(__dirname, './src/utils'),
      '@types': path.resolve(__dirname, './src/types'),
      '@stores': path.resolve(__dirname, './src/stores'),
      '@api': path.resolve(__dirname, './src/api')
    }
  }
});
</file>

<file path="scripts/database/check-user.js">
const { PrismaClient } = require('@prisma/client');
const bcrypt = require('bcrypt');

const prisma = new PrismaClient();

async function main() {
  try {
    // Find the student user
    const student = await prisma.user.findUnique({
      where: { email: 'student@example.com' }
    });

    if (!student) {
      console.log('❌ Student user not found');
      
      // Create the student user
      console.log('Creating student user...');
      const passwordHash = await bcrypt.hash('Demo123!', 10);
      
      const newStudent = await prisma.user.create({
        data: {
          email: 'student@example.com',
          passwordHash,
          firstName: 'Demo',
          lastName: 'Student',
          role: 'STUDENT',
          status: 'ACTIVE'
        }
      });
      
      console.log('✅ Student user created:', newStudent.email);
    } else {
      console.log('✅ Student user exists:', student.email);
      console.log('User details:', {
        id: student.id,
        email: student.email,
        role: student.role,
        tenantId: student.tenantId,
        status: student.status
      });
      
      // Test the password
      const passwordMatch = await bcrypt.compare('Demo123!', student.passwordHash);
      console.log('Password "Demo123!" is', passwordMatch ? 'correct ✅' : 'incorrect ❌');
      
      if (!passwordMatch) {
        // Update the password
        console.log('Updating password...');
        const newHash = await bcrypt.hash('Demo123!', 10);
        await prisma.user.update({
          where: { id: student.id },
          data: { passwordHash: newHash }
        });
        console.log('✅ Password updated to "Demo123!"');
      }
    }
    
    // List all users
    console.log('\nAll users in database:');
    const users = await prisma.user.findMany({
      select: { email: true, role: true, status: true }
    });
    users.forEach(u => console.log(`  - ${u.email} (${u.role}, ${u.status})`));
    
  } catch (error) {
    console.error('Error:', error);
  } finally {
    await prisma.$disconnect();
  }
}

main();
</file>

<file path="scripts/database/seed-video.js">
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

async function seedVideoData() {
  try {
    console.log('🎬 Seeding video data...');
    
    // Find or create a teacher user
    let teacher = await prisma.user.findFirst({
      where: { role: 'TEACHER' }
    });
    
    if (!teacher) {
      console.log('Creating teacher user...');
      const bcrypt = require('bcrypt');
      teacher = await prisma.user.create({
        data: {
          email: 'teacher@example.com',
          passwordHash: await bcrypt.hash('Demo123!', 10),
          firstName: 'Demo',
          lastName: 'Teacher',
          role: 'TEACHER',
          status: 'ACTIVE'
        }
      });
    }
    
    // Create a lesson
    const lesson = await prisma.lesson.upsert({
      where: { 
        id: 'demo-lesson-1' 
      },
      update: {},
      create: {
        id: 'demo-lesson-1',
        title: 'Introduction to JavaScript',
        description: 'Learn the fundamentals of JavaScript programming',
        createdById: teacher.id,
        order: 1,
        status: 'PUBLISHED'
      }
    });
    
    console.log('✓ Created lesson:', lesson.title);
    
    // Create a video group
    const videoGroup = await prisma.videoGroup.upsert({
      where: { 
        id: 'demo-group-1' 
      },
      update: {},
      create: {
        id: 'demo-group-1',
        title: 'JavaScript Basics',
        description: 'Core concepts of JavaScript',
        lessonId: lesson.id,
        order: 1
      }
    });
    
    console.log('✓ Created video group:', videoGroup.title);
    
    // Create a video
    const video = await prisma.video.upsert({
      where: { 
        id: 'demo-video-1' 
      },
      update: {},
      create: {
        id: 'demo-video-1',
        title: 'Variables and Data Types',
        description: 'Understanding JavaScript variables and data types',
        videoGroupId: videoGroup.id,
        duration: 600, // 10 minutes
        order: 1,
        status: 'READY',
        // Using a sample video path - replace with actual video
        filePath: 'videos/demo-video-1.mp4',
        fileName: 'demo-video-1.mp4',
        mimeType: 'video/mp4',
        size: BigInt(10485760), // 10MB
      }
    });
    
    console.log('✓ Created video:', video.title);
    
    // Create milestones with questions
    const milestones = [
      {
        id: 'milestone-1',
        videoId: video.id,
        timestamp: 30, // 30 seconds
        type: 'PAUSE',
        title: 'Introduction Complete',
        description: 'You\'ve completed the introduction section',
        order: 1
      },
      {
        id: 'milestone-2',
        videoId: video.id,
        timestamp: 120, // 2 minutes
        type: 'QUIZ',
        title: 'Quick Check: Variables',
        description: 'Test your understanding of variables',
        order: 2,
        questions: [
          {
            type: 'MULTIPLE_CHOICE',
            text: 'Which keyword is used to declare a constant in JavaScript?',
            questionData: {
              options: ['var', 'let', 'const', 'constant'],
              correctAnswer: 'const'
            },
            explanation: 'The const keyword is used to declare constants that cannot be reassigned.'
          },
          {
            type: 'TRUE_FALSE',
            text: 'JavaScript is a statically typed language.',
            questionData: {
              correctAnswer: false
            },
            explanation: 'JavaScript is dynamically typed, meaning variable types are determined at runtime.'
          }
        ]
      },
      {
        id: 'milestone-3',
        videoId: video.id,
        timestamp: 300, // 5 minutes
        type: 'CHECKPOINT',
        title: 'Midpoint Checkpoint',
        description: 'You\'re halfway through the lesson!',
        order: 3
      },
      {
        id: 'milestone-4',
        videoId: video.id,
        timestamp: 480, // 8 minutes
        type: 'QUIZ',
        title: 'Data Types Quiz',
        description: 'Check your understanding of JavaScript data types',
        order: 4,
        questions: [
          {
            type: 'MULTIPLE_CHOICE',
            text: 'Which of the following is NOT a primitive data type in JavaScript?',
            questionData: {
              options: ['string', 'number', 'array', 'boolean'],
              correctAnswer: 'array'
            },
            explanation: 'Arrays are objects in JavaScript, not primitive data types.'
          },
          {
            type: 'SHORT_ANSWER',
            text: 'What is the result of typeof null in JavaScript?',
            questionData: {
              correctAnswers: ['object', '"object"']
            },
            explanation: 'This is a well-known quirk in JavaScript - typeof null returns "object".'
          }
        ]
      }
    ];
    
    for (const milestoneData of milestones) {
      const { questions, ...milestone } = milestoneData;
      
      // Create or update milestone with nested questions
      const createdMilestone = await prisma.milestone.upsert({
        where: { id: milestone.id },
        update: {
          ...milestone,
          questions: questions ? {
            deleteMany: {}, // Clear existing questions
            create: questions.map((q, i) => ({
              type: q.type,
              text: q.text,
              questionData: q.questionData,
              explanation: q.explanation,
              order: i + 1,
              status: 'PUBLISHED',
              createdBy: teacher.id
            }))
          } : undefined
        },
        create: {
          ...milestone,
          questions: questions ? {
            create: questions.map((q, i) => ({
              type: q.type,
              text: q.text,
              questionData: q.questionData,
              explanation: q.explanation,
              order: i + 1,
              status: 'PUBLISHED',
              createdBy: teacher.id
            }))
          } : undefined
        },
        include: {
          questions: true
        }
      });
      
      console.log(`✓ Created milestone: ${createdMilestone.title} at ${createdMilestone.timestamp}s`);
      
      if (createdMilestone.questions && createdMilestone.questions.length > 0) {
        for (const question of createdMilestone.questions) {
          console.log(`  ✓ Added question: ${question.text.substring(0, 50)}...`);
        }
      }
    }
    
    // Create a second video for testing
    const video2 = await prisma.video.upsert({
      where: { 
        id: 'demo-video-2' 
      },
      update: {},
      create: {
        id: 'demo-video-2',
        title: 'Functions and Scope',
        description: 'Learn about JavaScript functions and scope',
        videoGroupId: videoGroup.id,
        duration: 720, // 12 minutes
        order: 2,
        status: 'READY',
        filePath: 'videos/demo-video-2.mp4',
        fileName: 'demo-video-2.mp4',
        mimeType: 'video/mp4',
        size: BigInt(12582912), // 12MB
      }
    });
    
    console.log('✓ Created second video:', video2.title);
    
    // Add a milestone to the second video
    await prisma.milestone.upsert({
      where: { id: 'milestone-5' },
      update: {},
      create: {
        id: 'milestone-5',
        videoId: video2.id,
        timestamp: 60,
        type: 'QUIZ',
        title: 'Function Basics',
        description: 'Test your understanding of functions',
        order: 1
      }
    });
    
    // Add a question to this milestone
    await prisma.question.upsert({
      where: { id: 'question-5' },
      update: {},
      create: {
        id: 'question-5',
        milestoneId: 'milestone-5',
        type: 'MULTIPLE_CHOICE',
        text: 'What keyword is used to define a function in JavaScript?',
        questionData: {
          options: ['func', 'function', 'def', 'fn'],
          correctAnswer: 'function'
        },
        explanation: 'The function keyword is used to define functions in JavaScript.',
        order: 1,
        status: 'PUBLISHED',
        createdBy: teacher.id
      }
    });
    
    console.log('✅ Video data seeded successfully!');
    console.log('\nYou can now test with:');
    console.log('  - Lesson: Introduction to JavaScript');
    console.log('  - Video 1: Variables and Data Types (with 4 milestones)');
    console.log('  - Video 2: Functions and Scope (with 1 milestone)');
    console.log('\nMilestone timestamps:');
    console.log('  - 0:30 - Info milestone');
    console.log('  - 2:00 - Quiz (2 questions)');
    console.log('  - 5:00 - Checkpoint');
    console.log('  - 8:00 - Quiz (2 questions)');
    
  } catch (error) {
    console.error('❌ Error seeding video data:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

seedVideoData()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
</file>

<file path="scripts/database/simple-seed.js">
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

async function simpleSeed() {
  try {
    console.log('🎬 Creating simple test data...');
    
    // Get teacher user
    const teacher = await prisma.user.findFirst({
      where: { role: 'TEACHER' }
    });
    
    if (!teacher) {
      console.error('No teacher user found. Run the user seed first.');
      return;
    }
    
    // Create lesson
    const lesson = await prisma.lesson.upsert({
      where: { id: 'test-lesson-1' },
      update: {},
      create: {
        id: 'test-lesson-1',
        title: 'Test Lesson',
        description: 'A simple test lesson',
        createdById: teacher.id,
        order: 1,
        status: 'PUBLISHED'
      }
    });
    
    // Create video group
    const videoGroup = await prisma.videoGroup.upsert({
      where: { id: 'test-group-1' },
      update: {},
      create: {
        id: 'test-group-1',
        title: 'Test Video Group',
        description: 'A test video group',
        lessonId: lesson.id,
        order: 1
      }
    });
    
    // Create video
    const video = await prisma.video.upsert({
      where: { id: 'test-video-1' },
      update: {},
      create: {
        id: 'test-video-1',
        title: 'Test Video',
        description: 'A test video with milestones',
        videoGroupId: videoGroup.id,
        duration: 300, // 5 minutes
        order: 1,
        status: 'READY',
        filePath: 'videos/test-video.mp4',
        fileName: 'test-video.mp4',
        mimeType: 'video/mp4'
      }
    });
    
    // Create milestones
    const milestone1 = await prisma.milestone.upsert({
      where: { id: 'test-milestone-1' },
      update: {},
      create: {
        id: 'test-milestone-1',
        videoId: video.id,
        timestamp: 60, // 1 minute
        type: 'PAUSE',
        title: 'First Milestone',
        description: 'This is the first milestone',
        order: 1
      }
    });
    
    const milestone2 = await prisma.milestone.upsert({
      where: { id: 'test-milestone-2' },
      update: {},
      create: {
        id: 'test-milestone-2',
        videoId: video.id,
        timestamp: 120, // 2 minutes
        type: 'QUIZ',
        title: 'Quiz Milestone',
        description: 'Test your knowledge',
        order: 2
      }
    });
    
    // Create questions for the quiz milestone
    await prisma.question.upsert({
      where: { id: 'test-question-1' },
      update: {},
      create: {
        id: 'test-question-1',
        milestoneId: milestone2.id,
        type: 'MULTIPLE_CHOICE',
        text: 'What color is the sky?',
        questionData: {
          options: ['Red', 'Blue', 'Green', 'Yellow'],
          correctAnswer: 'Blue'
        },
        explanation: 'The sky appears blue due to light scattering',
        status: 'PUBLISHED',
        createdBy: teacher.id
      }
    });
    
    await prisma.question.upsert({
      where: { id: 'test-question-2' },
      update: {},
      create: {
        id: 'test-question-2',
        milestoneId: milestone2.id,
        type: 'TRUE_FALSE',
        text: 'The Earth is round.',
        questionData: {
          correctAnswer: true
        },
        explanation: 'The Earth is roughly spherical in shape.',
        status: 'PUBLISHED',
        createdBy: teacher.id
      }
    });
    
    console.log('✅ Simple test data created successfully!');
    console.log('\nCreated:');
    console.log('- Lesson: Test Lesson');
    console.log('- Video: Test Video (5 minutes)');
    console.log('- Milestone 1: First Milestone (1:00)');
    console.log('- Milestone 2: Quiz Milestone (2:00) - with 2 questions');
    console.log('\nVideo ID:', video.id);
    
  } catch (error) {
    console.error('❌ Error:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

simpleSeed()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
</file>

<file path="scripts/dev/dev.sh">
#!/bin/bash

# Development Environment Manager Script
# This script helps manage the local development setup with Docker for databases only

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Functions
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Check if database is ready
check_db_ready() {
    local max_attempts=30
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if npx prisma db execute --stdin --schema=database/prisma/schema.prisma <<< "SELECT 1;" 2>/dev/null; then
            return 0
        fi
        print_status "Waiting for database to be ready... (attempt $attempt/$max_attempts)"
        sleep 1
        attempt=$((attempt + 1))
    done
    
    return 1
}

# Verify seed data and authentication
verify_seed() {
    print_status "Verifying seed data and authentication..."
    
    # Check if backend is running
    if ! curl -s http://localhost:3000/health >/dev/null 2>&1; then
        print_warning "Backend not running, skipping authentication verification"
        return 1
    fi
    
    # Test default users
    local test_users=(
        "admin@example.com:Demo123!"
        "teacher@example.com:Demo123!"
        "student@example.com:Demo123!"
    )
    
    local all_passed=true
    
    for user_pass in "${test_users[@]}"; do
        IFS=':' read -r email password <<< "$user_pass"
        
        # Create temp JSON file for authentication test
        echo "{\"email\":\"$email\",\"password\":\"$password\"}" > /tmp/auth_test.json
        
        # Test authentication
        if curl -s -X POST http://localhost:3000/api/v1/auth/login \
            -H "Content-Type: application/json" \
            -d @/tmp/auth_test.json \
            -o /tmp/auth_response.json 2>/dev/null; then
            
            if grep -q "\"success\":true" /tmp/auth_response.json 2>/dev/null; then
                echo -e "  ${GREEN}✓${NC} $email can authenticate"
            else
                echo -e "  ${RED}✗${NC} $email authentication failed"
                all_passed=false
            fi
        else
            echo -e "  ${RED}✗${NC} $email - API call failed"
            all_passed=false
        fi
    done
    
    # Cleanup
    rm -f /tmp/auth_test.json /tmp/auth_response.json
    
    if [ "$all_passed" = true ]; then
        print_success "All default users can authenticate!"
        return 0
    else
        print_error "Some users failed authentication. Run: $0 db:seed:fix"
        return 1
    fi
}

# Commands
case "$1" in
    start)
        print_status "Starting development environment..."
        
        # Start Docker services (DB, Redis only)
        print_status "Starting Docker services (Database & Redis)..."
        docker-compose -f docker-compose.dev.yml up -d postgres redis adminer redis-insight
        
        # Wait for database to be ready
        print_status "Waiting for database to be ready..."
        if ! check_db_ready; then
            print_error "Database failed to start. Check Docker logs."
            exit 1
        fi
        
        # Check migration status
        print_status "Checking database migration status..."
        MIGRATE_STATUS=$(npx prisma migrate status --schema=database/prisma/schema.prisma 2>&1)
        
        if echo "$MIGRATE_STATUS" | grep -q "Database schema is up to date"; then
            print_success "Database schema is up to date!"
        elif echo "$MIGRATE_STATUS" | grep -q "No migration found in prisma/migrations"; then
            print_warning "No migration history found. Creating baseline migration..."
            npx prisma migrate diff --from-empty --to-schema-datamodel database/prisma/schema.prisma --script > /tmp/baseline.sql 2>/dev/null
            if [ -s /tmp/baseline.sql ]; then
                mkdir -p database/prisma/migrations/0_init
                mv /tmp/baseline.sql database/prisma/migrations/0_init/migration.sql
                npx prisma migrate resolve --applied 0_init --schema=database/prisma/schema.prisma
                print_success "Baseline migration created and marked as applied!"
            else
                print_warning "Database appears to be empty, generating schema..."
                npx prisma db push --schema=database/prisma/schema.prisma
            fi
        else
            print_warning "Database schema is not up to date. Running migrations..."
            npx prisma migrate deploy --schema=database/prisma/schema.prisma
        fi
        
        # Install dependencies if needed
        if [ ! -d "node_modules" ]; then
            print_status "Installing backend dependencies..."
            npm install
        fi
        
        if [ ! -d "frontend/node_modules" ]; then
            print_status "Installing frontend dependencies..."
            cd frontend && npm install && cd ..
        fi
        
        # Generate Prisma client
        print_status "Generating Prisma client..."
        npx prisma generate --schema=database/prisma/schema.prisma
        
        # Seed database if empty
        print_status "Checking if database needs seeding..."
        USER_COUNT=$(npx prisma db execute --stdin --schema=database/prisma/schema.prisma <<< "SELECT COUNT(*) FROM \"User\";" 2>/dev/null | grep -o '[0-9]\+' | head -1)
        
        if [ "$USER_COUNT" -eq "0" ] 2>/dev/null; then
            print_warning "Database is empty. Running seed..."
            npm run db:seed
        else
            print_status "Database already has $USER_COUNT users"
        fi
        
        # Start backend locally
        print_status "Starting backend locally with hot reload..."
        nohup npm run dev > /tmp/backend.log 2>&1 &
        echo $! > /tmp/backend.pid
        
        # Start frontend locally
        print_status "Starting frontend locally with hot reload..."
        cd frontend && nohup npm run dev > /tmp/frontend.log 2>&1 &
        echo $! > /tmp/frontend.pid
        cd ..
        
        # Wait for services to start
        print_status "Waiting for services to start..."
        sleep 5
        
        # Verify authentication
        verify_seed || print_warning "Authentication verification failed - you may need to fix seed data"
        
        print_success "Development environment started!"
        echo ""
        echo "Services available at:"
        echo "  Backend API:    http://localhost:3000"
        echo "  Frontend:       http://localhost:3001"
        echo "  Database UI:    http://localhost:8080"
        echo "  Redis UI:       http://localhost:8001"
        echo ""
        echo "Default credentials:"
        echo "  Admin:    admin@example.com / Demo123!"
        echo "  Teacher:  teacher@example.com / Demo123!"
        echo "  Student:  student@example.com / Demo123!"
        echo ""
        echo "Both backend and frontend are running locally with hot reload enabled!"
        echo ""
        echo "View logs with:"
        echo "  Backend:  tail -f /tmp/backend.log"
        echo "  Frontend: tail -f /tmp/frontend.log"
        ;;
        
    stop)
        print_status "Stopping development environment..."
        
        # Kill local backend process
        print_status "Stopping local backend..."
        if [ -f /tmp/backend.pid ]; then
            kill $(cat /tmp/backend.pid) 2>/dev/null || true
            rm /tmp/backend.pid
        fi
        pkill -f "tsx watch" 2>/dev/null || true
        
        # Kill local frontend process
        print_status "Stopping local frontend..."
        if [ -f /tmp/frontend.pid ]; then
            kill $(cat /tmp/frontend.pid) 2>/dev/null || true
            rm /tmp/frontend.pid
        fi
        pkill -f "vite" 2>/dev/null || true
        
        # Stop Docker containers
        print_status "Stopping Docker services..."
        docker-compose -f docker-compose.dev.yml down
        
        print_success "Development environment stopped!"
        ;;
        
    restart)
        print_status "Restarting development environment..."
        $0 stop
        sleep 2
        $0 start
        ;;
        
    status)
        echo "Development Environment Status:"
        echo "==============================="
        echo ""
        echo "Docker Services:"
        docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "(NAME|interactive-learning)" || echo "No services running"
        echo ""
        echo "Local Backend Process:"
        ps aux | grep "tsx watch" | grep -v grep || echo "Backend not running locally"
        echo ""
        echo "Local Frontend Process:"
        ps aux | grep "vite" | grep -v grep || echo "Frontend not running locally"
        echo ""
        
        # Test health endpoints
        echo "Service Health Checks:"
        echo "----------------------"
        echo -n "Backend:  "
        curl -s http://localhost:3000/health 2>/dev/null | python3 -c "import sys, json; data=json.load(sys.stdin); print(f\"✅ Healthy (v{data['version']})\") if data['status']=='healthy' else print('❌ Not responding')" 2>/dev/null || echo "❌ Not responding"
        
        echo -n "Frontend: "
        curl -s -o /dev/null -w "%{http_code}" http://localhost:3001 2>/dev/null | grep -q "200" && echo "✅ Running" || echo "❌ Not responding"
        
        echo ""
        echo "Authentication Status:"
        echo "---------------------"
        verify_seed
        ;;
        
    logs)
        case "$2" in
            backend)
                if [ -f /tmp/backend.log ]; then
                    tail -f /tmp/backend.log
                else
                    print_error "Backend log file not found. Is the backend running?"
                fi
                ;;
            frontend)
                if [ -f /tmp/frontend.log ]; then
                    tail -f /tmp/frontend.log
                else
                    print_error "Frontend log file not found. Is the frontend running?"
                fi
                ;;
            db)
                docker logs -f interactive-learning-db
                ;;
            redis)
                docker logs -f interactive-learning-redis
                ;;
            *)
                echo "Usage: $0 logs [backend|frontend|db|redis]"
                ;;
        esac
        ;;
        
    db:migrate)
        print_status "Running database migrations..."
        npx prisma migrate dev --schema=database/prisma/schema.prisma
        print_success "Migrations completed!"
        ;;
        
    db:seed)
        print_status "Running database seed..."
        
        # Check if database is ready
        if ! check_db_ready; then
            print_error "Database is not ready. Start the environment first: $0 start"
            exit 1
        fi
        
        # Run seed script
        if [ -f "database/seed.ts" ]; then
            print_status "Running TypeScript seed script..."
            npx tsx database/seed.ts
        elif [ -f "scripts/seed.js" ]; then
            print_status "Running JavaScript seed script..."
            node scripts/seed.js
        else
            print_error "No seed script found!"
            exit 1
        fi
        
        print_success "Database seeded!"
        ;;
        
    db:seed:fix)
        print_status "Fixing seed data and authentication..."
        
        # Check if database is ready
        if ! check_db_ready; then
            print_error "Database is not ready. Start the environment first: $0 start"
            exit 1
        fi
        
        # Run the fix script
        if [ -f "scripts/check-user.js" ]; then
            node scripts/check-user.js
        else
            print_warning "Fix script not found. Creating it..."
            cat > scripts/check-user.js << 'EOF'
const { PrismaClient } = require('@prisma/client');
const bcrypt = require('bcrypt');

const prisma = new PrismaClient();

async function fixUsers() {
  const defaultUsers = [
    { email: 'admin@example.com', firstName: 'Demo', lastName: 'Admin', role: 'ADMIN' },
    { email: 'teacher@example.com', firstName: 'Demo', lastName: 'Teacher', role: 'TEACHER' },
    { email: 'student@example.com', firstName: 'Demo', lastName: 'Student', role: 'STUDENT' }
  ];
  
  const passwordHash = await bcrypt.hash('Demo123!', 10);
  
  for (const userData of defaultUsers) {
    const user = await prisma.user.upsert({
      where: { email: userData.email },
      update: { passwordHash },
      create: {
        ...userData,
        passwordHash,
        status: 'ACTIVE'
      }
    });
    console.log(`✓ Fixed user: ${user.email}`);
  }
}

fixUsers()
  .then(() => {
    console.log('✅ All users fixed!');
    process.exit(0);
  })
  .catch(error => {
    console.error('❌ Error:', error);
    process.exit(1);
  })
  .finally(() => prisma.$disconnect());
EOF
            node scripts/check-user.js
        fi
        
        print_success "Seed data fixed!"
        ;;
        
    db:studio)
        print_status "Opening Prisma Studio..."
        npx prisma studio --schema=database/prisma/schema.prisma
        ;;
        
    db:reset)
        print_warning "This will reset your database and delete all data!"
        read -p "Are you sure? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            print_status "Resetting database..."
            npx prisma migrate reset --force --schema=database/prisma/schema.prisma
            print_success "Database reset completed!"
            
            # Automatically seed after reset
            print_status "Running seed after reset..."
            $0 db:seed
        else
            print_status "Database reset cancelled."
        fi
        ;;
        
    test:auth)
        print_status "Testing authentication for all default users..."
        
        # Check if backend is running
        if ! curl -s http://localhost:3000/health >/dev/null 2>&1; then
            print_error "Backend is not running. Start it first: $0 start"
            exit 1
        fi
        
        verify_seed
        if [ $? -eq 0 ]; then
            print_success "All authentication tests passed!"
        else
            print_error "Some authentication tests failed!"
            print_status "Try running: $0 db:seed:fix"
            exit 1
        fi
        ;;
        
    install)
        print_status "Installing all dependencies..."
        
        # Backend dependencies
        print_status "Installing backend dependencies..."
        npm install
        
        # Frontend dependencies
        print_status "Installing frontend dependencies..."
        cd frontend && npm install && cd ..
        
        print_success "All dependencies installed!"
        ;;
        
    clean)
        print_warning "This will remove all Docker volumes and clean up development files!"
        read -p "Are you sure? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            $0 stop
            print_status "Removing Docker volumes..."
            docker-compose -f docker-compose.dev.yml down -v
            print_status "Cleaning up log files..."
            rm -f /tmp/backend.log /tmp/frontend.log /tmp/backend.pid /tmp/frontend.pid
            print_success "Cleanup completed!"
        else
            print_status "Cleanup cancelled."
        fi
        ;;
        
    *)
        echo "Usage: $0 {start|stop|restart|status|logs|db:migrate|db:seed|db:seed:fix|db:studio|db:reset|test:auth|install|clean}"
        echo ""
        echo "Commands:"
        echo "  start         - Start all services (Docker databases + local apps)"
        echo "  stop          - Stop all services"
        echo "  restart       - Restart all services"
        echo "  status        - Show status of all services"
        echo "  logs          - Show logs (backend|frontend|db|redis)"
        echo "  db:migrate    - Run database migrations"
        echo "  db:seed       - Seed database with default data"
        echo "  db:seed:fix   - Fix authentication for default users"
        echo "  db:studio     - Open Prisma Studio"
        echo "  db:reset      - Reset database (WARNING: deletes all data)"
        echo "  test:auth     - Test authentication for all default users"
        echo "  install       - Install all dependencies"
        echo "  clean         - Clean up Docker volumes and temp files"
        echo ""
        echo "Default Credentials:"
        echo "  Admin:    admin@example.com / Demo123!"
        echo "  Teacher:  teacher@example.com / Demo123!"
        echo "  Student:  student@example.com / Demo123!"
        exit 1
        ;;
esac
</file>

<file path="scripts/frontend/debug-frontend.sh">
#!/bin/bash

# Frontend debugging script for Claude Code
# This script helps capture screenshots and debug frontend issues

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}Frontend Debugging Tool${NC}"
echo "========================"

# Check if frontend is running
check_frontend() {
    if curl -s http://localhost:5173 > /dev/null; then
        echo -e "${GREEN}✓ Frontend is running on port 5173${NC}"
        return 0
    else
        echo -e "${RED}✗ Frontend is not running${NC}"
        echo "Please run: cd frontend && npm run dev"
        return 1
    fi
}

# Capture screenshot function
capture() {
    local url="${1:-http://localhost:5173}"
    local name="${2:-screenshot}"
    
    echo -e "${YELLOW}Capturing screenshot of $url...${NC}"
    npx tsx scripts/frontend/screenshot.ts capture "$url"
    
    # Find the latest screenshot
    latest=$(ls -t screenshots/*.png 2>/dev/null | head -1)
    if [ -n "$latest" ]; then
        echo -e "${GREEN}Screenshot saved: $latest${NC}"
        echo "You can now read this file with the Read tool to see the visual state"
    fi
}

# Debug specific page
debug_page() {
    local path="${1:-/}"
    local url="http://localhost:5173${path}"
    
    echo -e "${YELLOW}Debugging page: $url${NC}"
    npx tsx scripts/frontend/screenshot.ts debug "$url"
}

# Capture element
capture_element() {
    local selector="$1"
    local url="${2:-http://localhost:5173}"
    
    if [ -z "$selector" ]; then
        echo -e "${RED}Error: Please provide a CSS selector${NC}"
        echo "Usage: ./debug-frontend.sh element 'selector' [url]"
        return 1
    fi
    
    echo -e "${YELLOW}Capturing element: $selector${NC}"
    npx tsx scripts/frontend/screenshot.ts element "$selector" "$url"
}

# Capture multiple viewports
capture_responsive() {
    echo -e "${YELLOW}Capturing responsive views...${NC}"
    npx tsx scripts/frontend/screenshot.ts multi
}

# Interactive debug session
interactive_debug() {
    local url="${1:-http://localhost:5173}"
    
    echo -e "${YELLOW}Starting interactive debug session...${NC}"
    echo "This will:"
    echo "  1. Navigate to $url"
    echo "  2. Capture page metrics"
    echo "  3. Look for error elements"
    echo "  4. Monitor network failures"
    echo "  5. Save a debug screenshot"
    
    npx tsx scripts/frontend/screenshot.ts debug "$url"
}

# Main menu
show_menu() {
    echo ""
    echo "Commands:"
    echo "  capture [url]           - Capture a screenshot"
    echo "  element <selector> [url] - Capture specific element"
    echo "  debug [path]            - Debug a specific page"
    echo "  responsive              - Capture all viewports"
    echo "  interactive [url]       - Start interactive debug"
    echo "  check                   - Check if frontend is running"
    echo ""
}

# Main execution
if ! check_frontend; then
    exit 1
fi

case "${1:-capture}" in
    capture)
        capture "$2" "$3"
        ;;
    element)
        capture_element "$2" "$3"
        ;;
    debug)
        debug_page "$2"
        ;;
    responsive)
        capture_responsive
        ;;
    interactive)
        interactive_debug "$2"
        ;;
    check)
        # Already checked above
        ;;
    help|--help|-h)
        show_menu
        ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}"
        show_menu
        exit 1
        ;;
esac
</file>

<file path="scripts/frontend/screenshot.ts">
import puppeteer, { Browser, Page } from 'puppeteer';
import * as fs from 'fs';
import * as path from 'path';

interface ScreenshotOptions {
  url?: string;
  fullPage?: boolean;
  selector?: string;
  viewport?: { width: number; height: number };
  outputPath?: string;
  waitForSelector?: string;
  waitTime?: number;
}

class ScreenshotDebugger {
  private browser: Browser | null = null;
  private page: Page | null = null;
  private screenshotDir: string;

  constructor() {
    // Create screenshots directory if it doesn't exist
    this.screenshotDir = path.join(process.cwd(), 'screenshots');
    if (!fs.existsSync(this.screenshotDir)) {
      fs.mkdirSync(this.screenshotDir, { recursive: true });
    }
  }

  async initialize(): Promise<void> {
    this.browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    this.page = await this.browser.newPage();
    
    // Set default viewport
    await this.page.setViewport({ width: 1920, height: 1080 });
    
    // Enable console logging from the page
    this.page.on('console', msg => console.log('PAGE LOG:', msg.text()));
    this.page.on('pageerror', error => console.log('PAGE ERROR:', error.message));
  }

  async captureScreenshot(options: ScreenshotOptions): Promise<string> {
    if (!this.page) {
      await this.initialize();
    }

    const {
      url = 'http://localhost:5173',
      fullPage = true,
      selector,
      viewport,
      outputPath,
      waitForSelector,
      waitTime = 0
    } = options;

    // Navigate to URL if provided
    if (url) {
      await this.page!.goto(url, { waitUntil: 'networkidle2' });
    }

    // Set custom viewport if provided
    if (viewport) {
      await this.page!.setViewport(viewport);
    }

    // Wait for specific selector if provided
    if (waitForSelector) {
      await this.page!.waitForSelector(waitForSelector, { timeout: 10000 });
    }

    // Additional wait time if needed
    if (waitTime > 0) {
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }

    // Generate filename
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = outputPath || `screenshot-${timestamp}.png`;
    const filepath = path.join(this.screenshotDir, filename);

    // Capture screenshot
    if (selector) {
      const element = await this.page!.$(selector);
      if (element) {
        await element.screenshot({ path: filepath as any });
        console.log(`Element screenshot saved: ${filepath}`);
      } else {
        throw new Error(`Selector "${selector}" not found`);
      }
    } else {
      await this.page!.screenshot({ path: filepath as any, fullPage });
      console.log(`Page screenshot saved: ${filepath}`);
    }

    return filepath;
  }

  async captureMultipleViews(baseUrl: string = 'http://localhost:5173'): Promise<void> {
    const views = [
      { name: 'home', path: '/' },
      { name: 'login', path: '/login' },
      { name: 'register', path: '/register' },
      { name: 'student-dashboard', path: '/student' },
      { name: 'teacher-dashboard', path: '/teacher' },
      { name: 'admin-dashboard', path: '/admin' },
      { name: 'lessons', path: '/lessons' },
    ];

    const viewports = [
      { name: 'desktop', width: 1920, height: 1080 },
      { name: 'tablet', width: 768, height: 1024 },
      { name: 'mobile', width: 375, height: 667 },
    ];

    for (const view of views) {
      for (const viewport of viewports) {
        try {
          await this.captureScreenshot({
            url: `${baseUrl}${view.path}`,
            viewport,
            outputPath: `${view.name}-${viewport.name}.png`,
            waitTime: 1000
          });
        } catch (error) {
          console.error(`Failed to capture ${view.name} on ${viewport.name}:`, error);
        }
      }
    }
  }

  async debugInteractive(url: string = 'http://localhost:5173'): Promise<void> {
    if (!this.page) {
      await this.initialize();
    }

    await this.page!.goto(url, { waitUntil: 'networkidle2' });

    // Get page metrics
    const metrics = await this.page!.metrics();
    console.log('Page metrics:', metrics);

    // Get page title
    const title = await this.page!.title();
    console.log('Page title:', title);

    // Check for common error indicators
    const errors = await this.page!.evaluate(() => {
      const errorElements = document.querySelectorAll('.error, .alert-danger, [class*="error"]');
      return Array.from(errorElements).map(el => ({
        class: el.className,
        text: el.textContent?.trim()
      }));
    });

    if (errors.length > 0) {
      console.log('Found error elements:', errors);
    }

    // Get network errors
    const failedRequests: string[] = [];
    this.page!.on('requestfailed', request => {
      failedRequests.push(`${request.url()} - ${request.failure()?.errorText}`);
    });

    // Capture current state
    await this.captureScreenshot({
      outputPath: 'debug-current-state.png'
    });
  }

  async captureElement(selector: string, url?: string): Promise<string> {
    return this.captureScreenshot({
      url,
      selector,
      fullPage: false,
      outputPath: `element-${selector.replace(/[^a-z0-9]/gi, '-')}.png`
    });
  }

  async fillFormAndCapture(
    url: string,
    formData: Record<string, string>,
    submitSelector: string = 'button[type="submit"]'
  ): Promise<void> {
    if (!this.page) {
      await this.initialize();
    }

    await this.page!.goto(url, { waitUntil: 'networkidle2' });

    // Fill form fields
    for (const [selector, value] of Object.entries(formData)) {
      await this.page!.type(selector, value);
    }

    // Capture before submit
    await this.captureScreenshot({
      outputPath: 'form-filled.png'
    });

    // Submit form
    await this.page!.click(submitSelector);
    await this.page!.waitForNavigation({ waitUntil: 'networkidle2' });

    // Capture after submit
    await this.captureScreenshot({
      outputPath: 'form-submitted.png'
    });
  }

  async cleanup(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
      this.page = null;
    }
  }
}

// CLI usage
async function main() {
  const screenshotDebugger = new ScreenshotDebugger();
  
  try {
    const args = process.argv.slice(2);
    const command = args[0] || 'capture';

    switch (command) {
      case 'capture':
        const url = args[1] || 'http://localhost:5173';
        const filepath = await screenshotDebugger.captureScreenshot({ url });
        console.log(`Screenshot captured: ${filepath}`);
        break;

      case 'element':
        const selector = args[1];
        const pageUrl = args[2] || 'http://localhost:5173';
        if (!selector) {
          console.error('Please provide a selector');
          process.exit(1);
        }
        await screenshotDebugger.captureElement(selector, pageUrl);
        break;

      case 'multi':
        await screenshotDebugger.captureMultipleViews();
        break;

      case 'debug':
        const debugUrl = args[1] || 'http://localhost:5173';
        await screenshotDebugger.debugInteractive(debugUrl);
        break;

      case 'form':
        // Example: npm run screenshot form http://localhost:5173/login
        const formUrl = args[1] || 'http://localhost:5173/login';
        await screenshotDebugger.fillFormAndCapture(formUrl, {
          'input[name="email"]': 'test@example.com',
          'input[name="password"]': 'password123'
        });
        break;

      default:
        console.log(`
Usage:
  npm run screenshot [command] [options]

Commands:
  capture [url]           - Capture a full page screenshot
  element <selector> [url] - Capture a specific element
  multi                   - Capture multiple views and viewports
  debug [url]            - Run interactive debugging
  form [url]             - Fill and submit a form
        `);
    }
  } catch (error) {
    console.error('Error:', error);
  } finally {
    await screenshotDebugger.cleanup();
  }
}

// Export for use in other scripts
export { ScreenshotDebugger, ScreenshotOptions };

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}
</file>

<file path="scripts/testing/check-access.ts">
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function checkAccess() {
  try {
    const videoId = 'cme33hmyb000bxgonc1t7lrrh'
    const userEmail = 'student@example.com' // or whichever user you're testing with
    
    // Get user
    const user = await prisma.user.findUnique({
      where: { email: userEmail }
    })
    
    if (!user) {
      console.log('User not found')
      return
    }
    
    console.log('User:', { id: user.id, email: user.email, role: user.role })
    
    // Check video and its lesson
    const video = await prisma.video.findUnique({
      where: { id: videoId },
      include: {
        videoGroup: {
          include: {
            lesson: {
              include: {
                studentProgress: {
                  where: { studentId: user.id }
                }
              }
            }
          }
        }
      }
    })
    
    if (!video) {
      console.log('Video not found')
      return
    }
    
    console.log('Video:', { 
      id: video.id, 
      title: video.title,
      duration: video.duration 
    })
    console.log('Lesson:', {
      id: video.videoGroup.lesson.id,
      title: video.videoGroup.lesson.title,
      createdById: video.videoGroup.lesson.createdById
    })
    
    // Check access
    const isCreator = video.videoGroup.lesson.createdById === user.id
    const isEnrolled = video.videoGroup.lesson.studentProgress.length > 0
    
    console.log('Access check:')
    console.log('- Is creator:', isCreator)
    console.log('- Is enrolled:', isEnrolled)
    console.log('- Has access:', isCreator || isEnrolled)
    
    // Check existing session
    const session = await prisma.studentSession.findFirst({
      where: {
        videoId: videoId,
        studentId: user.id
      }
    })
    
    if (session) {
      console.log('Existing session:', {
        id: session.id,
        status: session.status,
        currentPosition: session.currentPosition
      })
    } else {
      console.log('No existing session')
    }
    
  } catch (error) {
    console.error('Error:', error)
  } finally {
    await prisma.$disconnect()
  }
}

checkAccess()
</file>

<file path="scripts/testing/enroll-student.ts">
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function enrollStudent() {
  try {
    const videoId = 'cme33hmyb000bxgonc1t7lrrh'
    const studentEmail = 'student@example.com'
    
    // Get student user
    const student = await prisma.user.findUnique({
      where: { email: studentEmail }
    })
    
    if (!student) {
      console.log('Student not found')
      return
    }
    
    // Get video and its lesson
    const video = await prisma.video.findUnique({
      where: { id: videoId },
      include: {
        videoGroup: {
          include: {
            lesson: true
          }
        }
      }
    })
    
    if (!video) {
      console.log('Video not found')
      return
    }
    
    const lessonId = video.videoGroup.lesson.id
    
    // Check if already enrolled
    const existingProgress = await prisma.studentProgress.findFirst({
      where: {
        studentId: student.id,
        lessonId: lessonId
      }
    })
    
    if (existingProgress) {
      console.log('Student already enrolled in lesson')
      return
    }
    
    // Create enrollment
    const progress = await prisma.studentProgress.create({
      data: {
        studentId: student.id,
        lessonId: lessonId,
        isCompleted: false,
        completionPercent: 0,
        totalTimeSpent: 0,
        totalMilestones: 0,
        completedMilestones: 0,
        averageScore: 0,
        totalAttempts: 0,
        successfulAttempts: 0
      }
    })
    
    console.log('✅ Student enrolled successfully!')
    console.log('Progress record:', {
      id: progress.id,
      studentId: progress.studentId,
      lessonId: progress.lessonId
    })
    
  } catch (error) {
    console.error('Error:', error)
  } finally {
    await prisma.$disconnect()
  }
}

enrollStudent()
</file>

<file path="scripts/testing/run-tests.sh">
#!/bin/bash

# Interactive Learning Platform - Test Runner
# Comprehensive test execution script for Phase 1 foundation tests

set -e  # Exit on any error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Functions
print_header() {
    echo -e "${BLUE}=================================${NC}"
    echo -e "${BLUE}$1${NC}"
    echo -e "${BLUE}=================================${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

# Check if required services are running
check_services() {
    print_header "Checking Required Services"
    
    # Check if PostgreSQL is accessible
    if ! pg_isready -h localhost -p 5432 >/dev/null 2>&1; then
        print_error "PostgreSQL is not accessible. Please ensure it's running."
        echo "You can start it with: docker-compose up -d postgres"
        exit 1
    else
        print_success "PostgreSQL is accessible"
    fi
    
    # Check if test database exists
    if ! psql -h localhost -p 5432 -U postgres -lqt | cut -d \| -f 1 | grep -qw learning_platform_test; then
        print_warning "Test database doesn't exist. Creating it..."
        createdb -h localhost -p 5432 -U postgres learning_platform_test || {
            print_error "Failed to create test database"
            exit 1
        }
        print_success "Test database created"
    else
        print_success "Test database exists"
    fi
}

# Run backend tests
run_backend_tests() {
    print_header "Running Backend Tests"
    
    # Set test environment
    export NODE_ENV=test
    export DATABASE_URL="postgresql://postgres:postgres@localhost:5432/learning_platform_test"
    
    # Run database migrations for test database
    print_warning "Running test database migrations..."
    npx prisma migrate deploy --schema=database/prisma/schema.prisma || {
        print_error "Failed to run test database migrations"
        exit 1
    }
    
    # Run Jest tests
    print_warning "Running Jest tests..."
    npm test -- --verbose --coverage || {
        print_error "Backend tests failed"
        exit 1
    }
    
    print_success "Backend tests completed successfully"
}

# Run frontend tests
run_frontend_tests() {
    print_header "Running Frontend Tests"
    
    cd frontend
    
    # Run Vitest tests
    print_warning "Running Vitest tests..."
    npm run test:run || {
        print_error "Frontend tests failed"
        cd ..
        exit 1
    }
    
    cd ..
    print_success "Frontend tests completed successfully"
}

# Run integration tests
run_integration_tests() {
    print_header "Running Integration Tests"
    
    # Start services if not running
    print_warning "Ensuring services are running for integration tests..."
    docker-compose -f docker-compose.dev.yml up -d postgres redis
    
    # Wait for services to be ready
    sleep 5
    
    # Run API integration tests
    if [ -f "scripts/test-api.sh" ]; then
        print_warning "Running API integration tests..."
        bash scripts/test-api.sh || {
            print_error "Integration tests failed"
            exit 1
        }
        print_success "Integration tests completed successfully"
    else
        print_warning "API integration tests script not found, skipping..."
    fi
}

# Generate coverage reports
generate_coverage() {
    print_header "Generating Coverage Reports"
    
    # Backend coverage
    if [ -d "coverage" ]; then
        print_success "Backend coverage report generated in ./coverage/lcov-report/index.html"
    fi
    
    # Frontend coverage
    if [ -d "frontend/coverage" ]; then
        print_success "Frontend coverage report generated in ./frontend/coverage/index.html"
    fi
    
    # Combined coverage summary
    echo ""
    echo -e "${BLUE}Coverage Summary:${NC}"
    echo "Backend: Check ./coverage/lcov-report/index.html"
    echo "Frontend: Check ./frontend/coverage/index.html"
}

# Main execution
main() {
    print_header "Interactive Learning Platform - Test Suite"
    echo "Running Phase 1: Foundation Tests"
    echo ""
    
    # Parse command line arguments
    SKIP_SERVICES=false
    RUN_BACKEND=true
    RUN_FRONTEND=true
    RUN_INTEGRATION=true
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --skip-services)
                SKIP_SERVICES=true
                shift
                ;;
            --backend-only)
                RUN_FRONTEND=false
                RUN_INTEGRATION=false
                shift
                ;;
            --frontend-only)
                RUN_BACKEND=false
                RUN_INTEGRATION=false
                shift
                ;;
            --integration-only)
                RUN_BACKEND=false
                RUN_FRONTEND=false
                shift
                ;;
            --help)
                echo "Usage: $0 [OPTIONS]"
                echo ""
                echo "Options:"
                echo "  --skip-services     Skip service checks"
                echo "  --backend-only      Run only backend tests"
                echo "  --frontend-only     Run only frontend tests"
                echo "  --integration-only  Run only integration tests"
                echo "  --help              Show this help message"
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    # Check services unless skipped
    if [ "$SKIP_SERVICES" = false ]; then
        check_services
    fi
    
    # Run tests based on options
    if [ "$RUN_BACKEND" = true ]; then
        run_backend_tests
    fi
    
    if [ "$RUN_FRONTEND" = true ]; then
        run_frontend_tests
    fi
    
    if [ "$RUN_INTEGRATION" = true ]; then
        run_integration_tests
    fi
    
    # Generate coverage reports
    generate_coverage
    
    print_header "Test Execution Complete"
    print_success "All tests passed successfully!"
    echo ""
    echo "Phase 1: Foundation tests are complete."
    echo "Next steps:"
    echo "  1. Review coverage reports"
    echo "  2. Address any gaps in test coverage"
    echo "  3. Proceed to Phase 2: Core Coverage"
}

# Execute main function with all arguments
main "$@"
</file>

<file path="scripts/testing/test-api.sh">
#!/bin/bash
# API Testing Script for Local Development

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

API_BASE="http://localhost:3000"
JWT_TOKEN=""

echo -e "${BLUE}🧪 Interactive Learning Platform API Testing${NC}"
echo "==========================================="

# Test 1: Health Check
echo -e "\n${YELLOW}1. Testing Health Check...${NC}"
if curl -s -f "${API_BASE}/health" > /dev/null; then
    echo -e "${GREEN}✅ Health check passed${NC}"
    curl -s "${API_BASE}/health" | jq . 2>/dev/null || curl -s "${API_BASE}/health"
else
    echo -e "${RED}❌ Health check failed - API might not be running${NC}"
    echo "Please run: npm run dev:up"
    exit 1
fi

# Test 2: User Registration
echo -e "\n${YELLOW}2. Testing User Registration...${NC}"
REGISTER_RESPONSE=$(curl -s -X POST "${API_BASE}/api/v1/auth/register" \
    -H "Content-Type: application/json" \
    -d '{
        "email": "testteacher@example.com",
        "password": "Password123!",
        "firstName": "Test",
        "lastName": "Teacher",
        "role": "TEACHER"
    }')

if echo "$REGISTER_RESPONSE" | grep -q '"success":true'; then
    echo -e "${GREEN}✅ User registration successful${NC}"
    JWT_TOKEN=$(echo "$REGISTER_RESPONSE" | jq -r '.data.tokens.accessToken' 2>/dev/null)
    echo "Extracted JWT token (first 50 chars): ${JWT_TOKEN:0:50}..."
else
    echo -e "${YELLOW}⚠️  Registration might have failed (user might already exist)${NC}"
    echo "Response: $REGISTER_RESPONSE"
    
    # Try login instead
    echo -e "\n${YELLOW}2b. Trying Login...${NC}"
    LOGIN_RESPONSE=$(curl -s -X POST "${API_BASE}/api/v1/auth/login" \
        -H "Content-Type: application/json" \
        -d '{
            "email": "testteacher@example.com",
            "password": "Password123!"
        }')
    
    if echo "$LOGIN_RESPONSE" | grep -q '"success":true'; then
        echo -e "${GREEN}✅ User login successful${NC}"
        JWT_TOKEN=$(echo "$LOGIN_RESPONSE" | jq -r '.data.tokens.accessToken' 2>/dev/null)
        echo "Extracted JWT token (first 50 chars): ${JWT_TOKEN:0:50}..."
    else
        echo -e "${RED}❌ Both registration and login failed${NC}"
        echo "Response: $LOGIN_RESPONSE"
        exit 1
    fi
fi

# Test 3: Get Current User Profile
echo -e "\n${YELLOW}3. Testing Get Current User Profile...${NC}"
if [ -n "$JWT_TOKEN" ]; then
    PROFILE_RESPONSE=$(curl -s -X GET "${API_BASE}/api/v1/auth/me" \
        -H "Authorization: Bearer ${JWT_TOKEN}")
    
    if echo "$PROFILE_RESPONSE" | grep -q '"success":true'; then
        echo -e "${GREEN}✅ Profile retrieval successful${NC}"
        echo "$PROFILE_RESPONSE" | jq '.data | {email, firstName, lastName, role}' 2>/dev/null || echo "Profile: $PROFILE_RESPONSE"
    else
        echo -e "${RED}❌ Profile retrieval failed${NC}"
        echo "Response: $PROFILE_RESPONSE"
    fi
else
    echo -e "${RED}❌ No JWT token available for profile test${NC}"
fi

# Test 4: Create Lesson
echo -e "\n${YELLOW}4. Testing Lesson Creation...${NC}"
if [ -n "$JWT_TOKEN" ]; then
    LESSON_RESPONSE=$(curl -s -X POST "${API_BASE}/api/v1/lessons" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer ${JWT_TOKEN}" \
        -d '{
            "title": "Test Lesson: Introduction to Docker",
            "description": "A comprehensive guide to containerization with Docker",
            "difficulty": "beginner",
            "estimatedTime": 60,
            "objectives": [
                "Understand Docker concepts",
                "Learn container basics",
                "Practice with Docker commands"
            ],
            "tags": ["docker", "containerization", "devops"]
        }')
    
    if echo "$LESSON_RESPONSE" | grep -q '"success":true'; then
        echo -e "${GREEN}✅ Lesson creation successful${NC}"
        LESSON_ID=$(echo "$LESSON_RESPONSE" | jq -r '.data.id' 2>/dev/null)
        echo "Created lesson ID: $LESSON_ID"
        echo "$LESSON_RESPONSE" | jq '.data | {id, title, status, difficulty}' 2>/dev/null || echo "Lesson: $LESSON_RESPONSE"
    else
        echo -e "${RED}❌ Lesson creation failed${NC}"
        echo "Response: $LESSON_RESPONSE"
    fi
else
    echo -e "${RED}❌ No JWT token available for lesson creation${NC}"
fi

# Test 5: List Lessons
echo -e "\n${YELLOW}5. Testing Lesson Listing...${NC}"
if [ -n "$JWT_TOKEN" ]; then
    LESSONS_RESPONSE=$(curl -s -X GET "${API_BASE}/api/v1/lessons" \
        -H "Authorization: Bearer ${JWT_TOKEN}")
    
    if echo "$LESSONS_RESPONSE" | grep -q '"success":true'; then
        echo -e "${GREEN}✅ Lesson listing successful${NC}"
        echo "$LESSONS_RESPONSE" | jq '.data | length' 2>/dev/null && echo " lessons found" || echo "Lessons: $LESSONS_RESPONSE"
    else
        echo -e "${RED}❌ Lesson listing failed${NC}"
        echo "Response: $LESSONS_RESPONSE"
    fi
else
    echo -e "${RED}❌ No JWT token available for lesson listing${NC}"
fi

# Test 6: Database Connectivity (if accessible)
echo -e "\n${YELLOW}6. Testing Database Connectivity...${NC}"
if command -v docker > /dev/null 2>&1; then
    if docker ps | grep -q "interactive-learning-db"; then
        DB_TEST=$(docker exec interactive-learning-db psql -U postgres -d interactive_learning -c "SELECT COUNT(*) FROM users;" 2>/dev/null || echo "DB_ERROR")
        if [[ "$DB_TEST" != "DB_ERROR" ]]; then
            echo -e "${GREEN}✅ Database connectivity successful${NC}"
            echo "Database query result: $DB_TEST"
        else
            echo -e "${YELLOW}⚠️  Database query failed but container is running${NC}"
        fi
    else
        echo -e "${YELLOW}⚠️  Database container not found - run: npm run dev:up${NC}"
    fi
else
    echo -e "${YELLOW}⚠️  Docker not available for database test${NC}"
fi

# Test 7: Redis Connectivity (if accessible)
echo -e "\n${YELLOW}7. Testing Redis Connectivity...${NC}"
if command -v docker > /dev/null 2>&1; then
    if docker ps | grep -q "interactive-learning-redis"; then
        REDIS_TEST=$(docker exec interactive-learning-redis redis-cli -a redis_dev_password ping 2>/dev/null || echo "REDIS_ERROR")
        if [[ "$REDIS_TEST" == "PONG" ]]; then
            echo -e "${GREEN}✅ Redis connectivity successful${NC}"
            echo "Redis response: $REDIS_TEST"
        else
            echo -e "${YELLOW}⚠️  Redis query failed but container is running${NC}"
        fi
    else
        echo -e "${YELLOW}⚠️  Redis container not found - run: npm run dev:up${NC}"
    fi
else
    echo -e "${YELLOW}⚠️  Docker not available for Redis test${NC}"
fi

echo -e "\n${BLUE}🎉 API Testing Complete!${NC}"
echo "=============================="
echo -e "${GREEN}✅ Basic API functionality verified${NC}"
echo -e "${BLUE}📋 Next steps:${NC}"
echo "  • Access API at: ${API_BASE}"
echo "  • Database admin: http://localhost:8080"
echo "  • Redis admin: http://localhost:8001"
echo "  • View logs: npm run dev:logs"
echo ""
echo -e "${BLUE}🔗 Useful endpoints:${NC}"
echo "  • Health: GET ${API_BASE}/health"
echo "  • Auth: POST ${API_BASE}/api/v1/auth/login"
echo "  • Users: GET ${API_BASE}/api/v1/users"
echo "  • Lessons: GET ${API_BASE}/api/v1/lessons"
</file>

<file path="scripts/testing/test-lesson-detail.sh">
#!/bin/bash

# Test script for lesson detail page
# Usage: ./test-lesson-detail.sh

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}Testing Lesson Detail Page...${NC}"

# 1. Login as student to get token
echo -e "\n${BLUE}1. Logging in as student...${NC}"
LOGIN_RESPONSE=$(curl -s -X POST http://localhost:3000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "student@example.com",
    "password": "Demo123!"
  }')

TOKEN=$(echo $LOGIN_RESPONSE | grep -o '"accessToken":"[^"]*' | cut -d'"' -f4)

if [ -z "$TOKEN" ]; then
  echo -e "${RED}Failed to get auth token${NC}"
  echo "Response: $LOGIN_RESPONSE"
  exit 1
fi

echo -e "${GREEN}✓ Successfully logged in as student${NC}"

# 2. Get list of lessons
echo -e "\n${BLUE}2. Getting list of published lessons...${NC}"
LESSONS_RESPONSE=$(curl -s -X GET "http://localhost:3000/api/v1/lessons?status=PUBLISHED&limit=5" \
  -H "Authorization: Bearer $TOKEN")

echo "Lessons response:"
echo $LESSONS_RESPONSE | python3 -m json.tool | head -50

# 3. Get first lesson ID
LESSON_ID=$(echo $LESSONS_RESPONSE | grep -o '"id":"[^"]*' | head -1 | cut -d'"' -f4)

if [ -z "$LESSON_ID" ]; then
  echo -e "${RED}No published lessons found${NC}"
  exit 1
fi

echo -e "${GREEN}✓ Found lesson: $LESSON_ID${NC}"

# 4. Get lesson details
echo -e "\n${BLUE}3. Getting lesson details...${NC}"
LESSON_DETAIL=$(curl -s -X GET "http://localhost:3000/api/v1/lessons/$LESSON_ID" \
  -H "Authorization: Bearer $TOKEN")

echo "Lesson detail:"
echo $LESSON_DETAIL | python3 -m json.tool | head -30

# 5. Get video groups for the lesson
echo -e "\n${BLUE}4. Getting video groups for lesson...${NC}"
VIDEO_GROUPS=$(curl -s -X GET "http://localhost:3000/api/v1/videos?lessonId=$LESSON_ID" \
  -H "Authorization: Bearer $TOKEN")

echo "Video groups for lesson:"
echo $VIDEO_GROUPS | python3 -m json.tool | head -50

# Check if there are video groups
if echo $VIDEO_GROUPS | grep -q '"data":\[\]'; then
  echo -e "${RED}No video groups found for this lesson${NC}"
else
  echo -e "${GREEN}✓ Video groups found for lesson${NC}"
fi

echo -e "\n${GREEN}Test complete!${NC}"
echo -e "You can now visit: ${BLUE}http://localhost:3001/lessons/$LESSON_ID${NC}"
</file>

<file path="scripts/testing/test-session.ts">
import axios from 'axios'

async function testSession() {
  try {
    // First login as student
    const loginResponse = await axios.post('http://localhost:3000/api/v1/auth/login', {
      email: 'student@example.com',
      password: 'Demo123!'
    })
    
    console.log('Login response data:', loginResponse.data.data)
    const accessToken = loginResponse.data.data?.tokens?.accessToken || loginResponse.data.data?.accessToken
    console.log('✅ Login successful')
    
    if (!accessToken) {
      console.error('No access token received!')
      return
    }
    
    // Decode the token to see what's in it
    const tokenParts = accessToken.split('.')
    const payload = JSON.parse(Buffer.from(tokenParts[1], 'base64').toString())
    console.log('Token payload:', payload)
    
    // Now try to get session for the video
    const videoId = 'cme33hmyb000bxgonc1t7lrrh'
    
    try {
      const sessionResponse = await axios.get(
        `http://localhost:3000/api/v1/sessions/video/${videoId}`,
        {
          headers: {
            Authorization: `Bearer ${accessToken}`
          }
        }
      )
      
      console.log('✅ Session fetched successfully:', sessionResponse.data)
    } catch (sessionError: any) {
      console.error('❌ Session fetch error:', {
        status: sessionError.response?.status,
        data: sessionError.response?.data,
        message: sessionError.message
      })
    }
    
  } catch (error: any) {
    console.error('❌ Login error:', error.response?.data || error.message)
  }
}

testSession()
</file>

<file path="scripts/testing/test-video-player.ts">
#!/usr/bin/env tsx

import axios from 'axios'

const API_URL = 'http://localhost:3000/api/v1'

// Test credentials
const testUser = {
  email: 'student@example.com',
  password: 'Demo123!'
}

// Test video ID from the database
const testVideoId = 'cme33hmyb000bxgonc1t7lrrh'

async function login() {
  try {
    const response = await axios.post(`${API_URL}/auth/login`, testUser)
    const token = response.data.data.tokens.accessToken
    console.log('Token received:', token ? '✓' : '✗')
    return token
  } catch (error: any) {
    console.error('Login failed:', error.response?.data || error.message)
    throw error
  }
}

async function testVideoPlayerFlow(token: string) {
  const headers = { Authorization: `Bearer ${token}` }
  let sessionId: string = ''
  
  console.log('\n=== Testing Video Player Flow ===\n')
  
  try {
    // 1. Get video details
    console.log('1. Getting video details...')
    const videoResponse = await axios.get(`${API_URL}/videos/${testVideoId}`, { headers })
    console.log('✓ Video loaded:', videoResponse.data.data.title)
    console.log('  Milestones:', videoResponse.data.data.milestones?.length || 0)
    
    // 2. Get or create session
    console.log('\n2. Getting session for video...')
    try {
      const sessionResponse = await axios.get(`${API_URL}/sessions/video/${testVideoId}`, { headers })
      const session = sessionResponse.data.data
      if (session) {
        sessionId = session.id
        console.log('✓ Found existing session:', sessionId)
        console.log('  Status:', session.status)
        console.log('  Current position:', session.currentPosition, 'seconds')
      }
    } catch (error) {
      console.log('  No existing session found')
    }
    
    // 3. Start session if needed
    if (!sessionId) {
      console.log('\n3. Starting new session...')
      const startResponse = await axios.post(`${API_URL}/sessions/start`, 
        { videoId: testVideoId }, 
        { headers }
      )
      const session = startResponse.data.data
      if (session) {
        sessionId = session.id
        console.log('✓ Session started:', sessionId)
      } else {
        console.log('  Session creation returned null (expected for new videos)')
        // Create session through GET endpoint
        const getResponse = await axios.get(`${API_URL}/sessions/video/${testVideoId}`, { headers })
        sessionId = getResponse.data.data.id
        console.log('✓ Session created via GET:', sessionId)
      }
    }
    
    // 4. Update progress
    console.log('\n4. Updating progress...')
    const progressResponse = await axios.put(
      `${API_URL}/sessions/${sessionId}/progress`,
      { currentTime: 30, totalWatchTime: 30 },
      { headers }
    )
    console.log('✓ Progress updated to 30 seconds')
    
    // 5. Mark milestone (if video has milestones)
    const video = videoResponse.data.data
    if (video.milestones && video.milestones.length > 0) {
      const firstMilestone = video.milestones[0]
      console.log('\n5. Marking milestone as reached...')
      try {
        await axios.post(
          `${API_URL}/sessions/${sessionId}/milestone`,
          { 
            milestoneId: firstMilestone.id,
            timestamp: firstMilestone.timestamp
          },
          { headers }
        )
        console.log('✓ Milestone reached:', firstMilestone.title)
        
        // 6. Submit answer if milestone has questions
        if (firstMilestone.questions && firstMilestone.questions.length > 0) {
          const firstQuestion = firstMilestone.questions[0]
          console.log('\n6. Submitting answer to question...')
          
          // Determine answer based on question type
          let answer = 'Test answer'
          if (firstQuestion.type === 'MULTIPLE_CHOICE') {
            const options = firstQuestion.questionData?.options || []
            answer = options[0] || 'Option A'
          } else if (firstQuestion.type === 'TRUE_FALSE') {
            answer = 'true'
          }
          
          const answerResponse = await axios.post(
            `${API_URL}/sessions/${sessionId}/question`,
            {
              questionId: firstQuestion.id,
              milestoneId: firstMilestone.id,
              answer: answer
            },
            { headers }
          )
          const result = answerResponse.data.data
          console.log('✓ Answer submitted')
          console.log('  Correct:', result.isCorrect)
          console.log('  Score:', result.score)
          if (result.explanation) {
            console.log('  Explanation:', result.explanation)
          }
        }
      } catch (error: any) {
        if (error.response?.data?.error === 'Milestone not found') {
          console.log('  Milestone not found for this video')
        } else {
          throw error
        }
      }
    }
    
    // 7. Complete session
    console.log('\n7. Completing session...')
    const completeResponse = await axios.put(
      `${API_URL}/sessions/${sessionId}/complete`,
      { finalTime: 60, totalWatchTime: 60 },
      { headers }
    )
    console.log('✓ Session completed')
    console.log('  Final status:', completeResponse.data.data.status)
    
    console.log('\n=== All Video Player Flows Working! ===\n')
    
  } catch (error: any) {
    console.error('\n✗ Error in video player flow:')
    console.error('  Status:', error.response?.status)
    console.error('  Message:', error.response?.data?.error || error.message)
    console.error('  Details:', error.response?.data?.details)
    process.exit(1)
  }
}

async function main() {
  try {
    console.log('Logging in as student...')
    const token = await login()
    console.log('✓ Logged in successfully')
    
    await testVideoPlayerFlow(token)
    
    console.log('\n✅ All tests passed!')
  } catch (error) {
    console.error('Test failed:', error)
    process.exit(1)
  }
}

main()
</file>

<file path="scripts/video/process-video.mjs">
import { PrismaClient } from '@prisma/client';
import { VideoProcessingService } from '../src/services/VideoProcessingService.js';

const prisma = new PrismaClient();

async function processVideo(videoId) {
  try {
    console.log('Processing video:', videoId);
    
    // Get video from database
    const video = await prisma.video.findUnique({
      where: { id: videoId }
    });

    if (!video) {
      console.error('Video not found:', videoId);
      return;
    }

    console.log('Found video:', {
      id: video.id,
      title: video.title,
      filePath: video.filePath,
      duration: video.duration
    });

    if (!video.filePath) {
      console.error('Video has no file path');
      return;
    }

    // Process the video metadata
    console.log('Extracting metadata from:', video.filePath);
    const metadata = await VideoProcessingService.getVideoMetadata(video.filePath);
    const size = await VideoProcessingService.getFileSize(video.filePath);

    console.log('Extracted metadata:', metadata);
    console.log('Extracted size:', size);

    // Update video with metadata
    const updatedVideo = await prisma.video.update({
      where: { id: videoId },
      data: {
        duration: metadata.duration,
        size: size,
        processedAt: new Date(),
        processingStatus: metadata.duration ? 'COMPLETED' : 'FAILED',
        metadata: {
          width: metadata.width,
          height: metadata.height,
          bitrate: metadata.bitrate,
          fps: metadata.fps,
          codec: metadata.codec
        }
      }
    });

    console.log('Updated video successfully:', {
      id: updatedVideo.id,
      duration: updatedVideo.duration,
      size: updatedVideo.size,
      processingStatus: updatedVideo.processingStatus
    });

  } catch (error) {
    console.error('Error processing video:', error);
  } finally {
    await prisma.$disconnect();
  }
}

// Process the specific video
const videoId = 'cme33hmyb000bxgonc1t7lrrh';
processVideo(videoId);
</file>

<file path="scripts/video/process-video.ts">
import { VideoService } from '../src/services/VideoService'

async function processVideo() {
  try {
    const videoId = 'cme33hmyb000bxgonc1t7lrrh'
    console.log('Processing video metadata for:', videoId)
    
    const updatedVideo = await VideoService.processVideoMetadata(videoId)
    
    console.log('✅ Video processed successfully!')
    console.log('Updated video:', {
      id: updatedVideo.id,
      title: updatedVideo.title,
      duration: updatedVideo.duration,
      size: updatedVideo.size,
      processingStatus: updatedVideo.processingStatus
    })
    
  } catch (error) {
    console.error('❌ Error processing video:', error)
  }
}

processVideo()
</file>

<file path="scripts/README.md">
# Scripts Directory Organization

This directory contains utility scripts organized by functionality.

## Directory Structure

### 📁 frontend/
Frontend debugging and screenshot utilities
- `screenshot.ts` - Puppeteer-based screenshot capture utility
- `debug-frontend.sh` - Frontend debugging helper script

### 📁 testing/
Test scripts and utilities
- `test-api.sh` - API endpoint testing
- `test-lesson-detail.sh` - Lesson detail testing
- `test-session.ts` - Session testing
- `test-video-player.ts` - Video player testing
- `run-tests.sh` - Main test runner
- `check-access.ts` - Access control testing
- `enroll-student.ts` - Student enrollment testing

### 📁 database/
Database seeding and management scripts
- `simple-seed.js` - Basic database seeding
- `seed-video.js` - Video data seeding
- `check-user.js` - User verification utility

### 📁 video/
Video processing scripts
- `process-video.ts` - TypeScript video processor
- `process-video.mjs` - ES module video processor

### 📁 dev/
Development utilities
- `dev.sh` - Development environment helper

## Usage Examples

### Frontend Screenshot Capture
```bash
# Capture full page screenshot
npx tsx scripts/frontend/screenshot.ts capture http://localhost:3001

# Capture specific element
npx tsx scripts/frontend/screenshot.ts element '.login-form' http://localhost:3001

# Debug mode with metrics
npx tsx scripts/frontend/screenshot.ts debug http://localhost:3001
```

### Running Tests
```bash
# Run API tests
npm run test:api

# Run all tests
bash scripts/testing/run-tests.sh
```

### Database Operations
```bash
# Seed database
node scripts/database/simple-seed.js

# Check user
node scripts/database/check-user.js
```
</file>

<file path="scripts/tsconfig.json">
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "../dist/scripts",
    "rootDir": ".",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "types": ["node"],
    "allowSyntheticDefaultImports": true,
    "noEmit": true
  },
  "include": [
    "**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "**/*.test.ts"
  ]
}
</file>

<file path="src/controllers/__tests__/auth.controller.test.ts">
import request from 'supertest';
import express from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { AuthController } from '../auth.controller';
import { UserService } from '../../services/user.service';
import { getTestPrismaClient, setupTestDatabase, cleanupDatabase } from '../../../tests/utils/database';
import { validationErrorHandler } from '../../middleware/validation';

describe('AuthController', () => {
  let app: express.Application;
  let authController: AuthController;
  let userService: UserService;
  let prisma: ReturnType<typeof getTestPrismaClient>;

  beforeAll(async () => {
    await setupTestDatabase();
    prisma = getTestPrismaClient();
  });

  beforeEach(async () => {
    await cleanupDatabase();
    
    // Initialize services and controllers
    userService = new UserService();
    authController = new AuthController();
    
    // Setup Express app for testing
    app = express();
    app.use(express.json());
    
    // Setup routes
    app.post('/auth/register', authController.register);
    app.post('/auth/login', authController.login);
    app.post('/auth/logout', authController.logout);
    app.post('/auth/refresh', authController.refreshToken);
    
    // Add error handler
    app.use(validationErrorHandler);
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  describe('POST /auth/register', () => {
    const validRegistrationData = {
      email: 'newuser@example.com',
      password: 'SecurePassword123!',
      firstName: 'John',
      lastName: 'Doe',
      role: 'STUDENT'
    };

    it('should register a new user with valid data', async () => {
      const response = await request(app)
        .post('/auth/register')
        .send(validRegistrationData)
        .expect(201);

      expect(response.body).toHaveProperty('user');
      expect(response.body).toHaveProperty('accessToken');
      expect(response.body).toHaveProperty('refreshToken');
      expect(response.body.user.email).toBe(validRegistrationData.email);
      expect(response.body.user.role).toBe(validRegistrationData.role);
      expect(response.body.user).not.toHaveProperty('passwordHash');
    });

    it('should reject registration with duplicate email', async () => {
      // First registration
      await request(app)
        .post('/auth/register')
        .send(validRegistrationData)
        .expect(201);

      // Duplicate registration
      const response = await request(app)
        .post('/auth/register')
        .send(validRegistrationData)
        .expect(409);

      expect(response.body).toHaveProperty('error');
      expect(response.body.error).toContain('already exists');
    });

    it('should reject registration with invalid email format', async () => {
      const response = await request(app)
        .post('/auth/register')
        .send({
          ...validRegistrationData,
          email: 'invalid-email'
        })
        .expect(400);

      expect(response.body).toHaveProperty('errors');
      expect(response.body.errors).toContainEqual(
        expect.objectContaining({
          field: 'email',
          message: expect.stringContaining('valid email')
        })
      );
    });

    it('should reject registration with weak password', async () => {
      const response = await request(app)
        .post('/auth/register')
        .send({
          ...validRegistrationData,
          password: '12345'
        })
        .expect(400);

      expect(response.body).toHaveProperty('errors');
      expect(response.body.errors).toContainEqual(
        expect.objectContaining({
          field: 'password',
          message: expect.stringContaining('password')
        })
      );
    });

    it('should reject registration with invalid role', async () => {
      const response = await request(app)
        .post('/auth/register')
        .send({
          ...validRegistrationData,
          role: 'INVALID_ROLE'
        })
        .expect(400);

      expect(response.body).toHaveProperty('errors');
      expect(response.body.errors).toContainEqual(
        expect.objectContaining({
          field: 'role'
        })
      );
    });

    it('should hash the password before storing', async () => {
      await request(app)
        .post('/auth/register')
        .send(validRegistrationData)
        .expect(201);

      const user = await prisma.user.findUnique({
        where: { email: validRegistrationData.email }
      });

      expect(user).toBeTruthy();
      expect(user?.passwordHash).toBeTruthy();
      expect(user?.passwordHash).not.toBe(validRegistrationData.password);
      
      const isValidPassword = await bcrypt.compare(
        validRegistrationData.password,
        user!.passwordHash
      );
      expect(isValidPassword).toBe(true);
    });
  });

  describe('POST /auth/login', () => {
    const userCredentials = {
      email: 'testuser@example.com',
      password: 'SecurePassword123!'
    };

    beforeEach(async () => {
      // Create a test user
      const passwordHash = await bcrypt.hash(userCredentials.password, 10);
      await prisma.user.create({
        data: {
          email: userCredentials.email,
          firstName: 'Test',
          lastName: 'User',
          role: 'STUDENT',
          status: 'ACTIVE',
          passwordHash,
          emailVerified: new Date()
        }
      });
    });

    it('should authenticate user with valid credentials', async () => {
      const response = await request(app)
        .post('/auth/login')
        .send(userCredentials)
        .expect(200);

      expect(response.body).toHaveProperty('user');
      expect(response.body).toHaveProperty('accessToken');
      expect(response.body).toHaveProperty('refreshToken');
      expect(response.body.user.email).toBe(userCredentials.email);
    });

    it('should reject login with invalid email', async () => {
      const response = await request(app)
        .post('/auth/login')
        .send({
          email: 'nonexistent@example.com',
          password: userCredentials.password
        })
        .expect(401);

      expect(response.body).toHaveProperty('error');
      expect(response.body.error).toContain('Invalid credentials');
    });

    it('should reject login with invalid password', async () => {
      const response = await request(app)
        .post('/auth/login')
        .send({
          email: userCredentials.email,
          password: 'WrongPassword123!'
        })
        .expect(401);

      expect(response.body).toHaveProperty('error');
      expect(response.body.error).toContain('Invalid credentials');
    });

    it('should reject login for inactive user', async () => {
      // Update user status to inactive
      await prisma.user.update({
        where: { email: userCredentials.email },
        data: { status: 'INACTIVE' }
      });

      const response = await request(app)
        .post('/auth/login')
        .send(userCredentials)
        .expect(403);

      expect(response.body).toHaveProperty('error');
      expect(response.body.error).toContain('inactive');
    });

    it('should update lastLogin timestamp on successful login', async () => {
      await request(app)
        .post('/auth/login')
        .send(userCredentials)
        .expect(200);

      const user = await prisma.user.findUnique({
        where: { email: userCredentials.email }
      });

      expect(user?.lastLogin).toBeTruthy();
      expect(new Date(user!.lastLogin!).getTime()).toBeCloseTo(Date.now(), -2);
    });

    it('should return valid JWT tokens', async () => {
      const response = await request(app)
        .post('/auth/login')
        .send(userCredentials)
        .expect(200);

      // Verify access token
      const decodedAccess = jwt.verify(
        response.body.accessToken,
        process.env.JWT_SECRET!
      ) as any;
      expect(decodedAccess.userId).toBeTruthy();
      expect(decodedAccess.email).toBe(userCredentials.email);

      // Verify refresh token
      const decodedRefresh = jwt.verify(
        response.body.refreshToken,
        process.env.JWT_SECRET!
      ) as any;
      expect(decodedRefresh.userId).toBe(decodedAccess.userId);
      expect(decodedRefresh.type).toBe('refresh');
    });
  });

  describe('POST /auth/refresh', () => {
    let validRefreshToken: string;
    let userId: string;

    beforeEach(async () => {
      // Create a test user and get tokens
      const user = await prisma.user.create({
        data: {
          email: 'refresh@example.com',
          firstName: 'Refresh',
          lastName: 'User',
          role: 'STUDENT',
          status: 'ACTIVE',
          passwordHash: await bcrypt.hash('Password123!', 10),
          emailVerified: new Date()
        }
      });
      
      userId = user.id;
      
      // Create refresh token
      validRefreshToken = jwt.sign(
        { userId, type: 'refresh' },
        process.env.JWT_SECRET!,
        { expiresIn: '7d' }
      );
      
      // Store refresh token
      await prisma.refreshToken.create({
        data: {
          token: validRefreshToken,
          userId,
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
        }
      });
    });

    it('should refresh tokens with valid refresh token', async () => {
      const response = await request(app)
        .post('/auth/refresh')
        .send({ refreshToken: validRefreshToken })
        .expect(200);

      expect(response.body).toHaveProperty('accessToken');
      expect(response.body).toHaveProperty('refreshToken');
      expect(response.body.accessToken).not.toBe(validRefreshToken);
    });

    it('should reject refresh with invalid token', async () => {
      const response = await request(app)
        .post('/auth/refresh')
        .send({ refreshToken: 'invalid-token' })
        .expect(401);

      expect(response.body).toHaveProperty('error');
      expect(response.body.error).toContain('Invalid token');
    });

    it('should reject refresh with expired token', async () => {
      // Create expired token
      const expiredToken = jwt.sign(
        { userId, type: 'refresh' },
        process.env.JWT_SECRET!,
        { expiresIn: '-1h' }
      );

      const response = await request(app)
        .post('/auth/refresh')
        .send({ refreshToken: expiredToken })
        .expect(401);

      expect(response.body).toHaveProperty('error');
      expect(response.body.error).toContain('expired');
    });

    it('should invalidate old refresh token after successful refresh', async () => {
      await request(app)
        .post('/auth/refresh')
        .send({ refreshToken: validRefreshToken })
        .expect(200);

      // Try to use old token again
      const response = await request(app)
        .post('/auth/refresh')
        .send({ refreshToken: validRefreshToken })
        .expect(401);

      expect(response.body).toHaveProperty('error');
    });
  });

  describe('POST /auth/logout', () => {
    let accessToken: string;
    let refreshToken: string;

    beforeEach(async () => {
      // Create user and login to get tokens
      const user = await prisma.user.create({
        data: {
          email: 'logout@example.com',
          firstName: 'Logout',
          lastName: 'User',
          role: 'STUDENT',
          status: 'ACTIVE',
          passwordHash: await bcrypt.hash('Password123!', 10),
          emailVerified: new Date()
        }
      });

      accessToken = jwt.sign(
        { userId: user.id, email: user.email },
        process.env.JWT_SECRET!,
        { expiresIn: '15m' }
      );

      refreshToken = jwt.sign(
        { userId: user.id, type: 'refresh' },
        process.env.JWT_SECRET!,
        { expiresIn: '7d' }
      );

      await prisma.refreshToken.create({
        data: {
          token: refreshToken,
          userId: user.id,
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
        }
      });
    });

    it('should successfully logout user', async () => {
      const response = await request(app)
        .post('/auth/logout')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({ refreshToken })
        .expect(200);

      expect(response.body).toHaveProperty('message');
      expect(response.body.message).toContain('success');

      // Verify refresh token is deleted
      const tokenExists = await prisma.refreshToken.findFirst({
        where: { token: refreshToken }
      });
      expect(tokenExists).toBeNull();
    });

    it('should logout even without refresh token', async () => {
      const response = await request(app)
        .post('/auth/logout')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({})
        .expect(200);

      expect(response.body).toHaveProperty('message');
    });
  });
});
</file>

<file path="src/controllers/userController.ts">
import { Response } from 'express';
import { PrismaClient, UserRole, UserStatus } from '@prisma/client';
import bcrypt from 'bcrypt';
import { AuthenticatedRequest } from '../middleware/auth/authMiddleware';
import { logger } from '../utils/logger';

const prisma = new PrismaClient();

export const userController = {
  // Get all users (Admin only)
  async getAllUsers(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const { page = 1, limit = 10, role, status, tenantId } = req.query;
      const offset = (Number(page) - 1) * Number(limit);

      const where: any = {};
      if (req.user?.tenantId) {
        where.tenantId = req.user.tenantId;
      }
      if (role) where.role = role as UserRole;
      if (status) where.status = status as UserStatus;
      if (tenantId && req.user?.role === 'ADMIN') where.tenantId = tenantId as string;

      const users = await prisma.user.findMany({
        where,
        skip: offset,
        take: Number(limit),
        select: {
          id: true,
          email: true,
          username: true,
          firstName: true,
          lastName: true,
          avatar: true,
          role: true,
          status: true,
          tenantId: true,
          lastLoginAt: true,
          createdAt: true,
          emailVerified: true
        },
        orderBy: { createdAt: 'desc' }
      });

      const total = await prisma.user.count({ where });

      res.json({
        success: true,
        data: users,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total,
          totalPages: Math.ceil(total / Number(limit))
        }
      });
    } catch (error) {
      logger.error('Error fetching users:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch users'
      });
      return;
    }
  },

  // Get user by ID
  async getUserById(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const currentUser = req.user!;

      // Users can only view their own profile unless admin
      if (currentUser.role !== 'ADMIN' && currentUser.id !== id) {
        res.status(403).json({
          success: false,
          error: 'Access denied: Cannot view other user profiles'
        });
        return;
      }

      const where: any = { id };
      if (currentUser.tenantId && currentUser.role !== 'ADMIN') {
        where.tenantId = currentUser.tenantId;
      }

      const user = await prisma.user.findFirst({
        where,
        select: {
          id: true,
          email: true,
          username: true,
          firstName: true,
          lastName: true,
          avatar: true,
          role: true,
          status: true,
          tenantId: true,
          lastLoginAt: true,
          createdAt: true,
          emailVerified: true,
          metadata: true,
          userPreferences: {
            select: {
              autoplay: true,
              playbackSpeed: true,
              subtitles: true,
              theme: true,
              language: true,
              emailNotifications: true,
              progressNotifications: true,
              allowAnalytics: true
            }
          }
        }
      });

      if (!user) {
        res.status(404).json({
          success: false,
          error: 'User not found'
        });
        return;
      }

      res.json({
        success: true,
        data: user
      });
    } catch (error) {
      logger.error('Error fetching user:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch user'
      });
      return;
    }
  },

  // Create new user (Admin only)
  async createUser(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const {
        email,
        username,
        firstName,
        lastName,
        password,
        role = UserRole.STUDENT,
        tenantId
      } = req.body;

      const currentUser = req.user!;

      // Set tenant context
      let userTenantId = currentUser.tenantId;
      if (tenantId && currentUser.role === 'ADMIN') {
        userTenantId = tenantId;
      }

      // Hash password
      const passwordHash = await bcrypt.hash(password, 12);

      const user = await prisma.user.create({
        data: {
          email,
          username,
          firstName,
          lastName,
          passwordHash,
          role,
          tenantId: userTenantId,
          status: UserStatus.PENDING_VERIFICATION
        },
        select: {
          id: true,
          email: true,
          username: true,
          firstName: true,
          lastName: true,
          role: true,
          status: true,
          tenantId: true,
          createdAt: true
        }
      });

      // Create default user preferences
      await prisma.userPreference.create({
        data: {
          userId: user.id
        }
      });

      logger.info(`User created: ${user.email} by ${currentUser.email}`);

      res.status(201).json({
        success: true,
        data: user,
        message: 'User created successfully'
      });
    } catch (error: any) {
      logger.error('Error creating user:', error);
      
      if (error.code === 'P2002') {
        res.status(409).json({
          success: false,
          error: 'User with this email or username already exists'
        });
        return;
      }

      res.status(500).json({
        success: false,
        error: 'Failed to create user'
      });
      return;
    }
  },

  // Update user
  async updateUser(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const currentUser = req.user!;
      const updateData = req.body;

      // Users can only update their own profile unless admin
      if (currentUser.role !== 'ADMIN' && currentUser.id !== id) {
        res.status(403).json({
          success: false,
          error: 'Access denied: Cannot update other user profiles'
        });
        return;
      }

      // Remove sensitive fields that shouldn't be updated directly
      delete updateData.passwordHash;
      delete updateData.id;
      delete updateData.createdAt;

      // Only admins can change roles and status
      if (currentUser.role !== 'ADMIN') {
        delete updateData.role;
        delete updateData.status;
        delete updateData.tenantId;
      }

      const where: any = { id };
      if (currentUser.tenantId && currentUser.role !== 'ADMIN') {
        where.tenantId = currentUser.tenantId;
      }

      const user = await prisma.user.update({
        where,
        data: updateData,
        select: {
          id: true,
          email: true,
          username: true,
          firstName: true,
          lastName: true,
          avatar: true,
          role: true,
          status: true,
          tenantId: true,
          updatedAt: true
        }
      });

      logger.info(`User updated: ${user.email} by ${currentUser.email}`);

      res.json({
        success: true,
        data: user,
        message: 'User updated successfully'
      });
    } catch (error: any) {
      logger.error('Error updating user:', error);
      
      if (error.code === 'P2002') {
        res.status(409).json({
          success: false,
          error: 'Email or username already exists'
        });
        return;
      }

      if (error.code === 'P2025') {
        res.status(404).json({
          success: false,
          error: 'User not found'
        });
        return;
      }

      res.status(500).json({
        success: false,
        error: 'Failed to update user'
      });
      return;
    }
  },

  // Change password
  async changePassword(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const { currentPassword, newPassword } = req.body;
      const currentUser = req.user!;

      // Users can only change their own password unless admin
      if (currentUser.role !== 'ADMIN' && currentUser.id !== id) {
        res.status(403).json({
          success: false,
          error: 'Access denied: Cannot change other user passwords'
        });
        return;
      }

      const where: any = { id };
      if (currentUser.tenantId && currentUser.role !== 'ADMIN') {
        where.tenantId = currentUser.tenantId;
      }

      const user = await prisma.user.findFirst({ where });
      if (!user) {
        res.status(404).json({
          success: false,
          error: 'User not found'
        });
        return;
      }

      // Verify current password (unless admin)
      if (currentUser.role !== 'ADMIN') {
        const isCurrentPasswordValid = await bcrypt.compare(currentPassword, user.passwordHash);
        if (!isCurrentPasswordValid) {
          res.status(400).json({
            success: false,
            error: 'Current password is incorrect'
          });
        return;
        }
      }

      // Hash new password
      const newPasswordHash = await bcrypt.hash(newPassword, 12);

      await prisma.user.update({
        where: { id },
        data: {
          passwordHash: newPasswordHash,
          updatedAt: new Date()
        }
      });

      logger.info(`Password changed for user: ${user.email} by ${currentUser.email}`);

      res.json({
        success: true,
        message: 'Password changed successfully'
      });
    } catch (error) {
      logger.error('Error changing password:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to change password'
      });
      return;
    }
  },

  // Update user preferences
  async updatePreferences(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const currentUser = req.user!;
      const preferencesData = req.body;

      // Users can only update their own preferences
      if (currentUser.id !== id) {
        res.status(403).json({
          success: false,
          error: 'Access denied: Cannot update other user preferences'
        });
        return;
      }

      const preferences = await prisma.userPreference.upsert({
        where: { userId: id },
        create: {
          userId: id,
          ...preferencesData
        },
        update: preferencesData,
        select: {
          autoplay: true,
          playbackSpeed: true,
          subtitles: true,
          theme: true,
          language: true,
          emailNotifications: true,
          progressNotifications: true,
          allowAnalytics: true,
          customSettings: true,
          updatedAt: true
        }
      });

      res.json({
        success: true,
        data: preferences,
        message: 'Preferences updated successfully'
      });
    } catch (error) {
      logger.error('Error updating preferences:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update preferences'
      });
      return;
    }
  },

  // Delete user (Admin only)
  async deleteUser(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const currentUser = req.user!;

      // Cannot delete own account
      if (currentUser.id === id) {
        res.status(400).json({
          success: false,
          error: 'Cannot delete your own account'
        });
        return;
      }

      const where: any = { id };
      if (currentUser.tenantId) {
        where.tenantId = currentUser.tenantId;
      }

      const user = await prisma.user.findFirst({ where });
      if (!user) {
        res.status(404).json({
          success: false,
          error: 'User not found'
        });
        return;
      }

      await prisma.user.delete({ where: { id } });

      logger.info(`User deleted: ${user.email} by ${currentUser.email}`);

      res.json({
        success: true,
        message: 'User deleted successfully'
      });
    } catch (error) {
      logger.error('Error deleting user:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete user'
      });
      return;
    }
  }
};
</file>

<file path="src/middleware/auth/sessionMiddleware.ts">
import { Response, NextFunction } from 'express';
import { AuthenticatedRequest } from './authMiddleware';
import { prisma } from '../../config/database';
import { logger } from '../../utils/logger';
import { environment } from '../../config/environment';

/**
 * Session validation middleware - Checks if user session is still valid
 */
export const validateSession = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  if (!req.user) {
    return next(); // Skip if not authenticated
  }

  try {
    const userId = req.user.id;
    const sessionTimeout = environment.session.timeoutMinutes * 60 * 1000; // Convert to milliseconds
    const now = new Date();
    
    // Check if user's last activity was within session timeout
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { lastLoginAt: true }
    });

    if (!user || !user.lastLoginAt) {
      logger.warn('Session validation failed - no last login time', { userId });
      return next();
    }

    const lastActivity = new Date(user.lastLoginAt);
    const timeSinceLastActivity = now.getTime() - lastActivity.getTime();

    if (timeSinceLastActivity > sessionTimeout) {
      logger.info('Session expired due to inactivity', {
        userId,
        lastActivity: lastActivity.toISOString(),
        sessionTimeout: `${environment.session.timeoutMinutes} minutes`
      });
      
      // Don't update lastLoginAt here as session is expired
      return res.status(401).json({
        error: {
          code: 'SESSION_EXPIRED',
          message: 'Session has expired due to inactivity',
          timestamp: now.toISOString()
        }
      });
    }

    // Update last activity time for active sessions
    await prisma.user.update({
      where: { id: userId },
      data: { lastLoginAt: now }
    });

    logger.debug('Session validated and updated', {
      userId,
      lastActivity: lastActivity.toISOString()
    });

    next();
  } catch (error) {
    logger.error('Session validation error', {
      error: error instanceof Error ? error.message : 'Unknown error',
      userId: req.user.id,
      requestId: req.headers['x-request-id']
    });
    
    // Don't fail the request for session validation errors
    next();
  }
};

/**
 * Concurrent session limit middleware
 */
export const checkConcurrentSessions = async (
  req: AuthenticatedRequest,
  _res: Response,
  next: NextFunction
) => {
  if (!req.user) {
    return next();
  }

  try {
    const userId = req.user.id;
    const maxConcurrentSessions = 3; // Allow maximum 3 concurrent sessions
    const sessionTimeout = environment.session.timeoutMinutes * 60 * 1000;
    const cutoffTime = new Date(Date.now() - sessionTimeout);

    // Count active student sessions for this user
    const activeSessions = await prisma.studentSession.count({
      where: {
        studentId: userId,
        lastSeenAt: {
          gte: cutoffTime
        },
        status: 'ACTIVE'
      }
    });

    if (activeSessions > maxConcurrentSessions) {
      logger.warn('Too many concurrent sessions', {
        userId,
        activeSessions,
        maxAllowed: maxConcurrentSessions
      });

      // Optionally, you could terminate the oldest sessions here
      // For now, just warn and continue
    }

    next();
  } catch (error) {
    logger.error('Concurrent session check error', {
      error: error instanceof Error ? error.message : 'Unknown error',
      userId: req.user.id,
      requestId: req.headers['x-request-id']
    });
    
    next();
  }
};

/**
 * Device fingerprinting middleware for session security
 */
export const captureDeviceInfo = (
  req: AuthenticatedRequest,
  _res: Response,
  next: NextFunction
) => {
  if (!req.user) {
    return next();
  }

  try {
    // Capture device and browser information
    const deviceInfo = {
      userAgent: req.headers['user-agent'],
      acceptLanguage: req.headers['accept-language'],
      acceptEncoding: req.headers['accept-encoding'],
      ip: req.ip,
      timestamp: new Date().toISOString()
    };

    // Add device info to request for use in other middleware/controllers
    (req as any).deviceInfo = deviceInfo;

    logger.debug('Device information captured', {
      userId: req.user.id,
      deviceInfo,
      requestId: req.headers['x-request-id']
    });

    next();
  } catch (error) {
    logger.error('Device info capture error', {
      error: error instanceof Error ? error.message : 'Unknown error',
      userId: req.user?.id,
      requestId: req.headers['x-request-id']
    });
    
    next();
  }
};

/**
 * Session cleanup middleware - Removes expired sessions periodically
 */
export const cleanupExpiredSessions = async () => {
  try {
    const sessionTimeout = environment.session.timeoutMinutes * 60 * 1000;
    const cutoffTime = new Date(Date.now() - sessionTimeout);

    // Clean up expired student sessions
    const deletedSessions = await prisma.studentSession.deleteMany({
      where: {
        lastSeenAt: {
          lt: cutoffTime
        },
        status: {
          in: ['ACTIVE', 'PAUSED']
        }
      }
    });

    if (deletedSessions.count > 0) {
      logger.info('Cleaned up expired sessions', {
        deletedCount: deletedSessions.count,
        cutoffTime: cutoffTime.toISOString()
      });
    }

    // Also update user last login times for users who haven't been active
    await prisma.user.updateMany({
      where: {
        lastLoginAt: {
          lt: cutoffTime
        }
      },
      data: {
        lastLoginAt: null
      }
    });

  } catch (error) {
    logger.error('Session cleanup error', {
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
};
</file>

<file path="src/middleware/error/errorHandler.ts">
import { Request, Response } from 'express';
import { Prisma } from '@prisma/client';
import { ZodError } from 'zod';
import { JsonWebTokenError, TokenExpiredError } from 'jsonwebtoken';
import { logger } from '../../utils/logger';
import { environment } from '../../config/environment';

// Custom error class
export class AppError extends Error {
  public readonly statusCode: number;
  public readonly isOperational: boolean;
  public readonly code?: string;
  public readonly details?: any;

  constructor(
    message: string,
    statusCode: number = 500,
    isOperational: boolean = true,
    code?: string,
    details?: any
  ) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.code = code;
    this.details = details;

    Error.captureStackTrace(this, this.constructor);
  }
}

// Error response interface
interface ErrorResponse {
  error: {
    code: string;
    message: string;
    details?: any;
    stack?: string;
    requestId?: string;
    timestamp: string;
  };
}

// Main error handler middleware
export const errorHandler = (
  error: Error,
  req: Request,
  res: Response
) => {
  const requestId = req.headers['x-request-id'] as string;
  
  // Log the error
  logger.error('Error occurred', {
    error: error.message,
    stack: error.stack,
    requestId,
    method: req.method,
    url: req.originalUrl,
    userId: (req as any).user?.id || 'anonymous',
    ip: req.ip,
    userAgent: req.headers['user-agent'],
    body: req.body,
    params: req.params,
    query: req.query
  });

  // Handle different error types
  let statusCode = 500;
  let code = 'INTERNAL_SERVER_ERROR';
  let message = 'An unexpected error occurred';
  let details: any = undefined;

  // Custom AppError
  if (error instanceof AppError) {
    statusCode = error.statusCode;
    code = error.code || 'APPLICATION_ERROR';
    message = error.message;
    details = error.details;
  }
  
  // Prisma errors
  else if (error instanceof Prisma.PrismaClientKnownRequestError) {
    const prismaError = handlePrismaError(error);
    statusCode = prismaError.statusCode;
    code = prismaError.code;
    message = prismaError.message;
    details = prismaError.details;
  }
  
  // Prisma validation errors
  else if (error instanceof Prisma.PrismaClientValidationError) {
    statusCode = 400;
    code = 'VALIDATION_ERROR';
    message = 'Invalid data provided';
    details = { validation: 'Invalid data format or missing required fields' };
  }
  
  // Zod validation errors
  else if (error instanceof ZodError) {
    statusCode = 400;
    code = 'VALIDATION_ERROR';
    message = 'Invalid request data';
    details = {
      validation: error.errors.map(err => ({
        field: err.path.join('.'),
        message: err.message,
        code: err.code
      }))
    };
  }
  
  // JWT errors
  else if (error instanceof JsonWebTokenError) {
    statusCode = 401;
    code = 'INVALID_TOKEN';
    message = 'Invalid authentication token';
  }
  
  else if (error instanceof TokenExpiredError) {
    statusCode = 401;
    code = 'TOKEN_EXPIRED';
    message = 'Authentication token has expired';
  }
  
  // Multer errors (file upload)
  else if (error.name === 'MulterError') {
    const multerError = handleMulterError(error as any);
    statusCode = multerError.statusCode;
    code = multerError.code;
    message = multerError.message;
    details = multerError.details;
  }
  
  // Syntax errors (JSON parsing)
  else if (error instanceof SyntaxError && 'body' in error) {
    statusCode = 400;
    code = 'INVALID_JSON';
    message = 'Invalid JSON in request body';
  }
  
  // Type errors
  else if (error instanceof TypeError) {
    statusCode = 400;
    code = 'TYPE_ERROR';
    message = 'Invalid data type provided';
  }

  // Build error response
  const errorResponse: ErrorResponse = {
    error: {
      code,
      message,
      details,
      requestId,
      timestamp: new Date().toISOString()
    }
  };

  // Add stack trace in development
  if (environment.server.isDevelopment) {
    errorResponse.error.stack = error.stack;
  }

  // Send error response
  res.status(statusCode).json(errorResponse);
};

// Handle Prisma-specific errors
function handlePrismaError(error: Prisma.PrismaClientKnownRequestError) {
  switch (error.code) {
    case 'P2002': // Unique constraint violation
      return {
        statusCode: 409,
        code: 'DUPLICATE_RECORD',
        message: 'A record with this data already exists',
        details: {
          field: error.meta?.target,
          constraint: 'unique_violation'
        }
      };
    
    case 'P2025': // Record not found
      return {
        statusCode: 404,
        code: 'RECORD_NOT_FOUND',
        message: 'The requested record was not found',
        details: {
          cause: error.meta?.cause
        }
      };
    
    case 'P2003': // Foreign key constraint violation
      return {
        statusCode: 400,
        code: 'FOREIGN_KEY_VIOLATION',
        message: 'Referenced record does not exist',
        details: {
          field: error.meta?.field_name
        }
      };
    
    case 'P2014': // Invalid ID
      return {
        statusCode: 400,
        code: 'INVALID_ID',
        message: 'Invalid record ID provided',
        details: {
          field: error.meta?.field_name
        }
      };
    
    default:
      return {
        statusCode: 500,
        code: 'DATABASE_ERROR',
        message: 'A database error occurred',
        details: {
          code: error.code,
          meta: error.meta
        }
      };
  }
}

// Handle Multer (file upload) errors
function handleMulterError(error: any) {
  switch (error.code) {
    case 'LIMIT_FILE_SIZE':
      return {
        statusCode: 413,
        code: 'FILE_TOO_LARGE',
        message: 'File size exceeds the allowed limit',
        details: {
          maxSize: environment.security.maxFileSize
        }
      };
    
    case 'LIMIT_FILE_COUNT':
      return {
        statusCode: 400,
        code: 'TOO_MANY_FILES',
        message: 'Too many files uploaded',
        details: {
          maxCount: error.limit
        }
      };
    
    case 'LIMIT_UNEXPECTED_FILE':
      return {
        statusCode: 400,
        code: 'UNEXPECTED_FILE',
        message: 'Unexpected file field',
        details: {
          field: error.field
        }
      };
    
    default:
      return {
        statusCode: 400,
        code: 'FILE_UPLOAD_ERROR',
        message: 'File upload failed',
        details: {
          error: error.message
        }
      };
  }
}
</file>

<file path="src/middleware/error/notFoundHandler.ts">
import { Request, Response } from 'express';
import { logger } from '../../utils/logger';

export const notFoundHandler = (req: Request, res: Response) => {
  const requestId = req.headers['x-request-id'] as string;
  
  // Log the 404 error
  logger.warn('Route not found', {
    requestId,
    method: req.method,
    url: req.originalUrl,
    ip: req.ip,
    userAgent: req.headers['user-agent'],
    userId: (req as any).user?.id || 'anonymous'
  });

  // Send 404 response
  res.status(404).json({
    error: {
      code: 'ROUTE_NOT_FOUND',
      message: `Route ${req.method} ${req.originalUrl} not found`,
      requestId,
      timestamp: new Date().toISOString()
    }
  });
};
</file>

<file path="src/middleware/security/corsMiddleware.ts">
import cors from 'cors';
import { environment } from '../../config/environment';
import { logger } from '../../utils/logger';

// CORS configuration
const corsOptions: cors.CorsOptions = {
  origin: (origin, callback) => {
    const allowedOrigins = environment.cors.origins;
    
    // Allow requests with no origin (mobile apps, Postman, etc.)
    if (!origin) {
      return callback(null, true);
    }
    
    // Check if origin is in allowed list
    if (allowedOrigins.includes(origin)) {
      return callback(null, true);
    }
    
    // In development, allow localhost with any port
    if (environment.server.isDevelopment && origin.includes('localhost')) {
      return callback(null, true);
    }
    
    logger.warn(`CORS blocked origin: ${origin}`);
    return callback(new Error(`Origin ${origin} not allowed by CORS policy`));
  },
  
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
  
  allowedHeaders: [
    'Origin',
    'X-Requested-With',
    'Content-Type',
    'Accept',
    'Authorization',
    'X-API-Key',
    'X-Client-Version',
    'X-Request-ID'
  ],
  
  exposedHeaders: [
    'X-Total-Count',
    'X-Page-Count',
    'X-Current-Page',
    'X-Per-Page',
    'X-Rate-Limit-Remaining',
    'X-Rate-Limit-Reset'
  ],
  
  credentials: true,
  
  // Preflight cache time
  maxAge: 86400, // 24 hours
  
  // Handle preflight for all routes
  preflightContinue: false,
  
  optionsSuccessStatus: 204
};

export const corsMiddleware = cors(corsOptions);
</file>

<file path="src/middleware/security/rateLimitMiddleware.ts">
import rateLimit from 'express-rate-limit';
import { Request, Response } from 'express';
import { environment } from '../../config/environment';
import { logger } from '../../utils/logger';

// Custom key generator for rate limiting
const keyGenerator = (req: Request): string => {
  // Use user ID if authenticated, otherwise use IP
  const userId = (req as any).user?.id;
  if (userId) {
    return `user:${userId}`;
  }
  
  // Get real IP address
  const forwarded = req.headers['x-forwarded-for'] as string;
  const ip = forwarded ? forwarded.split(',')[0].trim() : req.ip;
  return `ip:${ip}`;
};

// Custom skip function
const skipFunction = (req: Request): boolean => {
  // Skip rate limiting for health checks
  if (req.path === '/health') {
    return true;
  }
  
  // Skip for internal requests (if they have special header)
  if (req.headers['x-internal-request'] === 'true') {
    return true;
  }
  
  return false;
};

// Rate limit exceeded handler
const rateLimitHandler = (req: Request, res: Response) => {
  const identifier = keyGenerator(req);
  logger.warn(`Rate limit exceeded for ${identifier} on ${req.method} ${req.path}`, {
    identifier,
    path: req.path,
    method: req.method,
    userAgent: req.headers['user-agent'],
    ip: req.ip
  });

  res.status(429).json({
    error: {
      code: 'RATE_LIMIT_EXCEEDED',
      message: 'Too many requests, please try again later.',
      retryAfter: Math.ceil(environment.rateLimit.windowMs / 1000)
    }
  });
};

// Default rate limit configuration
export const rateLimitMiddleware = rateLimit({
  windowMs: environment.rateLimit.windowMs,
  max: environment.rateLimit.maxRequests,
  keyGenerator,
  skip: skipFunction,
  handler: rateLimitHandler,
  standardHeaders: true,
  legacyHeaders: false,
  message: {
    error: {
      code: 'RATE_LIMIT_EXCEEDED',
      message: 'Too many requests, please try again later.'
    }
  }
});

// Stricter rate limit for authentication endpoints
export const authRateLimitMiddleware = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts per window
  keyGenerator,
  skip: skipFunction,
  handler: (req: Request, res: Response) => {
    const identifier = keyGenerator(req);
    logger.warn(`Auth rate limit exceeded for ${identifier}`, {
      identifier,
      path: req.path,
      method: req.method,
      userAgent: req.headers['user-agent'],
      ip: req.ip
    });

    res.status(429).json({
      error: {
        code: 'AUTH_RATE_LIMIT_EXCEEDED',
        message: 'Too many authentication attempts. Please try again in 15 minutes.',
        retryAfter: 900 // 15 minutes
      }
    });
  },
  standardHeaders: true,
  legacyHeaders: false
});

// Rate limit for file uploads
export const uploadRateLimitMiddleware = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 10, // 10 uploads per hour
  keyGenerator,
  skip: skipFunction,
  handler: (req: Request, res: Response) => {
    const identifier = keyGenerator(req);
    logger.warn(`Upload rate limit exceeded for ${identifier}`, {
      identifier,
      path: req.path,
      method: req.method,
      userAgent: req.headers['user-agent'],
      ip: req.ip
    });

    res.status(429).json({
      error: {
        code: 'UPLOAD_RATE_LIMIT_EXCEEDED',
        message: 'Too many file uploads. Please try again in an hour.',
        retryAfter: 3600 // 1 hour
      }
    });
  },
  standardHeaders: true,
  legacyHeaders: false
});

// Rate limit for AI API requests
export const aiRateLimitMiddleware = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 20, // 20 AI requests per minute
  keyGenerator,
  skip: skipFunction,
  handler: (req: Request, res: Response) => {
    const identifier = keyGenerator(req);
    logger.warn(`AI rate limit exceeded for ${identifier}`, {
      identifier,
      path: req.path,
      method: req.method,
      userAgent: req.headers['user-agent'],
      ip: req.ip
    });

    res.status(429).json({
      error: {
        code: 'AI_RATE_LIMIT_EXCEEDED',
        message: 'AI service rate limit exceeded. Please try again in a minute.',
        retryAfter: 60
      }
    });
  },
  standardHeaders: true,
  legacyHeaders: false
});
</file>

<file path="src/middleware/security/securityMiddleware.ts">
import { Request, Response, NextFunction } from 'express';
import helmet from 'helmet';
import { environment } from '../../config/environment';

// Security middleware configuration
export const securityMiddleware = [
  // Basic security headers
  helmet({
    // Content Security Policy
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
        fontSrc: ["'self'", "https://fonts.gstatic.com"],
        imgSrc: ["'self'", "data:", "https:", "blob:"],
        scriptSrc: environment.server.isDevelopment 
          ? ["'self'", "'unsafe-inline'", "'unsafe-eval'"] 
          : ["'self'"],
        connectSrc: ["'self'", "https:", "wss:", "ws:"],
        mediaSrc: ["'self'", "blob:", "https:"],
        objectSrc: ["'none'"],
        frameSrc: ["'none'"],
        baseUri: ["'self'"],
        formAction: ["'self'"],
        upgradeInsecureRequests: environment.server.isProduction ? [] : null
      }
    },
    
    // Cross Origin Embedder Policy
    crossOriginEmbedderPolicy: false,
    
    // DNS Prefetch Control
    dnsPrefetchControl: {
      allow: false
    },
    
    // Frameguard (X-Frame-Options)
    frameguard: {
      action: 'deny'
    },
    
    // Hide Powered-By header
    hidePoweredBy: true,
    
    // HTTP Strict Transport Security
    hsts: {
      maxAge: 31536000, // 1 year
      includeSubDomains: true,
      preload: true
    },
    
    // IE No Open
    ieNoOpen: true,
    
    // Don't Sniff Mimetype
    noSniff: true,
    
    // Origin Agent Cluster
    originAgentCluster: true,
    
    // Permitted Cross Domain Policies
    permittedCrossDomainPolicies: false,
    
    // Referrer Policy
    referrerPolicy: {
      policy: ['no-referrer', 'strict-origin-when-cross-origin']
    },
    
    // X-XSS-Protection
    xssFilter: true
  }),

  // Custom security headers
  (req: Request, res: Response, next: NextFunction) => {
    // Remove server information
    res.removeHeader('X-Powered-By');
    res.removeHeader('Server');
    
    // Add custom security headers
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('X-Permitted-Cross-Domain-Policies', 'none');
    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
    
    // Add request ID for tracking
    if (!req.headers['x-request-id']) {
      req.headers['x-request-id'] = generateRequestId();
    }
    
    res.setHeader('X-Request-ID', req.headers['x-request-id'] as string);
    
    next();
  }
];

// Generate unique request ID
function generateRequestId(): string {
  return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
</file>

<file path="src/middleware/upload/videoUploadMiddleware.ts">
import multer from 'multer'
import path from 'path'
import fs from 'fs/promises'
import { Request } from 'express'
import { v4 as uuidv4 } from 'uuid'

// Supported video formats
const SUPPORTED_VIDEO_TYPES = [
  'video/mp4',
  'video/avi',
  'video/mov',
  'video/wmv',
  'video/flv',
  'video/webm'
]

// Maximum file size (500MB)
const MAX_FILE_SIZE = 500 * 1024 * 1024

// Video upload directory
const UPLOAD_DIR = path.join(process.cwd(), 'uploads', 'videos')
const THUMBNAIL_DIR = path.join(process.cwd(), 'uploads', 'thumbnails')

// Ensure upload directories exist
const ensureUploadDirectories = async () => {
  try {
    await fs.access(UPLOAD_DIR)
  } catch {
    await fs.mkdir(UPLOAD_DIR, { recursive: true })
  }
  
  try {
    await fs.access(THUMBNAIL_DIR)
  } catch {
    await fs.mkdir(THUMBNAIL_DIR, { recursive: true })
  }
}

// Initialize directories on module load
ensureUploadDirectories().catch(console.error)

// Multer storage configuration for videos
const storage = multer.diskStorage({
  destination: async (_req, _file, cb) => {
    try {
      await ensureUploadDirectories()
      cb(null, UPLOAD_DIR)
    } catch (error) {
      cb(error as Error | null, '')
    }
  },
  filename: (_req, file, cb) => {
    // Generate unique filename with original extension
    const uniqueSuffix = uuidv4()
    const fileExtension = path.extname(file.originalname)
    const fileName = `${uniqueSuffix}${fileExtension}`
    cb(null, fileName)
  }
})

// File filter for videos only
const fileFilter = (_req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  if (SUPPORTED_VIDEO_TYPES.includes(file.mimetype)) {
    cb(null, true)
  } else {
    cb(new Error(`Unsupported file type. Supported types: ${SUPPORTED_VIDEO_TYPES.join(', ')}`))
  }
}

// Multer configuration
const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: MAX_FILE_SIZE,
    files: 1 // Only one video file at a time
  }
})

// Middleware for single video upload
export const uploadVideoMiddleware = upload.single('video')

// Middleware for handling multer errors
export const handleUploadErrors = (error: any, _req: Request, res: any, next: any) => {
  if (error instanceof multer.MulterError) {
    switch (error.code) {
      case 'LIMIT_FILE_SIZE':
        return res.status(400).json({
          success: false,
          error: 'File too large. Maximum size is 500MB.'
        })
      case 'LIMIT_UNEXPECTED_FILE':
        return res.status(400).json({
          success: false,
          error: 'Unexpected field name. Use "video" field for video upload.'
        })
      default:
        return res.status(400).json({
          success: false,
          error: `Upload error: ${error.message}`
        })
    }
  }
  
  if (error.message.includes('Unsupported file type')) {
    return res.status(400).json({
      success: false,
      error: error.message
    })
  }
  
  next(error)
}

// Utility function to get video file path
export const getVideoFilePath = (filename: string): string => {
  return path.join(UPLOAD_DIR, filename)
}

// Utility function to get thumbnail file path
export const getThumbnailFilePath = (filename: string): string => {
  return path.join(THUMBNAIL_DIR, filename)
}

// Utility function to delete video file
export const deleteVideoFile = async (filename: string): Promise<void> => {
  try {
    const filePath = getVideoFilePath(filename)
    await fs.unlink(filePath)
  } catch (error) {
    console.error('Error deleting video file:', error)
  }
}

// Utility function to delete thumbnail file
export const deleteThumbnailFile = async (filename: string): Promise<void> => {
  try {
    const filePath = getThumbnailFilePath(filename)
    await fs.unlink(filePath)
  } catch (error) {
    console.error('Error deleting thumbnail file:', error)
  }
}

export { UPLOAD_DIR, THUMBNAIL_DIR, SUPPORTED_VIDEO_TYPES, MAX_FILE_SIZE }
</file>

<file path="src/middleware/validation/validateRequest.ts">
import { Request, Response, NextFunction } from 'express';
import { validationResult } from 'express-validator';
import { logger } from '../../utils/logger';

export const validateRequest = (req: Request, res: Response, next: NextFunction) => {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    const errorMessages = errors.array().map(error => ({
      field: error.type === 'field' ? error.path : 'unknown',
      message: error.msg,
      value: error.type === 'field' ? error.value : undefined
    }));

    logger.warn('Validation failed:', {
      path: req.path,
      method: req.method,
      errors: errorMessages,
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: 'Validation failed',
      details: errorMessages
    });
    return;
  }

  next();
};
</file>

<file path="src/services/__tests__/user.service.test.ts">
import bcrypt from 'bcrypt';
import { UserService } from '../user.service';
import { getTestPrismaClient, setupTestDatabase, cleanupDatabase } from '../../../tests/utils/database';
import { User, UserRole, UserStatus } from '@prisma/client';

describe('UserService', () => {
  let userService: UserService;
  let prisma: ReturnType<typeof getTestPrismaClient>;

  beforeAll(async () => {
    await setupTestDatabase();
    prisma = getTestPrismaClient();
  });

  beforeEach(async () => {
    await cleanupDatabase();
    userService = new UserService();
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  describe('createUser', () => {
    const validUserData = {
      email: 'newuser@example.com',
      password: 'SecurePassword123!',
      firstName: 'John',
      lastName: 'Doe',
      role: 'STUDENT' as UserRole
    };

    it('should create a new user with valid data', async () => {
      const user = await userService.createUser(validUserData);

      expect(user).toBeDefined();
      expect(user.id).toBeTruthy();
      expect(user.email).toBe(validUserData.email);
      expect(user.firstName).toBe(validUserData.firstName);
      expect(user.lastName).toBe(validUserData.lastName);
      expect(user.role).toBe(validUserData.role);
      expect(user.status).toBe('ACTIVE');
    });

    it('should hash the password before storing', async () => {
      const user = await userService.createUser(validUserData);
      
      const dbUser = await prisma.user.findUnique({
        where: { id: user.id }
      });

      expect(dbUser?.passwordHash).toBeTruthy();
      expect(dbUser?.passwordHash).not.toBe(validUserData.password);
      
      const isValidPassword = await bcrypt.compare(
        validUserData.password,
        dbUser!.passwordHash
      );
      expect(isValidPassword).toBe(true);
    });

    it('should throw error when creating user with duplicate email', async () => {
      await userService.createUser(validUserData);
      
      await expect(userService.createUser(validUserData))
        .rejects
        .toThrow('already exists');
    });

    it('should create user preferences automatically', async () => {
      const user = await userService.createUser(validUserData);
      
      const preferences = await prisma.userPreference.findUnique({
        where: { userId: user.id }
      });

      expect(preferences).toBeDefined();
      expect(preferences?.userId).toBe(user.id);
      expect(preferences?.theme).toBe('light');
      expect(preferences?.language).toBe('en');
    });

    it('should validate email format', async () => {
      const invalidData = {
        ...validUserData,
        email: 'invalid-email'
      };

      await expect(userService.createUser(invalidData))
        .rejects
        .toThrow('Invalid email');
    });

    it('should validate password strength', async () => {
      const weakPasswordData = {
        ...validUserData,
        password: '12345'
      };

      await expect(userService.createUser(weakPasswordData))
        .rejects
        .toThrow('Password must be at least');
    });

    it('should sanitize input data', async () => {
      const unsafeData = {
        ...validUserData,
        firstName: '  John  ',
        lastName: '  Doe  ',
        email: '  NewUser@Example.Com  '
      };

      const user = await userService.createUser(unsafeData);
      
      expect(user.firstName).toBe('John');
      expect(user.lastName).toBe('Doe');
      expect(user.email).toBe('newuser@example.com');
    });
  });

  describe('getUserById', () => {
    let testUser: User;

    beforeEach(async () => {
      testUser = await prisma.user.create({
        data: {
          email: 'getuser@example.com',
          firstName: 'Get',
          lastName: 'User',
          role: 'STUDENT',
          status: 'ACTIVE',
          passwordHash: await bcrypt.hash('Password123!', 10)
        }
      });
    });

    it('should retrieve user by valid ID', async () => {
      const user = await userService.getUserById(testUser.id);

      expect(user).toBeDefined();
      expect(user?.id).toBe(testUser.id);
      expect(user?.email).toBe(testUser.email);
    });

    it('should return null for non-existent ID', async () => {
      const user = await userService.getUserById('non-existent-id');
      expect(user).toBeNull();
    });

    it('should not include password hash in response', async () => {
      const user = await userService.getUserById(testUser.id);
      expect(user).not.toHaveProperty('passwordHash');
    });

    it('should include user preferences if requested', async () => {
      await prisma.userPreference.create({
        data: {
          userId: testUser.id,
          theme: 'dark',
          language: 'en'
        }
      });

      const user = await userService.getUserById(testUser.id, {
        includePreferences: true
      });

      expect(user?.preferences).toBeDefined();
      expect(user?.preferences?.theme).toBe('dark');
    });
  });

  describe('getUserByEmail', () => {
    let testUser: User;

    beforeEach(async () => {
      testUser = await prisma.user.create({
        data: {
          email: 'finduser@example.com',
          firstName: 'Find',
          lastName: 'User',
          role: 'TEACHER',
          status: 'ACTIVE',
          passwordHash: await bcrypt.hash('Password123!', 10)
        }
      });
    });

    it('should retrieve user by email', async () => {
      const user = await userService.getUserByEmail(testUser.email);

      expect(user).toBeDefined();
      expect(user?.id).toBe(testUser.id);
      expect(user?.email).toBe(testUser.email);
    });

    it('should be case-insensitive for email', async () => {
      const user = await userService.getUserByEmail('FindUser@Example.Com');
      
      expect(user).toBeDefined();
      expect(user?.id).toBe(testUser.id);
    });

    it('should return null for non-existent email', async () => {
      const user = await userService.getUserByEmail('nonexistent@example.com');
      expect(user).toBeNull();
    });
  });

  describe('updateUser', () => {
    let testUser: User;

    beforeEach(async () => {
      testUser = await prisma.user.create({
        data: {
          email: 'updateuser@example.com',
          firstName: 'Update',
          lastName: 'User',
          role: 'STUDENT',
          status: 'ACTIVE',
          passwordHash: await bcrypt.hash('Password123!', 10)
        }
      });
    });

    it('should update user profile information', async () => {
      const updates = {
        firstName: 'Updated',
        lastName: 'Name',
        bio: 'New bio text'
      };

      const updatedUser = await userService.updateUser(testUser.id, updates);

      expect(updatedUser.firstName).toBe(updates.firstName);
      expect(updatedUser.lastName).toBe(updates.lastName);
      expect(updatedUser.bio).toBe(updates.bio);
    });

    it('should not allow email update through regular update', async () => {
      const updates = {
        email: 'newemail@example.com'
      };

      const updatedUser = await userService.updateUser(testUser.id, updates);
      expect(updatedUser.email).toBe(testUser.email);
    });

    it('should update password with proper hashing', async () => {
      const newPassword = 'NewSecurePassword123!';
      
      const updatedUser = await userService.updateUser(testUser.id, {
        password: newPassword
      });

      const dbUser = await prisma.user.findUnique({
        where: { id: testUser.id }
      });

      const isValidPassword = await bcrypt.compare(
        newPassword,
        dbUser!.passwordHash
      );
      expect(isValidPassword).toBe(true);
    });

    it('should throw error for non-existent user', async () => {
      await expect(
        userService.updateUser('non-existent-id', { firstName: 'Test' })
      ).rejects.toThrow('User not found');
    });

    it('should track updatedAt timestamp', async () => {
      const originalUser = await prisma.user.findUnique({
        where: { id: testUser.id }
      });
      
      // Wait a bit to ensure timestamp difference
      await new Promise(resolve => setTimeout(resolve, 10));
      
      await userService.updateUser(testUser.id, { firstName: 'Updated' });
      
      const updatedUser = await prisma.user.findUnique({
        where: { id: testUser.id }
      });

      expect(updatedUser!.updatedAt.getTime()).toBeGreaterThan(
        originalUser!.updatedAt.getTime()
      );
    });
  });

  describe('deleteUser', () => {
    let testUser: User;

    beforeEach(async () => {
      testUser = await prisma.user.create({
        data: {
          email: 'deleteuser@example.com',
          firstName: 'Delete',
          lastName: 'User',
          role: 'STUDENT',
          status: 'ACTIVE',
          passwordHash: await bcrypt.hash('Password123!', 10)
        }
      });
    });

    it('should soft delete user by default', async () => {
      await userService.deleteUser(testUser.id);

      const user = await prisma.user.findUnique({
        where: { id: testUser.id }
      });

      expect(user).toBeDefined();
      expect(user?.status).toBe('DELETED');
      expect(user?.deletedAt).toBeTruthy();
    });

    it('should hard delete user when specified', async () => {
      await userService.deleteUser(testUser.id, { hardDelete: true });

      const user = await prisma.user.findUnique({
        where: { id: testUser.id }
      });

      expect(user).toBeNull();
    });

    it('should cascade delete related data on hard delete', async () => {
      // Create related data
      await prisma.userPreference.create({
        data: { userId: testUser.id }
      });

      await userService.deleteUser(testUser.id, { hardDelete: true });

      const preferences = await prisma.userPreference.findUnique({
        where: { userId: testUser.id }
      });

      expect(preferences).toBeNull();
    });

    it('should throw error for non-existent user', async () => {
      await expect(
        userService.deleteUser('non-existent-id')
      ).rejects.toThrow('User not found');
    });
  });

  describe('validateCredentials', () => {
    let testUser: User;
    const password = 'ValidPassword123!';

    beforeEach(async () => {
      testUser = await prisma.user.create({
        data: {
          email: 'validate@example.com',
          firstName: 'Validate',
          lastName: 'User',
          role: 'STUDENT',
          status: 'ACTIVE',
          passwordHash: await bcrypt.hash(password, 10),
          emailVerified: new Date()
        }
      });
    });

    it('should validate correct credentials', async () => {
      const isValid = await userService.validateCredentials(
        testUser.email,
        password
      );

      expect(isValid).toBe(true);
    });

    it('should reject incorrect password', async () => {
      const isValid = await userService.validateCredentials(
        testUser.email,
        'WrongPassword123!'
      );

      expect(isValid).toBe(false);
    });

    it('should reject non-existent email', async () => {
      const isValid = await userService.validateCredentials(
        'nonexistent@example.com',
        password
      );

      expect(isValid).toBe(false);
    });

    it('should reject inactive user', async () => {
      await prisma.user.update({
        where: { id: testUser.id },
        data: { status: 'INACTIVE' }
      });

      const isValid = await userService.validateCredentials(
        testUser.email,
        password
      );

      expect(isValid).toBe(false);
    });

    it('should reject unverified email', async () => {
      await prisma.user.update({
        where: { id: testUser.id },
        data: { emailVerified: null }
      });

      const isValid = await userService.validateCredentials(
        testUser.email,
        password
      );

      expect(isValid).toBe(false);
    });
  });

  describe('getUsersByRole', () => {
    beforeEach(async () => {
      // Create multiple users with different roles
      await prisma.user.createMany({
        data: [
          {
            email: 'student1@example.com',
            firstName: 'Student',
            lastName: 'One',
            role: 'STUDENT',
            status: 'ACTIVE',
            passwordHash: await bcrypt.hash('Password123!', 10)
          },
          {
            email: 'student2@example.com',
            firstName: 'Student',
            lastName: 'Two',
            role: 'STUDENT',
            status: 'ACTIVE',
            passwordHash: await bcrypt.hash('Password123!', 10)
          },
          {
            email: 'teacher1@example.com',
            firstName: 'Teacher',
            lastName: 'One',
            role: 'TEACHER',
            status: 'ACTIVE',
            passwordHash: await bcrypt.hash('Password123!', 10)
          }
        ]
      });
    });

    it('should retrieve all users with specific role', async () => {
      const students = await userService.getUsersByRole('STUDENT');

      expect(students).toHaveLength(2);
      expect(students.every(u => u.role === 'STUDENT')).toBe(true);
    });

    it('should support pagination', async () => {
      const firstPage = await userService.getUsersByRole('STUDENT', {
        skip: 0,
        take: 1
      });

      expect(firstPage).toHaveLength(1);

      const secondPage = await userService.getUsersByRole('STUDENT', {
        skip: 1,
        take: 1
      });

      expect(secondPage).toHaveLength(1);
      expect(firstPage[0].id).not.toBe(secondPage[0].id);
    });

    it('should filter by status', async () => {
      await prisma.user.update({
        where: { email: 'student1@example.com' },
        data: { status: 'INACTIVE' }
      });

      const activeStudents = await userService.getUsersByRole('STUDENT', {
        status: 'ACTIVE'
      });

      expect(activeStudents).toHaveLength(1);
      expect(activeStudents[0].email).toBe('student2@example.com');
    });
  });
});
</file>

<file path="src/services/auth/authService.ts">
import bcrypt from 'bcrypt';
import { prisma } from '@/config/database';
import { config } from '@/config/environment';
import { jwtService } from './jwtService';
import { AppError, AuthenticatedUser } from '@/types';
import { UserRole, UserStatus } from '@prisma/client';
import { logger } from '@/utils/logger';

export interface RegisterData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  username?: string;
  role?: UserRole;
  tenantId?: string;
}

export interface LoginData {
  email: string;
  password: string;
}

export interface AuthResult {
  user: AuthenticatedUser;
  accessToken: string;
  refreshToken: string;
}

class AuthService {
  /**
   * Register a new user
   */
  async register(data: RegisterData): Promise<AuthResult> {
    const { email, password, firstName, lastName, username, role = UserRole.STUDENT, tenantId } = data;

    // Check if user already exists
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [
          { email },
          ...(username ? [{ username }] : []),
        ],
      },
    });

    if (existingUser) {
      if (existingUser.email === email) {
        throw new AppError('Email already registered', 409);
      }
      if (existingUser.username === username) {
        throw new AppError('Username already taken', 409);
      }
    }

    // Hash password
    const passwordHash = await this.hashPassword(password);

    // Create user
    const user = await prisma.user.create({
      data: {
        email,
        passwordHash,
        firstName,
        lastName,
        username,
        role,
        tenantId,
        status: UserStatus.PENDING_VERIFICATION,
      },
    });

    const authenticatedUser: AuthenticatedUser = {
      id: user.id,
      email: user.email,
      role: user.role,
      status: user.status,
      tenantId: user.tenantId || undefined,
    };

    // Generate tokens
    const { accessToken, refreshToken } = jwtService.generateTokenPair(authenticatedUser);

    logger.info(`User registered: ${user.email}`);

    return {
      user: authenticatedUser,
      accessToken,
      refreshToken,
    };
  }

  /**
   * Login user
   */
  async login(data: LoginData): Promise<AuthResult> {
    const { email, password } = data;

    // Find user
    const user = await prisma.user.findUnique({
      where: { email },
    });

    if (!user) {
      throw new AppError('Invalid credentials', 401);
    }

    // Check password
    const isValidPassword = await this.comparePassword(password, user.passwordHash);
    if (!isValidPassword) {
      throw new AppError('Invalid credentials', 401);
    }

    // Check user status
    if (user.status === UserStatus.SUSPENDED) {
      throw new AppError('Account suspended', 403);
    }

    if (user.status === UserStatus.INACTIVE) {
      throw new AppError('Account inactive', 403);
    }

    // Update last login
    await prisma.user.update({
      where: { id: user.id },
      data: { lastLoginAt: new Date() },
    });

    const authenticatedUser: AuthenticatedUser = {
      id: user.id,
      email: user.email,
      role: user.role,
      status: user.status,
      tenantId: user.tenantId || undefined,
    };

    // Generate tokens
    const { accessToken, refreshToken } = jwtService.generateTokenPair(authenticatedUser);

    logger.info(`User logged in: ${user.email}`);

    return {
      user: authenticatedUser,
      accessToken,
      refreshToken,
    };
  }

  /**
   * Refresh access token
   */
  async refreshToken(refreshToken: string): Promise<AuthResult> {
    // Verify refresh token
    const payload = jwtService.verifyRefreshToken(refreshToken);

    // Find user
    const user = await prisma.user.findUnique({
      where: { id: payload.userId },
    });

    if (!user) {
      throw new AppError('User not found', 404);
    }

    // Check user status
    if (user.status === UserStatus.SUSPENDED || user.status === UserStatus.INACTIVE) {
      throw new AppError('Account not active', 403);
    }

    const authenticatedUser: AuthenticatedUser = {
      id: user.id,
      email: user.email,
      role: user.role,
      status: user.status,
      tenantId: user.tenantId || undefined,
    };

    // Generate new tokens
    const { accessToken, refreshToken: newRefreshToken } = jwtService.generateTokenPair(authenticatedUser);

    return {
      user: authenticatedUser,
      accessToken,
      refreshToken: newRefreshToken,
    };
  }

  /**
   * Get user by ID
   */
  async getUserById(userId: string): Promise<AuthenticatedUser | null> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
    });

    if (!user) return null;

    return {
      id: user.id,
      email: user.email,
      role: user.role,
      status: user.status,
      tenantId: user.tenantId || undefined,
    };
  }

  /**
   * Verify email
   */
  async verifyEmail(userId: string): Promise<void> {
    await prisma.user.update({
      where: { id: userId },
      data: {
        emailVerified: new Date(),
        status: UserStatus.ACTIVE,
      },
    });

    logger.info(`Email verified for user: ${userId}`);
  }

  /**
   * Change password
   */
  async changePassword(userId: string, currentPassword: string, newPassword: string): Promise<void> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
    });

    if (!user) {
      throw new AppError('User not found', 404);
    }

    // Verify current password
    const isValidPassword = await this.comparePassword(currentPassword, user.passwordHash);
    if (!isValidPassword) {
      throw new AppError('Current password is incorrect', 400);
    }

    // Hash new password
    const newPasswordHash = await this.hashPassword(newPassword);

    // Update password
    await prisma.user.update({
      where: { id: userId },
      data: { passwordHash: newPasswordHash },
    });

    logger.info(`Password changed for user: ${userId}`);
  }

  /**
   * Reset password
   */
  async resetPassword(email: string, newPassword: string): Promise<void> {
    const passwordHash = await this.hashPassword(newPassword);

    const user = await prisma.user.update({
      where: { email },
      data: { passwordHash },
    });

    logger.info(`Password reset for user: ${user.id}`);
  }

  /**
   * Hash password
   */
  private async hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, config.security.bcryptSaltRounds);
  }

  /**
   * Compare password
   */
  private async comparePassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }

  /**
   * Logout (for audit purposes)
   */
  async logout(userId: string): Promise<void> {
    logger.info(`User logged out: ${userId}`);
    // In a more advanced implementation, you might maintain a blacklist of tokens
  }
}

export const authService = new AuthService();
export default authService;
</file>

<file path="src/types/auth.ts">
import { UserRole } from '@prisma/client';

export interface User {
  id: string;
  email: string;
  username?: string;
  firstName: string;
  lastName: string;
  avatar?: string;
  role: UserRole;
  tenantId?: string;
  status: string;
  lastLoginAt?: Date;
  emailVerified?: Date;
  createdAt: Date;
}

export interface AuthenticatedUser extends User {}

export interface AuthContext {
  user: AuthenticatedUser;
  isAuthenticated: boolean;
}
</file>

<file path="src/types/index.ts">
import { Request } from 'express';
import { UserRole, UserStatus } from '@prisma/client';

// Authentication types
export interface AuthenticatedUser {
  id: string;
  email: string;
  role: UserRole;
  status: UserStatus;
  tenantId?: string;
}

export interface AuthenticatedRequest extends Request {
  user?: AuthenticatedUser;
}

// JWT Payload
export interface JWTPayload {
  userId: string;
  email: string;
  role: UserRole;
  tenantId?: string;
  iat?: number;
  exp?: number;
}

// API Response types
export interface APIResponse<T = any> {
  success: boolean;
  message: string;
  data?: T;
  errors?: string[];
  pagination?: PaginationInfo;
}

export interface PaginationInfo {
  page: number;
  limit: number;
  total: number;
  totalPages: number;
  hasNext: boolean;
  hasPrev: boolean;
}

export interface PaginationQuery {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

// Video processing types
export interface VideoUploadMetadata {
  originalName: string;
  size: number;
  mimeType: string;
  duration?: number;
}

export interface VideoProcessingJob {
  videoId: string;
  gcsPath: string;
  metadata: VideoUploadMetadata;
}

// AI Provider types
export interface AIProvider {
  name: string;
  generateQuestion(prompt: string, context: QuestionGenerationContext): Promise<GeneratedQuestion>;
  validateConfiguration(): Promise<boolean>;
}

export interface QuestionGenerationContext {
  lessonTitle: string;
  videoTitle: string;
  milestoneDescription: string;
  difficulty: string;
  questionType: string;
  existingQuestions?: string[];
}

export interface GeneratedQuestion {
  text: string;
  type: string;
  questionData: any;
  explanation?: string;
  hints?: string[];
  confidence: number;
  metadata?: any;
}

// Session management types
export interface SessionData {
  id: string;
  userId: string;
  videoId: string;
  currentPosition: number;
  lastMilestoneId?: string;
  completedMilestones: string[];
  deviceInfo?: any;
  lastSeenAt: Date;
}

// Analytics types
export interface AnalyticsEvent {
  type: string;
  userId?: string;
  sessionId?: string;
  data: any;
  context?: any;
  timestamp: Date;
}

// Progress tracking types
export interface ProgressUpdate {
  studentId: string;
  lessonId: string;
  videoId?: string;
  milestoneId?: string;
  completionPercent: number;
  timeSpent: number;
  score?: number;
}

// Error types
export class AppError extends Error {
  public statusCode: number;
  public isOperational: boolean;
  public code?: string;

  constructor(message: string, statusCode: number = 500, isOperational: boolean = true) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.name = this.constructor.name;
    
    Error.captureStackTrace(this, this.constructor);
  }
}

// Rate limiting types
export interface RateLimitConfig {
  windowMs: number;
  maxRequests: number;
  message?: string;
  standardHeaders?: boolean;
  legacyHeaders?: boolean;
}

// File upload types
export interface FileUploadConfig {
  maxSize: number;
  allowedTypes: string[];
  destination: string;
}

// Database transaction types
export type TransactionCallback<T> = (tx: any) => Promise<T>;

// Validation types
export interface ValidationError {
  field: string;
  message: string;
  code: string;
}

export interface ValidatedRequest<T = any> extends Request {
  validatedData?: T;
}

// Search and filter types
export interface SearchFilters {
  query?: string;
  status?: string[];
  role?: UserRole[];
  dateFrom?: Date;
  dateTo?: Date;
  tags?: string[];
  difficulty?: string[];
}

// Audit log types
export interface AuditLogData {
  action: string;
  resource: string;
  resourceId?: string;
  changes?: any;
  metadata?: any;
  ipAddress?: string;
  userAgent?: string;
}

// Cache types
export interface CacheOptions {
  ttl?: number;
  prefix?: string;
}

// Email types
export interface EmailOptions {
  to: string | string[];
  subject: string;
  text?: string;
  html?: string;
  attachments?: any[];
}

// Configuration types
export interface SystemConfiguration {
  key: string;
  value: any;
  description?: string;
  category?: string;
  isPublic?: boolean;
}
</file>

<file path="src/utils/logger.ts">
import winston from 'winston';
import { config } from '@/config/environment';

// Define log levels
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

// Define log colors
const colors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  http: 'magenta',
  debug: 'white',
};

winston.addColors(colors);

// Define log format
const format = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
  winston.format.colorize({ all: true }),
  winston.format.printf(
    (info) => `${info.timestamp} ${info.level}: ${info.message}`
  )
);

// Define transports
const transports: winston.transport[] = [
  new winston.transports.Console(),
];

// Add file transport in production
if (config.server.isProduction) {
  transports.push(
    new winston.transports.File({
      filename: config.logging.file,
      level: 'error',
    }),
    new winston.transports.File({
      filename: 'logs/all.log',
    })
  );
}

// Create logger
const logger = winston.createLogger({
  level: config.server.isDevelopment ? 'debug' : config.logging.level,
  levels,
  format,
  transports,
});

export { logger };
export default logger;
</file>

<file path="src/utils/validators.ts">
/**
 * Custom validators for the Interactive Learning Platform
 * Handles CUID format validation since database uses CUID instead of UUID
 */

import { ValidationChain, CustomValidator } from 'express-validator';
import { param, body, query } from 'express-validator';

/**
 * CUID format validation
 * CUID pattern: starts with 'c' followed by 24 lowercase alphanumeric characters
 * Example: c123456789012345678901234
 */
const CUID_PATTERN = /^c[a-z0-9]{24}$/;

/**
 * Custom validator to check if value matches CUID format
 */
export const isCUID: CustomValidator = (value: string) => {
  if (!value || typeof value !== 'string') {
    throw new Error('Value must be a string');
  }
  
  if (!CUID_PATTERN.test(value)) {
    throw new Error('Invalid CUID format');
  }
  
  return true;
};

/**
 * Validation chain for CUID parameters
 */
export const validateCUIDParam = (paramName: string, message?: string): ValidationChain => {
  return param(paramName).custom(isCUID).withMessage(message || `Invalid ${paramName}`);
};

/**
 * Validation chain for CUID body fields
 */
export const validateCUIDBody = (fieldName: string, message?: string): ValidationChain => {
  return body(fieldName).custom(isCUID).withMessage(message || `Valid ${fieldName} is required`);
};

/**
 * Validation chain for optional CUID query parameters
 */
export const validateCUIDQuery = (queryName: string, message?: string): ValidationChain => {
  return query(queryName).optional().custom(isCUID).withMessage(message || `Invalid ${queryName}`);
};

/**
 * Helper function to validate CUID string directly
 * Useful for programmatic validation outside of express-validator
 */
export const isValidCUID = (value: string): boolean => {
  return typeof value === 'string' && CUID_PATTERN.test(value);
};
</file>

<file path="tests/cases/test_answer_submit.sh">
#!/bin/bash

# Login as teacher
LOGIN_RESPONSE=$(curl -s -X POST http://localhost:3000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "teacher@example.com", "password": "password123"}')

TOKEN=$(echo $LOGIN_RESPONSE | jq -r '.data.tokens.accessToken')

if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
  echo "Failed to login"
  echo $LOGIN_RESPONSE | jq '.'
  exit 1
fi

echo "Logged in successfully"
VIDEO_ID="cme1aawsy0003l43s6nffdodu"
MILESTONE_ID="cme1km61t0001l6lftzpj8yqo"
QUESTION_ID="cme1kusax0003l6lfv66h1saw"

# Start a session first
echo "Starting session..."
SESSION_RESPONSE=$(curl -s -X POST http://localhost:3000/api/v1/sessions/start \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d "{\"videoId\": \"$VIDEO_ID\"}")

SESSION_ID=$(echo $SESSION_RESPONSE | jq -r '.data.id')
echo "Session ID: $SESSION_ID"

if [ -z "$SESSION_ID" ] || [ "$SESSION_ID" = "null" ]; then
  echo "Failed to start session"
  echo $SESSION_RESPONSE | jq '.'
  exit 1
fi

# Submit answer - testing with index 1 (which should be "ho" - the correct answer)
echo -e "\nSubmitting answer with index 1..."
ANSWER_RESPONSE=$(curl -s -X POST "http://localhost:3000/api/v1/sessions/$SESSION_ID/question" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d "{
    \"questionId\": \"$QUESTION_ID\",
    \"answer\": \"1\",
    \"milestoneId\": \"$MILESTONE_ID\"
  }")

echo "Answer response:"
echo $ANSWER_RESPONSE | jq '.'

# Also test with index 0 (which should be incorrect)
echo -e "\nSubmitting answer with index 0..."
ANSWER_RESPONSE_2=$(curl -s -X POST "http://localhost:3000/api/v1/sessions/$SESSION_ID/question" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d "{
    \"questionId\": \"$QUESTION_ID\",
    \"answer\": \"0\",
    \"milestoneId\": \"$MILESTONE_ID\"
  }")

echo "Answer response 2:"
echo $ANSWER_RESPONSE_2 | jq '.'
</file>

<file path="tests/cases/test_api_video.sh">
#!/bin/bash

# Login first to get token
echo "Logging in..."
LOGIN_RESPONSE=$(curl -s -X POST http://localhost:3000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "teacher@example.com",
    "password": "password123"
  }')

TOKEN=$(echo $LOGIN_RESPONSE | grep -o '"accessToken":"[^"]*' | cut -d'"' -f4)

if [ -z "$TOKEN" ]; then
  echo "Failed to get token. Login response:"
  echo $LOGIN_RESPONSE
  exit 1
fi

echo "Token obtained successfully"

# Get video groups
echo -e "\nFetching video groups..."
GROUPS_RESPONSE=$(curl -s -X GET http://localhost:3000/api/v1/videos \
  -H "Authorization: Bearer $TOKEN")

echo "Video groups response:"
echo $GROUPS_RESPONSE | jq '.'

# Extract first video ID if available
VIDEO_ID=$(echo $GROUPS_RESPONSE | jq -r '.data[] | select(.videos | length > 0) | .videos[0].id' | head -1)

if [ -z "$VIDEO_ID" ]; then
  echo "No video found in the response"
  exit 1
fi

echo -e "\nFetching video details for ID: $VIDEO_ID"
VIDEO_RESPONSE=$(curl -s -X GET "http://localhost:3000/api/v1/videos/$VIDEO_ID" \
  -H "Authorization: Bearer $TOKEN")

echo "Video details:"
echo $VIDEO_RESPONSE | jq '.data.milestones'

# Count questions
QUESTION_COUNT=$(echo $VIDEO_RESPONSE | jq '[.data.milestones[]?.questions? // [] | length] | add // 0')
echo -e "\nTotal questions across all milestones: $QUESTION_COUNT"

# Show milestones with questions
echo -e "\nMilestones with questions:"
echo $VIDEO_RESPONSE | jq '.data.milestones[] | select(.questions != null and (.questions | length) > 0) | {id: .id, title: .title, type: .type, questionsCount: (.questions | length), questions: .questions}'
</file>

<file path="tests/cases/test_invalid_lesson.json">
{"title": "", "description": "A" * 3000}
</file>

<file path="tests/cases/test_invalid_lesson2.json">
{"title": "", "description": "This description is way too long and should be rejected by the validation layer because it exceeds the maximum character limit that was set in the validation rules and this is intentionally very long to trigger that validation error and see how the system handles it properly or not."}
</file>

<file path="tests/cases/test_invalid_login.json">
{"email": "invalid@example.com", "password": "wrongpassword"}
</file>

<file path="tests/cases/test_lesson.json">
{
  "title": "Test Physics Lesson",
  "description": "A test lesson for Phase 1 testing",
  "objectives": ["Learn basic physics concepts", "Understand motion"],
  "estimatedTime": 30,
  "difficulty": "beginner",
  "tags": ["physics", "science"]
}
</file>

<file path="tests/cases/test_lesson2.json">
{
  "title": "Test Physics Lesson 2",
  "description": "A second test lesson for Phase 1 testing",
  "objectives": ["Learn more physics concepts"],
  "estimatedTime": 25,
  "difficulty": "beginner"
}
</file>

<file path="tests/cases/test_login.json">
{"email": "teacher@example.com", "password": "Demo123!"}
</file>

<file path="tests/cases/test_student_login.json">
{"email": "student@example.com", "password": "Demo123!"}
</file>

<file path="tests/cases/test_video_group.json">
{
  "title": "Test Video Group",
  "description": "Test video group for physics lesson",
  "lessonId": "cme172mq10001al4s4f7hz9yw"
}
</file>

<file path="tests/cases/test_video_group2.json">
{
  "title": "Test Video Group 2",
  "description": "Test video group for physics lesson 2",
  "lessonId": "cme173t240003al4skk6kb20v"
}
</file>

<file path="tests/factories/index.ts">
import { User, UserRole, UserStatus, Lesson, LessonStatus, Video, VideoStatus, Milestone, MilestoneType, Question, QuestionType, AIProvider } from '@prisma/client';
import bcrypt from 'bcrypt';
import { v4 as uuidv4 } from 'uuid';

/**
 * Factory for creating test users
 */
export class UserFactory {
  private static counter = 0;

  static async create(overrides?: Partial<User>): Promise<Partial<User>> {
    this.counter++;
    const timestamp = Date.now();
    
    return {
      id: uuidv4(),
      email: `test.user${this.counter}.${timestamp}@example.com`,
      firstName: `Test${this.counter}`,
      lastName: `User${this.counter}`,
      role: 'STUDENT' as UserRole,
      status: 'ACTIVE' as UserStatus,
      passwordHash: await bcrypt.hash('TestPassword123!', 10),
      emailVerified: new Date(),
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }

  static async createMany(count: number, overrides?: Partial<User>): Promise<Partial<User>[]> {
    const users: Partial<User>[] = [];
    for (let i = 0; i < count; i++) {
      users.push(await this.create(overrides));
    }
    return users;
  }

  static async createWithRole(role: UserRole, overrides?: Partial<User>): Promise<Partial<User>> {
    return this.create({ role, ...overrides });
  }

  static async createTeacher(overrides?: Partial<User>): Promise<Partial<User>> {
    return this.createWithRole('TEACHER', overrides);
  }

  static async createStudent(overrides?: Partial<User>): Promise<Partial<User>> {
    return this.createWithRole('STUDENT', overrides);
  }

  static async createAdmin(overrides?: Partial<User>): Promise<Partial<User>> {
    return this.createWithRole('ADMIN', overrides);
  }
}

/**
 * Factory for creating test lessons
 */
export class LessonFactory {
  private static counter = 0;

  static create(teacherId: string, overrides?: Partial<Lesson>): Partial<Lesson> {
    this.counter++;
    const timestamp = Date.now();
    
    return {
      id: uuidv4(),
      title: `Test Lesson ${this.counter}`,
      description: `Description for test lesson ${this.counter}`,
      status: 'PUBLISHED' as LessonStatus,
      order: this.counter,
      createdById: teacherId,
      objectives: ['Objective 1', 'Objective 2', 'Objective 3'],
      estimatedTime: 30,
      difficulty: 'beginner',
      tags: ['test', 'automated'],
      publishedAt: new Date(),
      metadata: { isTest: true },
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }

  static createDraft(teacherId: string, overrides?: Partial<Lesson>): Partial<Lesson> {
    return this.create(teacherId, { status: 'DRAFT' as LessonStatus, publishedAt: null, ...overrides });
  }

  static createPublished(teacherId: string, overrides?: Partial<Lesson>): Partial<Lesson> {
    return this.create(teacherId, { status: 'PUBLISHED' as LessonStatus, ...overrides });
  }

  static createMany(count: number, teacherId: string, overrides?: Partial<Lesson>): Partial<Lesson>[] {
    const lessons: Partial<Lesson>[] = [];
    for (let i = 0; i < count; i++) {
      lessons.push(this.create(teacherId, overrides));
    }
    return lessons;
  }
}

/**
 * Factory for creating test videos
 */
export class VideoFactory {
  private static counter = 0;

  static create(videoGroupId: string, overrides?: Partial<Video>): Partial<Video> {
    this.counter++;
    const timestamp = Date.now();
    
    return {
      id: uuidv4(),
      videoGroupId,
      title: `Test Video ${this.counter}`,
      description: `Description for test video ${this.counter}`,
      order: this.counter,
      status: 'READY' as VideoStatus,
      gcsPath: `test/videos/video${this.counter}.mp4`,
      gcsUrl: `https://storage.googleapis.com/test-bucket/video${this.counter}.mp4`,
      duration: 300, // 5 minutes
      thumbnailUrl: `https://storage.googleapis.com/test-bucket/thumbnails/video${this.counter}.jpg`,
      metadata: {
        resolution: '1920x1080',
        frameRate: 30,
        codec: 'h264'
      },
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }

  static createProcessing(videoGroupId: string, overrides?: Partial<Video>): Partial<Video> {
    return this.create(videoGroupId, { status: 'PROCESSING' as VideoStatus, ...overrides });
  }

  static createReady(videoGroupId: string, overrides?: Partial<Video>): Partial<Video> {
    return this.create(videoGroupId, { status: 'READY' as VideoStatus, ...overrides });
  }

  static createMany(count: number, videoGroupId: string, overrides?: Partial<Video>): Partial<Video>[] {
    const videos: Partial<Video>[] = [];
    for (let i = 0; i < count; i++) {
      videos.push(this.create(videoGroupId, overrides));
    }
    return videos;
  }
}

/**
 * Factory for creating test milestones
 */
export class MilestoneFactory {
  private static counter = 0;

  static create(videoId: string, overrides?: Partial<Milestone>): Partial<Milestone> {
    this.counter++;
    
    return {
      id: uuidv4(),
      videoId,
      type: 'QUIZ' as MilestoneType,
      timestamp: 30 + (this.counter * 30), // Every 30 seconds
      title: `Milestone ${this.counter}`,
      description: `Test milestone ${this.counter}`,
      order: this.counter,
      required: true,
      passingScore: 0.7,
      retryLimit: 3,
      metadata: { isTest: true },
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }

  static createQuiz(videoId: string, timestamp: number, overrides?: Partial<Milestone>): Partial<Milestone> {
    return this.create(videoId, { type: 'QUIZ' as MilestoneType, timestamp, ...overrides });
  }

  static createPause(videoId: string, timestamp: number, overrides?: Partial<Milestone>): Partial<Milestone> {
    return this.create(videoId, { type: 'PAUSE' as MilestoneType, timestamp, ...overrides });
  }

  static createInteractive(videoId: string, timestamp: number, overrides?: Partial<Milestone>): Partial<Milestone> {
    return this.create(videoId, { type: 'INTERACTIVE' as MilestoneType, timestamp, ...overrides });
  }

  static createMany(count: number, videoId: string, overrides?: Partial<Milestone>): Partial<Milestone>[] {
    const milestones: Partial<Milestone>[] = [];
    for (let i = 0; i < count; i++) {
      milestones.push(this.create(videoId, overrides));
    }
    return milestones;
  }
}

/**
 * Factory for creating test questions
 */
export class QuestionFactory {
  private static counter = 0;

  static create(milestoneId: string, overrides?: Partial<Question>): Partial<Question> {
    this.counter++;
    
    return {
      id: uuidv4(),
      milestoneId,
      type: 'MULTIPLE_CHOICE' as QuestionType,
      question: `Test question ${this.counter}?`,
      options: ['Option A', 'Option B', 'Option C', 'Option D'],
      correctAnswer: 'Option A',
      explanation: `This is the explanation for question ${this.counter}`,
      order: this.counter,
      points: 10,
      timeLimit: 60,
      metadata: { isTest: true },
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }

  static createMultipleChoice(milestoneId: string, overrides?: Partial<Question>): Partial<Question> {
    return this.create(milestoneId, {
      type: 'MULTIPLE_CHOICE' as QuestionType,
      options: ['Option A', 'Option B', 'Option C', 'Option D'],
      correctAnswer: 'Option A',
      ...overrides
    });
  }

  static createTrueFalse(milestoneId: string, overrides?: Partial<Question>): Partial<Question> {
    return this.create(milestoneId, {
      type: 'TRUE_FALSE' as QuestionType,
      options: ['True', 'False'],
      correctAnswer: 'True',
      ...overrides
    });
  }

  static createShortAnswer(milestoneId: string, overrides?: Partial<Question>): Partial<Question> {
    return this.create(milestoneId, {
      type: 'SHORT_ANSWER' as QuestionType,
      options: null,
      correctAnswer: 'Expected answer',
      ...overrides
    });
  }

  static createFillInTheBlank(milestoneId: string, overrides?: Partial<Question>): Partial<Question> {
    return this.create(milestoneId, {
      type: 'FILL_IN_THE_BLANK' as QuestionType,
      question: 'The capital of France is ___',
      options: null,
      correctAnswer: 'Paris',
      ...overrides
    });
  }

  static createMany(count: number, milestoneId: string, overrides?: Partial<Question>): Partial<Question>[] {
    const questions: Partial<Question>[] = [];
    for (let i = 0; i < count; i++) {
      questions.push(this.create(milestoneId, overrides));
    }
    return questions;
  }

  static createMixedTypes(milestoneId: string): Partial<Question>[] {
    return [
      this.createMultipleChoice(milestoneId),
      this.createTrueFalse(milestoneId),
      this.createShortAnswer(milestoneId),
      this.createFillInTheBlank(milestoneId)
    ];
  }
}

/**
 * Factory for creating AI-generated questions
 */
export class AIQuestionFactory {
  static create(milestoneId: string, provider: AIProvider, overrides?: Partial<Question>): Partial<Question> {
    return QuestionFactory.create(milestoneId, {
      aiGenerated: true,
      aiProvider: provider,
      aiModel: provider === 'OPENAI' ? 'gpt-3.5-turbo' : 'claude-3-haiku',
      aiConfigId: `test-${provider.toLowerCase()}-config`,
      generationPrompt: 'Generate a question about the video content',
      ...overrides
    });
  }

  static createOpenAI(milestoneId: string, overrides?: Partial<Question>): Partial<Question> {
    return this.create(milestoneId, 'OPENAI', overrides);
  }

  static createClaude(milestoneId: string, overrides?: Partial<Question>): Partial<Question> {
    return this.create(milestoneId, 'CLAUDE', overrides);
  }
}

/**
 * Factory for creating complete test scenarios
 */
export class ScenarioFactory {
  static async createCompleteLesson() {
    const teacher = await UserFactory.createTeacher();
    const lesson = LessonFactory.createPublished(teacher.id!);
    
    // Create video group
    const videoGroup = {
      id: uuidv4(),
      lessonId: lesson.id!,
      title: 'Main Videos',
      description: 'Primary video content',
      order: 1
    };
    
    // Create videos
    const video1 = VideoFactory.createReady(videoGroup.id);
    const video2 = VideoFactory.createReady(videoGroup.id);
    
    // Create milestones for each video
    const milestone1 = MilestoneFactory.createQuiz(video1.id!, 30);
    const milestone2 = MilestoneFactory.createQuiz(video1.id!, 60);
    const milestone3 = MilestoneFactory.createQuiz(video2.id!, 45);
    
    // Create questions for each milestone
    const questions1 = QuestionFactory.createMixedTypes(milestone1.id!);
    const questions2 = QuestionFactory.createMixedTypes(milestone2.id!);
    const questions3 = QuestionFactory.createMixedTypes(milestone3.id!);
    
    return {
      teacher,
      lesson,
      videoGroup,
      videos: [video1, video2],
      milestones: [milestone1, milestone2, milestone3],
      questions: [...questions1, ...questions2, ...questions3]
    };
  }

  static async createStudentProgress() {
    const student = await UserFactory.createStudent();
    const { lesson, videos, milestones } = await this.createCompleteLesson();
    
    // Create enrollment
    const enrollment = {
      id: uuidv4(),
      studentId: student.id!,
      lessonId: lesson.id!,
      enrolledAt: new Date(),
      status: 'ACTIVE'
    };
    
    // Create lesson progress
    const lessonProgress = {
      id: uuidv4(),
      studentId: student.id!,
      lessonId: lesson.id!,
      progress: 0.5,
      completedAt: null,
      lastAccessedAt: new Date()
    };
    
    // Create video session
    const videoSession = {
      id: uuidv4(),
      userId: student.id!,
      videoId: videos[0].id!,
      startTime: new Date(),
      lastPosition: 45,
      totalWatchTime: 45,
      completed: false
    };
    
    // Create milestone progress
    const milestoneProgress = {
      id: uuidv4(),
      userId: student.id!,
      milestoneId: milestones[0].id!,
      completed: true,
      score: 0.8,
      attempts: 1,
      completedAt: new Date()
    };
    
    return {
      student,
      enrollment,
      lessonProgress,
      videoSession,
      milestoneProgress
    };
  }
}

/**
 * Utility to reset factory counters
 */
export function resetFactories() {
  UserFactory['counter'] = 0;
  LessonFactory['counter'] = 0;
  VideoFactory['counter'] = 0;
  MilestoneFactory['counter'] = 0;
  QuestionFactory['counter'] = 0;
}
</file>

<file path="tests/utils/database.ts">
import { PrismaClient } from '@prisma/client';
import { execSync } from 'child_process';
import bcrypt from 'bcrypt';

let prisma: PrismaClient;

export const getTestPrismaClient = (): PrismaClient => {
  if (!prisma) {
    prisma = new PrismaClient({
      datasources: {
        db: {
          url: process.env.DATABASE_URL_TEST || 'postgresql://postgres:postgres@localhost:5432/learning_platform_test'
        }
      },
      log: process.env.DEBUG === 'true' ? ['query', 'error', 'warn'] : ['error']
    });
  }
  return prisma;
};

export const setupTestDatabase = async (): Promise<void> => {
  const prisma = getTestPrismaClient();
  
  try {
    // Run migrations on test database
    execSync('npx prisma migrate deploy --schema=database/prisma/schema.prisma', {
      env: {
        ...process.env,
        DATABASE_URL: process.env.DATABASE_URL_TEST
      }
    });
    
    // Clear all data
    await cleanupDatabase();
    
    // Seed basic test data
    await seedTestData();
  } catch (error) {
    console.error('Failed to setup test database:', error);
    throw error;
  }
};

export const cleanupDatabase = async (): Promise<void> => {
  const prisma = getTestPrismaClient();
  
  // Delete in correct order to respect foreign key constraints
  await prisma.$transaction([
    prisma.userAnswer.deleteMany(),
    prisma.milestoneProgress.deleteMany(),
    prisma.videoSession.deleteMany(),
    prisma.lessonProgress.deleteMany(),
    prisma.enrollment.deleteMany(),
    prisma.question.deleteMany(),
    prisma.milestone.deleteMany(),
    prisma.video.deleteMany(),
    prisma.videoGroup.deleteMany(),
    prisma.lesson.deleteMany(),
    prisma.userPreference.deleteMany(),
    prisma.refreshToken.deleteMany(),
    prisma.user.deleteMany(),
    prisma.aIConfiguration.deleteMany(),
    prisma.systemConfig.deleteMany(),
  ]);
};

export const seedTestData = async (): Promise<void> => {
  const prisma = getTestPrismaClient();
  const passwordHash = await bcrypt.hash('TestPassword123!', 10);
  
  // Create test users
  await prisma.user.createMany({
    data: [
      {
        id: 'test-teacher-id',
        email: 'test.teacher@example.com',
        firstName: 'Test',
        lastName: 'Teacher',
        role: 'TEACHER',
        status: 'ACTIVE',
        passwordHash,
        emailVerified: new Date()
      },
      {
        id: 'test-student-id',
        email: 'test.student@example.com',
        firstName: 'Test',
        lastName: 'Student',
        role: 'STUDENT',
        status: 'ACTIVE',
        passwordHash,
        emailVerified: new Date()
      },
      {
        id: 'test-admin-id',
        email: 'test.admin@example.com',
        firstName: 'Test',
        lastName: 'Admin',
        role: 'ADMIN',
        status: 'ACTIVE',
        passwordHash,
        emailVerified: new Date()
      }
    ]
  });
  
  // Create test AI configuration
  await prisma.aIConfiguration.create({
    data: {
      id: 'test-ai-config',
      provider: 'OPENAI',
      name: 'Test AI Configuration',
      model: 'gpt-3.5-turbo',
      parameters: {
        temperature: 0.7,
        maxTokens: 2000
      },
      isActive: true,
      rateLimit: 60,
      maxTokens: 4000
    }
  });
};

export const createTestUser = async (overrides?: Partial<any>) => {
  const prisma = getTestPrismaClient();
  const passwordHash = await bcrypt.hash('TestPassword123!', 10);
  
  return prisma.user.create({
    data: {
      email: `test${Date.now()}@example.com`,
      firstName: 'Test',
      lastName: 'User',
      role: 'STUDENT',
      status: 'ACTIVE',
      passwordHash,
      emailVerified: new Date(),
      ...overrides
    }
  });
};

export const createTestLesson = async (teacherId: string, overrides?: Partial<any>) => {
  const prisma = getTestPrismaClient();
  
  return prisma.lesson.create({
    data: {
      title: `Test Lesson ${Date.now()}`,
      description: 'Test lesson description',
      status: 'PUBLISHED',
      order: 1,
      createdById: teacherId,
      objectives: ['Test objective 1', 'Test objective 2'],
      estimatedTime: 30,
      difficulty: 'beginner',
      tags: ['test'],
      publishedAt: new Date(),
      ...overrides
    }
  });
};

export const disconnectTestDatabase = async (): Promise<void> => {
  if (prisma) {
    await prisma.$disconnect();
  }
};
</file>

<file path="tests/setup.ts">
import dotenv from 'dotenv';
import path from 'path';

// Load test environment variables
dotenv.config({ path: path.resolve(__dirname, '../.env.test') });

// Set test environment
process.env.NODE_ENV = 'test';
process.env.JWT_SECRET = 'test-jwt-secret-key';
process.env.DATABASE_URL = process.env.DATABASE_URL_TEST || 'postgresql://postgres:postgres@localhost:5432/learning_platform_test';

// Mock console methods to reduce noise in tests
global.console = {
  ...console,
  log: jest.fn(),
  debug: jest.fn(),
  info: jest.fn(),
  warn: jest.fn(),
  error: jest.fn(),
};

// Add custom matchers
expect.extend({
  toBeWithinRange(received: number, floor: number, ceiling: number) {
    const pass = received >= floor && received <= ceiling;
    if (pass) {
      return {
        message: () => `expected ${received} not to be within range ${floor} - ${ceiling}`,
        pass: true,
      };
    } else {
      return {
        message: () => `expected ${received} to be within range ${floor} - ${ceiling}`,
        pass: false,
      };
    }
  },
});

// Cleanup after all tests
afterAll(async () => {
  // Close database connections
  const { PrismaClient } = await import('@prisma/client');
  const prisma = new PrismaClient();
  await prisma.$disconnect();
  
  // Allow time for async operations to complete
  await new Promise(resolve => setTimeout(resolve, 500));
});
</file>

<file path=".env.example">
# Database Configuration
DATABASE_URL="postgresql://username:password@localhost:5432/education_platform"

# Server Configuration
PORT=3000
NODE_ENV=development
API_VERSION=v1

# JWT Configuration
JWT_SECRET=your-super-secure-jwt-secret-key-here
JWT_REFRESH_SECRET=your-super-secure-refresh-secret-key-here
JWT_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=7d

# Google Cloud Storage Configuration
GOOGLE_CLOUD_PROJECT_ID=your-project-id
GOOGLE_CLOUD_STORAGE_BUCKET=your-bucket-name
GOOGLE_APPLICATION_CREDENTIALS=path/to/service-account.json

# Redis Configuration
REDIS_URL=redis://localhost:6379
REDIS_PASSWORD=
REDIS_DB=0

# AI Provider Configuration
OPENAI_API_KEY=your-openai-api-key
ANTHROPIC_API_KEY=your-anthropic-api-key
GOOGLE_PALM_API_KEY=your-google-palm-api-key

# Email Configuration (Optional)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password

# Rate Limiting Configuration
RATE_LIMIT_WINDOW=15
RATE_LIMIT_MAX_REQUESTS=100

# Logging Configuration
LOG_LEVEL=info
LOG_FILE=logs/app.log

# Session Configuration
SESSION_TIMEOUT=30

# Security Configuration
BCRYPT_SALT_ROUNDS=12
MAX_FILE_SIZE=100MB
ALLOWED_FILE_TYPES=mp4,avi,mov,wmv

# Analytics Configuration
ENABLE_ANALYTICS=true
ANALYTICS_RETENTION_DAYS=90

# CORS Configuration
CORS_ORIGINS=http://localhost:3000,http://localhost:3001
</file>

<file path=".env.test">
# Test Environment Configuration
NODE_ENV=test

# Database
DATABASE_URL_TEST=postgresql://postgres:postgres@localhost:5432/learning_platform_test

# JWT
JWT_SECRET=test-jwt-secret-key-for-testing-only
JWT_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=7d

# AI Providers (Mock for testing)
OPENAI_API_KEY=test-openai-key
ANTHROPIC_API_KEY=test-anthropic-key

# Google Cloud Storage (Mock for testing)
GOOGLE_CLOUD_PROJECT_ID=test-project
GOOGLE_CLOUD_STORAGE_BUCKET=test-bucket
GOOGLE_CLOUD_KEYFILE_PATH=./test-service-account.json

# Redis (Test instance)
REDIS_URL=redis://localhost:6379/1

# API Configuration
API_BASE_URL=http://localhost:3000/api
FRONTEND_URL=http://localhost:3001

# Test-specific settings
DISABLE_RATE_LIMITING=true
LOG_LEVEL=error
DISABLE_CORS=true
</file>

<file path=".eslintrc.js">
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2022,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint'],
  extends: [
    'eslint:recommended',
  ],
  env: {
    node: true,
    es2022: true,
    jest: true,
  },
  rules: {
    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/no-non-null-assertion': 'warn',
    'prefer-const': 'error',
    'no-var': 'error',
  },
  ignorePatterns: [
    'dist/**/*',
    'node_modules/**/*',
    'logs/**/*',
    'uploads/**/*',
    'frontend/**/*',
    'database/seeds/**/*',
    'database/types.ts',
    '**/*.js',
    '**/*.d.ts',
  ],
};
</file>

<file path="dev.sh">
#!/bin/bash

# Development Environment Manager Script
# This script helps manage the local development setup with Docker for databases only

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Functions
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Commands
case "$1" in
    start)
        print_status "Starting development environment..."
        
        # Start Docker services (DB, Redis only)
        print_status "Starting Docker services (Database & Redis)..."
        docker-compose -f docker-compose.dev.yml up -d postgres redis adminer redis-insight
        
        # Wait for services to be healthy
        print_status "Waiting for services to be healthy..."
        sleep 5
        
        # Install dependencies if needed
        if [ ! -d "node_modules" ]; then
            print_status "Installing backend dependencies..."
            npm install
        fi
        
        if [ ! -d "frontend/node_modules" ]; then
            print_status "Installing frontend dependencies..."
            cd frontend && npm install && cd ..
        fi
        
        # Generate Prisma client
        print_status "Generating Prisma client..."
        npx prisma generate --schema=database/prisma/schema.prisma
        
        # Start backend locally
        print_status "Starting backend locally with hot reload..."
        npm run dev > /tmp/backend.log 2>&1 &
        echo $! > /tmp/backend.pid
        
        # Start frontend locally
        print_status "Starting frontend locally with hot reload..."
        cd frontend && npm run dev > /tmp/frontend.log 2>&1 &
        echo $! > /tmp/frontend.pid
        cd ..
        
        sleep 3
        print_success "Development environment started!"
        echo ""
        echo "Services available at:"
        echo "  Backend API:    http://localhost:3000"
        echo "  Frontend:       http://localhost:3001"
        echo "  Database UI:    http://localhost:8080"
        echo "  Redis UI:       http://localhost:8001"
        echo ""
        echo "Both backend and frontend are running locally with hot reload enabled!"
        echo ""
        echo "View logs with:"
        echo "  Backend:  tail -f /tmp/backend.log"
        echo "  Frontend: tail -f /tmp/frontend.log"
        ;;
        
    stop)
        print_status "Stopping development environment..."
        
        # Kill local backend process
        print_status "Stopping local backend..."
        if [ -f /tmp/backend.pid ]; then
            kill $(cat /tmp/backend.pid) 2>/dev/null || true
            rm /tmp/backend.pid
        fi
        pkill -f "tsx watch" 2>/dev/null || true
        
        # Kill local frontend process
        print_status "Stopping local frontend..."
        if [ -f /tmp/frontend.pid ]; then
            kill $(cat /tmp/frontend.pid) 2>/dev/null || true
            rm /tmp/frontend.pid
        fi
        pkill -f "vite" 2>/dev/null || true
        
        # Stop Docker containers
        print_status "Stopping Docker services..."
        docker-compose -f docker-compose.dev.yml down
        
        print_success "Development environment stopped!"
        ;;
        
    restart)
        print_status "Restarting development environment..."
        $0 stop
        sleep 2
        $0 start
        ;;
        
    status)
        echo "Development Environment Status:"
        echo "==============================="
        echo ""
        echo "Docker Services:"
        docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "(NAME|interactive-learning)" || echo "No services running"
        echo ""
        echo "Local Backend Process:"
        ps aux | grep "tsx watch" | grep -v grep || echo "Backend not running locally"
        echo ""
        echo "Local Frontend Process:"
        ps aux | grep "vite" | grep -v grep || echo "Frontend not running locally"
        echo ""
        
        # Test health endpoints
        echo "Service Health Checks:"
        echo "----------------------"
        echo -n "Backend:  "
        curl -s http://localhost:3000/health 2>/dev/null | python3 -c "import sys, json; data=json.load(sys.stdin); print(f\"✅ Healthy (v{data['version']})\") if data['status']=='healthy' else print('❌ Not responding')" 2>/dev/null || echo "❌ Not responding"
        
        echo -n "Frontend: "
        curl -s -o /dev/null -w "%{http_code}" http://localhost:3001 2>/dev/null | grep -q "200" && echo "✅ Running" || echo "❌ Not responding"
        ;;
        
    logs)
        case "$2" in
            backend)
                if [ -f /tmp/backend.log ]; then
                    tail -f /tmp/backend.log
                else
                    print_error "Backend log file not found. Is the backend running?"
                fi
                ;;
            frontend)
                if [ -f /tmp/frontend.log ]; then
                    tail -f /tmp/frontend.log
                else
                    print_error "Frontend log file not found. Is the frontend running?"
                fi
                ;;
            db)
                docker logs -f interactive-learning-db
                ;;
            redis)
                docker logs -f interactive-learning-redis
                ;;
            *)
                echo "Usage: $0 logs [backend|frontend|db|redis]"
                ;;
        esac
        ;;
        
    db:migrate)
        print_status "Running database migrations..."
        npx prisma migrate dev --schema=database/prisma/schema.prisma
        print_success "Migrations completed!"
        ;;
        
    db:studio)
        print_status "Opening Prisma Studio..."
        npx prisma studio --schema=database/prisma/schema.prisma
        ;;
        
    db:reset)
        print_warning "This will reset your database and delete all data!"
        read -p "Are you sure? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            print_status "Resetting database..."
            npx prisma migrate reset --force --schema=database/prisma/schema.prisma
            print_success "Database reset completed!"
        else
            print_status "Database reset cancelled."
        fi
        ;;
        
    install)
        print_status "Installing all dependencies..."
        
        # Backend dependencies
        print_status "Installing backend dependencies..."
        npm install
        
        # Frontend dependencies
        print_status "Installing frontend dependencies..."
        cd frontend && npm install && cd ..
        
        print_success "All dependencies installed!"
        ;;
        
    clean)
        print_warning "This will remove all Docker volumes and clean up development files!"
        read -p "Are you sure? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            $0 stop
            print_status "Removing Docker volumes..."
            docker-compose -f docker-compose.dev.yml down -v
            print_status "Cleaning up log files..."
            rm -f /tmp/backend.log /tmp/frontend.log /tmp/backend.pid /tmp/frontend.pid
            print_success "Cleanup completed!"
        else
            print_status "Cleanup cancelled."
        fi
        ;;
        
    *)
        echo "Usage: $0 {start|stop|restart|status|logs|db:migrate|db:studio|db:reset|install|clean}"
        echo ""
        echo "Commands:"
        echo "  start       - Start all services (Docker databases + local apps)"
        echo "  stop        - Stop all services"
        echo "  restart     - Restart all services"
        echo "  status      - Show status of all services"
        echo "  logs        - Show logs (backend|frontend|db|redis)"
        echo "  db:migrate  - Run database migrations"
        echo "  db:studio   - Open Prisma Studio"
        echo "  db:reset    - Reset database (WARNING: deletes all data)"
        echo "  install     - Install all dependencies"
        echo "  clean       - Clean up Docker volumes and temp files"
        exit 1
        ;;
esac
</file>

<file path="INTEGRATION_TESTING.md">
# Interactive Learning Platform - Integration Testing Guide

## 🚀 Complete System Integration

This guide provides step-by-step instructions for testing the complete interactive learning workflow, from content creation to student interaction.

## 📋 Prerequisites

1. **Development Environment Setup**
   ```bash
   npm run dev:setup
   ```

2. **AI Provider Configuration** (Optional but Recommended)
   ```bash
   # Set environment variables in .env
   OPENAI_API_KEY=your_openai_api_key_here
   ANTHROPIC_API_KEY=your_anthropic_api_key_here
   ```

3. **Start All Services**
   ```bash
   npm run dev:up
   ```

## 🔗 Service URLs

- **Frontend Application**: http://localhost:3001
- **Backend API**: http://localhost:3000
- **Database Admin (Adminer)**: http://localhost:8080
- **Redis Admin (RedisInsight)**: http://localhost:8001

## 🧪 Complete Workflow Testing

### Phase 1: Teacher Content Creation

#### 1.1 Teacher Registration & Authentication
1. Navigate to http://localhost:3001
2. Click "Register" and create a teacher account:
   ```json
   {
     "firstName": "John",
     "lastName": "Teacher",
     "email": "teacher@example.com",
     "password": "SecurePass123!",
     "role": "TEACHER"
   }
   ```
3. Verify email validation and successful login
4. Confirm teacher dashboard loads with appropriate tools

#### 1.2 Lesson Creation
1. Click "Create New Lesson" from teacher dashboard
2. Fill out lesson details:
   - Title: "Introduction to JavaScript"
   - Description: "Learn the fundamentals of JavaScript programming"
   - Tags: ["javascript", "programming", "beginner"]
   - Make it public
3. Verify lesson creation and navigation to lesson management page

#### 1.3 Video Upload
1. In lesson management page, click "Add Video"
2. Add video details:
   - Title: "Variables and Data Types"
   - Description: "Understanding JavaScript variables"
   - Video URL: `https://sample-videos.com/zip/10/mp4/SampleVideo_1280x720_1mb.mp4`
   - Duration: 60 (seconds)
3. Verify video appears in lesson

#### 1.4 Interactive Milestone Creation
1. Select the uploaded video
2. Click "Add Milestone" 
3. Create milestone:
   - Type: "QUIZ"
   - Timestamp: 30 seconds
   - Title: "Variables Quiz"
   - Description: "Test your understanding of JavaScript variables"
4. Verify milestone creation

#### 1.5 Question Creation
1. Click on the created milestone
2. Add questions manually:
   - **Multiple Choice**: "What keyword is used to declare a variable in JavaScript?"
     - Options: ["var", "variable", "let", "declare"]
     - Correct: "let"
   - **True/False**: "JavaScript is a strongly typed language"
     - Correct: "False"
   - **Short Answer**: "What symbol is used to end statements in JavaScript?"
     - Correct: ";"

#### 1.6 AI Question Generation (if configured)
1. Click "AI Generate" button
2. Provide content about JavaScript variables
3. Configure question generation:
   - Question count: 3
   - Types: All types
   - Difficulty: Medium
   - Provider: OpenAI or Claude
4. Verify AI-generated questions are added to milestone

### Phase 2: Student Learning Experience

#### 2.1 Student Registration
1. Open new browser session/incognito window
2. Navigate to http://localhost:3001
3. Register as student:
   ```json
   {
     "firstName": "Alice",
     "lastName": "Student", 
     "email": "student@example.com",
     "password": "SecurePass123!",
     "role": "STUDENT"
   }
   ```
4. Verify student dashboard loads with learning metrics

#### 2.2 Lesson Discovery
1. Click "Browse Lessons" or navigate to `/lessons`
2. Verify the teacher's lesson appears in the list
3. Click on "Introduction to JavaScript" lesson
4. Verify lesson details and video list display

#### 2.3 Interactive Video Experience
1. Click on "Variables and Data Types" video
2. Verify video player loads with controls
3. Start video playback
4. Test video controls:
   - Play/Pause
   - Volume control
   - Seeking
   - Fullscreen
5. Verify milestone marker appears on timeline at 30-second mark

#### 2.4 Milestone Interaction
1. Let video play to 30-second milestone
2. Verify video pauses automatically
3. Verify question overlay appears with quiz questions
4. Answer questions and verify:
   - Immediate feedback (correct/incorrect)
   - Explanations display
   - Progress tracking
5. Complete quiz and verify video resumes

#### 2.5 Progress Persistence
1. Pause video midway and close browser
2. Reopen and navigate back to video
3. Verify video resumes from last position
4. Verify completed milestones remain marked
5. Complete entire video and verify completion status

### Phase 3: Analytics & Management

#### 3.1 Teacher Analytics
1. Return to teacher account
2. Navigate to lesson management
3. Verify student progress data:
   - Video view statistics
   - Completion rates
   - Question performance
   - Engagement metrics

#### 3.2 Student Progress Tracking
1. Return to student account
2. Check dashboard for:
   - Updated learning statistics
   - Progress indicators
   - Achievement notifications
   - Learning streak updates

#### 3.3 Real-time Updates
1. Have student interact with content
2. Verify teacher sees real-time analytics updates
3. Test session tracking and progress synchronization

## 🔍 API Endpoint Testing

### Authentication Endpoints
```bash
# Register
curl -X POST http://localhost:3000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "firstName": "Test",
    "lastName": "User",
    "email": "test@example.com", 
    "password": "SecurePass123!",
    "role": "STUDENT"
  }'

# Login
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "SecurePass123!"
  }'
```

### Video Management Endpoints
```bash
# Get video groups (requires auth token)
curl -X GET http://localhost:3000/api/videos \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"

# Get specific video
curl -X GET http://localhost:3000/api/videos/VIDEO_ID \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```

### Session Tracking Endpoints  
```bash
# Start video session
curl -X POST http://localhost:3000/api/sessions/start \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"videoId": "VIDEO_ID"}'

# Update progress
curl -X PUT http://localhost:3000/api/sessions/SESSION_ID/progress \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"currentTime": 45, "totalWatchTime": 45}'
```

## 🎯 Key Integration Points to Verify

### 1. Authentication Flow
- [ ] Registration with role-based access
- [ ] JWT token generation and refresh
- [ ] Protected route access control
- [ ] Session persistence across browser restarts

### 2. Content Management
- [ ] Lesson creation with proper permissions
- [ ] Video upload and metadata management
- [ ] Milestone creation with timestamp validation
- [ ] Question management with multiple types

### 3. Interactive Video System
- [ ] Video player with full controls
- [ ] Milestone detection and triggering
- [ ] Question overlay display and interaction
- [ ] Progress tracking and resume capability

### 4. AI Integration (if configured)
- [ ] Provider availability detection
- [ ] Question generation from content
- [ ] Multiple question type generation
- [ ] Error handling for API failures

### 5. Analytics & Tracking
- [ ] Real-time progress updates
- [ ] Engagement metrics calculation
- [ ] Performance analytics accuracy
- [ ] Data persistence and retrieval

### 6. Role-Based Features
- [ ] Student dashboard shows learning progress
- [ ] Teacher dashboard shows content management tools
- [ ] Admin dashboard shows system overview
- [ ] Appropriate permission restrictions

## 🐛 Common Issues & Troubleshooting

### Database Connection Issues
```bash
# Check PostgreSQL status
docker-compose -f docker-compose.dev.yml exec postgres pg_isready -U postgres

# Reset database
npm run db:reset
```

### Frontend Build Issues
```bash
# Clear node_modules and reinstall
cd frontend && rm -rf node_modules && npm install
```

### API Connection Issues
```bash
# Check backend health
curl http://localhost:3000/health

# View backend logs
docker-compose -f docker-compose.dev.yml logs backend
```

### Video Playback Issues
- Ensure video URLs are accessible
- Check browser console for CORS errors
- Verify video format compatibility (MP4 recommended)

## 📊 Performance Testing

### Load Testing Scenarios
1. **Concurrent Users**: 50 students watching same video
2. **Content Creation**: 10 teachers creating lessons simultaneously  
3. **Database Load**: 1000 progress updates per minute
4. **API Response Times**: All endpoints < 200ms response time

### Monitoring Metrics
- Video session creation rate
- Question answer submission rate
- Progress update frequency
- Database query performance
- Memory usage patterns

## ✅ Integration Success Criteria

The integration is successful when:

1. **Complete User Journey Works**
   - Teacher can create interactive lessons
   - Students can learn with full engagement features
   - Progress is accurately tracked and persisted

2. **All Core Features Function**
   - Authentication and authorization
   - Video playback with milestone detection
   - Question system with immediate feedback
   - AI integration (if configured)
   - Real-time analytics

3. **System Resilience**
   - Handles errors gracefully
   - Recovers from service interruptions
   - Maintains data integrity
   - Scales under load

4. **User Experience Quality**
   - Intuitive interface navigation
   - Responsive design across devices
   - Fast loading times
   - Smooth video playback

## 🚢 Deployment Readiness

Once integration testing passes:

1. **Environment Configuration**
   - Production environment variables
   - SSL certificate setup
   - CDN configuration for video assets

2. **Security Hardening**
   - API rate limiting verification  
   - Input validation testing
   - Authentication security audit

3. **Performance Optimization**
   - Database query optimization
   - Caching strategy implementation
   - Asset optimization and compression

4. **Monitoring Setup**
   - Error tracking configuration
   - Performance monitoring
   - User analytics integration

---

**🎉 Congratulations!** 

If all tests pass, you have successfully integrated a complete Interactive Learning Platform with:
- ✅ Multi-role authentication system
- ✅ Interactive video player with milestones
- ✅ AI-powered question generation
- ✅ Real-time progress tracking
- ✅ Comprehensive analytics dashboard
- ✅ Docker-based development environment

The platform is ready for advanced features and production deployment!
</file>

<file path="jest.config.js">
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: [
    '**/__tests__/**/*.+(ts|tsx|js)',
    '**/?(*.)+(spec|test).+(ts|tsx|js)'
  ],
  transform: {
    '^.+\\.(ts|tsx)$': ['ts-jest', {
      tsconfig: {
        esModuleInterop: true,
        allowSyntheticDefaultImports: true
      }
    }]
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/index.ts',
    '!src/**/*.interface.ts',
    '!src/types/**/*'
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  coverageThresholds: {
    global: {
      branches: 70,
      functions: 75,
      lines: 80,
      statements: 80
    }
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@database/(.*)$': '<rootDir>/database/$1',
    '^@prisma/client$': '<rootDir>/node_modules/@prisma/client'
  },
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  testTimeout: 10000,
  verbose: true,
  forceExit: true,
  clearMocks: true,
  resetMocks: true,
  restoreMocks: true
};
</file>

<file path="QUICK_START.md">
# Quick Start - Development Environment

## 🚀 Ultra-Fast Local Development Setup

This project uses a **fully local development setup** for maximum performance:
- **Backend & Frontend**: Run locally with instant hot reload
- **Database & Redis**: Run in lightweight Docker containers
- **Zero Docker rebuilds**: Direct Node.js execution for both apps

## Prerequisites

- Node.js 18+ installed locally
- Docker Desktop installed and running
- npm or yarn package manager

## Getting Started

### 1. First Time Setup

```bash
# Install all dependencies (backend + frontend)
./dev.sh install

# Start everything
./dev.sh start
```

That's it! Everything is running with hot reload. 🎉

### 2. Daily Development

```bash
# Start everything
./dev.sh start

# Check status
./dev.sh status

# Stop everything
./dev.sh stop
```

## 📍 Service URLs

| Service | URL | Description |
|---------|-----|-------------|
| Backend API | http://localhost:3000 | Node.js backend (local) |
| Frontend | http://localhost:3001 | React application (local) |
| Health Check | http://localhost:3000/health | Backend health status |
| Database UI | http://localhost:8080 | Adminer for PostgreSQL |
| Redis UI | http://localhost:8001 | RedisInsight |

## 🛠 Development Commands

### Quick Commands

```bash
./dev.sh start      # Start everything
./dev.sh stop       # Stop everything
./dev.sh restart    # Restart everything
./dev.sh status     # Check all services
./dev.sh install    # Install dependencies
```

### View Logs

```bash
./dev.sh logs backend   # Backend logs
./dev.sh logs frontend  # Frontend logs
./dev.sh logs db        # Database logs
./dev.sh logs redis     # Redis logs
```

### Database Operations

```bash
./dev.sh db:migrate  # Run migrations
./dev.sh db:studio   # Open Prisma Studio
./dev.sh db:reset    # Reset database (WARNING: deletes data)
```

## 🔥 Hot Reload

Both backend and frontend have instant hot reload:

- **Backend**: Save any `.ts` file → Server restarts in ~1 second
- **Frontend**: Save any React file → Browser updates instantly
- **No Docker rebuilds**: Everything runs natively on your machine

## 🏗 Architecture

```
┌─────────────────────────────────────────┐
│         Your Local Machine              │
│                                         │
│  ┌────────────────┐  ┌────────────────┐│
│  │   Backend      │  │   Frontend     ││
│  │   (Node.js)    │  │   (React)      ││
│  │   Port: 3000   │  │   Port: 3001   ││
│  │                │  │                ││
│  │  ✨ Hot Reload │  │  ✨ Hot Reload ││
│  └────────────────┘  └────────────────┘│
│         ↓                    ↑          │
├─────────────────────────────────────────┤
│       Docker Containers (Data Only)     │
│                                         │
│  ┌────────────┐  ┌────────────┐       │
│  │ PostgreSQL │  │   Redis    │       │
│  │ Port: 5432 │  │ Port: 6379 │       │
│  └────────────┘  └────────────┘       │
└─────────────────────────────────────────┘
```

## 🐛 Troubleshooting

### Services not starting?

```bash
# Check what's running
./dev.sh status

# Restart everything
./dev.sh restart

# Check Docker is running
docker ps
```

### Port already in use?

```bash
# Find what's using port 3000 or 3001
lsof -i :3000
lsof -i :3001

# Kill the process
kill -9 <PID>
```

### Database connection issues?

```bash
# Make sure Docker containers are running
docker ps

# Check database logs
./dev.sh logs db

# Reset database if needed
./dev.sh db:reset
```

### Clean slate needed?

```bash
# Remove everything and start fresh
./dev.sh clean
./dev.sh install
./dev.sh start
```

## 💡 Pro Tips

1. **Instant feedback**: Both apps reload in under 1 second after saving
2. **Parallel development**: Backend and frontend run independently
3. **Easy debugging**: Use your IDE's Node.js debugger directly
4. **Performance**: No Docker overhead = blazing fast development
5. **Database GUI**: Use Adminer at http://localhost:8080
   - Server: `postgres`
   - Username: `postgres`
   - Password: `postgres_dev_password`
   - Database: `interactive_learning`

## 🎯 Why This Setup?

- **⚡ Lightning fast**: No Docker layers for application code
- **🔄 Instant hot reload**: Changes apply in milliseconds
- **🐞 Better debugging**: Direct Node.js process access
- **💻 Native performance**: Full CPU/RAM utilization
- **🗄️ Isolated data**: Databases in containers prevent conflicts
- **📦 Easy cleanup**: `./dev.sh clean` removes everything

## 📝 Common Workflows

### Adding a new API endpoint

1. Create your route in `src/routes/`
2. Save the file
3. Backend auto-restarts with your changes
4. Test immediately at http://localhost:3000/api/v1/your-endpoint

### Updating the UI

1. Edit React components in `frontend/src/`
2. Save the file
3. Browser auto-refreshes with changes
4. See results instantly at http://localhost:3001

### Database schema changes

1. Update `database/prisma/schema.prisma`
2. Run `./dev.sh db:migrate`
3. Backend auto-restarts with new schema
4. Use `./dev.sh db:studio` to view data

## 🚀 Ready to Code!

Everything you need is in the `dev.sh` script. Just run `./dev.sh start` and begin coding. Both backend and frontend will reload automatically as you work. Happy coding! 🎉
</file>

<file path="TESTING_SUITE_PLAN.md">
# Interactive Learning Platform - Comprehensive Testing Suite Plan

## Executive Summary

This document outlines a comprehensive testing strategy for the Interactive Learning Platform, addressing the current gaps in test coverage and providing a roadmap for implementing a robust testing infrastructure across all system components.

## Current State Analysis

### Existing Testing Infrastructure
- **Backend**: Jest configured but no test files implemented
- **Frontend**: No testing framework configured
- **Integration Tests**: Manual bash scripts for API testing
- **E2E Tests**: None implemented
- **Performance Tests**: None implemented
- **Security Tests**: None implemented

### Critical Gaps Identified
1. Zero unit test coverage across all components
2. No automated frontend testing
3. Lack of integration test automation
4. Missing E2E test scenarios
5. No performance benchmarking
6. Absence of security testing protocols

## Testing Architecture

### Testing Pyramid Strategy
```
         /\
        /E2E\        (5%)  - Critical user journeys
       /------\
      /Integration\  (20%) - API & service integration
     /------------\
    /   Unit Tests  \ (75%) - Component & function level
   /----------------\
```

## Component-Specific Testing Strategies

### 1. Backend Testing Strategy

#### Unit Tests (Target: 85% coverage)
**Framework**: Jest + Supertest
**Focus Areas**:
- Controllers: Request validation, response formatting
- Services: Business logic, data transformation
- Middleware: Authentication, authorization, error handling
- Utilities: Helper functions, validators
- Models: Data validation, schema compliance

**Key Test Scenarios**:
```typescript
// Example structure for auth.controller.test.ts
describe('AuthController', () => {
  describe('POST /auth/register', () => {
    test('should register user with valid data')
    test('should reject duplicate email')
    test('should validate password strength')
    test('should assign correct role')
  })
  
  describe('POST /auth/login', () => {
    test('should authenticate valid credentials')
    test('should reject invalid credentials')
    test('should return JWT token')
    test('should handle rate limiting')
  })
})
```

#### Integration Tests (Target: 70% coverage)
**Focus Areas**:
- Database operations with transaction handling
- Redis caching layer integration
- Google Cloud Storage operations
- AI provider integrations (OpenAI/Claude)
- WebSocket connections for real-time features

### 2. Frontend Testing Strategy

#### Unit Tests (Target: 80% coverage)
**Framework**: Vitest + React Testing Library
**Focus Areas**:
- Components: Rendering, props, state management
- Hooks: Custom hook logic, side effects
- Utilities: Formatters, validators, helpers
- Store: Zustand state management

**Key Test Scenarios**:
```typescript
// Example structure for VideoPlayer.test.tsx
describe('VideoPlayer Component', () => {
  test('renders video with correct source')
  test('handles play/pause interactions')
  test('triggers milestone events at correct timestamps')
  test('saves progress on unmount')
  test('resumes from saved position')
})
```

#### Component Integration Tests
**Focus Areas**:
- Form submissions with validation
- API integration with React Query
- Router navigation flows
- Authentication state management
- Real-time updates via WebSocket

### 3. Database Testing Strategy

#### Schema Tests
**Framework**: Prisma + Jest
**Focus Areas**:
- Migration integrity
- Constraint validation
- Index performance
- Transaction isolation
- Data integrity rules

**Test Scenarios**:
- Cascade deletion behavior
- Unique constraint enforcement
- Foreign key relationships
- Trigger execution
- View consistency

### 4. End-to-End Testing Strategy

#### Critical User Journeys
**Framework**: Playwright
**Test Scenarios**:

1. **Teacher Content Creation Flow**
   - Register → Create Lesson → Upload Video → Add Milestones → Generate Questions → Publish

2. **Student Learning Journey**
   - Register → Browse Lessons → Watch Video → Answer Questions → Track Progress → Complete Lesson

3. **Admin Management Flow**
   - Login → View Analytics → Manage Users → Configure System → Monitor Performance

4. **Cross-Device Session Persistence**
   - Start on Desktop → Continue on Mobile → Resume on Desktop

### 5. Performance Testing Strategy

#### Load Testing
**Framework**: K6 or Artillery
**Scenarios**:
- Concurrent video streaming (100+ users)
- Bulk question generation (50+ requests/min)
- Progress tracking updates (1000+ updates/min)
- Database query performance under load

#### Stress Testing
**Focus Areas**:
- System breaking points
- Recovery mechanisms
- Resource utilization limits
- Graceful degradation

### 6. Security Testing Strategy

#### Vulnerability Testing
**Framework**: OWASP ZAP + Custom Scripts
**Focus Areas**:
- SQL injection prevention
- XSS protection
- CSRF token validation
- JWT security
- File upload validation
- Rate limiting effectiveness

#### Penetration Testing
- Authentication bypass attempts
- Authorization escalation
- Data exposure risks
- API endpoint fuzzing

## Implementation Roadmap

### Phase 1: Foundation (Week 1-2)
**Priority**: CRITICAL

1. **Backend Unit Tests**
   - [ ] Set up Jest configuration with TypeScript
   - [ ] Implement auth controller tests
   - [ ] Implement user service tests
   - [ ] Add test database configuration
   - [ ] Create test data factories

2. **Frontend Testing Setup**
   - [ ] Install and configure Vitest
   - [ ] Set up React Testing Library
   - [ ] Configure test utilities and mocks
   - [ ] Create component test templates

### Phase 2: Core Coverage (Week 3-4)
**Priority**: HIGH

1. **Backend Coverage**
   - [ ] Video management tests
   - [ ] Milestone and question tests
   - [ ] Progress tracking tests
   - [ ] AI integration tests with mocks

2. **Frontend Coverage**
   - [ ] Authentication flow tests
   - [ ] Video player component tests
   - [ ] Dashboard component tests
   - [ ] Form validation tests

### Phase 3: Integration Testing (Week 5-6)
**Priority**: HIGH

1. **API Integration Tests**
   - [ ] Complete user journey tests
   - [ ] Database transaction tests
   - [ ] Cache layer tests
   - [ ] File upload tests

2. **Frontend Integration**
   - [ ] API integration with MSW mocks
   - [ ] State management tests
   - [ ] Router integration tests

### Phase 4: E2E & Performance (Week 7-8)
**Priority**: MEDIUM

1. **E2E Implementation**
   - [ ] Set up Playwright
   - [ ] Implement critical user journeys
   - [ ] Cross-browser testing
   - [ ] Mobile responsiveness tests

2. **Performance Testing**
   - [ ] Set up K6 or Artillery
   - [ ] Create load test scenarios
   - [ ] Establish performance baselines
   - [ ] Implement monitoring

### Phase 5: Security & Optimization (Week 9-10)
**Priority**: MEDIUM

1. **Security Testing**
   - [ ] OWASP ZAP integration
   - [ ] Custom security test suite
   - [ ] Vulnerability scanning
   - [ ] Security audit documentation

2. **Test Optimization**
   - [ ] Parallel test execution
   - [ ] Test data management
   - [ ] CI/CD integration
   - [ ] Test reporting dashboard

## Test Data Management

### Strategy
1. **Seed Data**: Consistent baseline for all tests
2. **Factories**: Dynamic test data generation
3. **Fixtures**: Static test data for specific scenarios
4. **Cleanup**: Automatic test data cleanup

### Implementation
```typescript
// Example test data factory
class UserFactory {
  static create(overrides?: Partial<User>): User {
    return {
      id: faker.uuid(),
      email: faker.email(),
      firstName: faker.firstName(),
      lastName: faker.lastName(),
      role: 'STUDENT',
      ...overrides
    }
  }
}
```

## CI/CD Integration

### Pipeline Configuration
```yaml
name: Test Suite
on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - Run backend unit tests
      - Run frontend unit tests
      - Generate coverage reports
  
  integration-tests:
    runs-on: ubuntu-latest
    steps:
      - Run API integration tests
      - Run database tests
  
  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - Run Playwright tests
      - Generate screenshots on failure
  
  performance-tests:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - Run load tests
      - Compare with baselines
```

## Testing Standards & Best Practices

### Code Coverage Requirements
- **Unit Tests**: Minimum 80% coverage
- **Integration Tests**: Minimum 60% coverage
- **Overall Coverage**: Minimum 75%
- **Critical Paths**: 100% coverage required

### Test Writing Guidelines
1. **AAA Pattern**: Arrange, Act, Assert
2. **Single Responsibility**: One assertion per test
3. **Descriptive Names**: Clear test intentions
4. **Independent Tests**: No test dependencies
5. **Fast Execution**: Mock external dependencies

### Test Organization
```
tests/
├── unit/
│   ├── backend/
│   │   ├── controllers/
│   │   ├── services/
│   │   └── utils/
│   └── frontend/
│       ├── components/
│       ├── hooks/
│       └── utils/
├── integration/
│   ├── api/
│   ├── database/
│   └── services/
├── e2e/
│   ├── journeys/
│   └── fixtures/
└── performance/
    ├── load/
    └── stress/
```

## Quality Gates

### Pre-commit Hooks
- Run unit tests for changed files
- Lint and format checks
- Type checking

### Pre-merge Requirements
- All tests passing
- Coverage thresholds met
- No security vulnerabilities
- Performance benchmarks maintained

### Release Criteria
- Full test suite execution
- E2E tests on staging environment
- Performance regression tests
- Security audit completion

## Monitoring & Reporting

### Test Metrics Dashboard
- Test execution time trends
- Coverage trends
- Flaky test identification
- Failure rate analysis

### Automated Reporting
- Daily test execution summary
- Weekly coverage reports
- Sprint-end quality metrics
- Release readiness reports

## Risk Mitigation

### High-Risk Areas Requiring Priority Testing
1. **Authentication & Authorization**: Security critical
2. **Payment Processing**: Financial risk
3. **Video Streaming**: Performance critical
4. **Progress Tracking**: Data integrity critical
5. **AI Integration**: Cost and reliability concerns

### Contingency Planning
- Rollback procedures for failed deployments
- Feature flags for gradual rollouts
- Canary deployments for high-risk changes
- Automated rollback on test failures

## Success Metrics

### Key Performance Indicators
- **Test Coverage**: Achieve 80% overall coverage
- **Test Execution Time**: < 10 minutes for full suite
- **Defect Escape Rate**: < 5% to production
- **Test Reliability**: < 1% flaky test rate
- **Automation Rate**: > 90% of test scenarios automated

### Quarterly Goals
- **Q1**: Foundation and core coverage (60% coverage)
- **Q2**: Integration and E2E (75% coverage)
- **Q3**: Performance and security (80% coverage)
- **Q4**: Optimization and maintenance (85% coverage)

## Budget & Resources

### Required Tools
- **Playwright License**: E2E testing
- **K6 Cloud**: Performance testing dashboards
- **Security Tools**: OWASP ZAP Pro
- **Monitoring**: Datadog or New Relic

### Team Requirements
- 2 QA Engineers (full-time)
- 1 DevOps Engineer (part-time)
- Developer time allocation: 20% for test writing

## Conclusion

This comprehensive testing plan addresses all current gaps in the Interactive Learning Platform's quality assurance infrastructure. Implementation of this plan will ensure:

1. **High Quality**: Reduced defect rates and improved reliability
2. **Fast Feedback**: Rapid identification of issues
3. **Confidence**: Safe deployments with comprehensive coverage
4. **Documentation**: Tests serve as living documentation
5. **Scalability**: Testing infrastructure that grows with the platform

The phased approach allows for incremental improvements while maintaining development velocity. Priority is given to critical user paths and high-risk areas, ensuring maximum value from testing investments.

---

**Next Steps**:
1. Review and approve testing plan
2. Allocate resources and budget
3. Begin Phase 1 implementation
4. Establish weekly testing metrics reviews
5. Create testing center of excellence

*Document Version*: 1.0.0  
*Last Updated*: 2025-08-08  
*Status*: Ready for Implementation
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "CommonJS",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": false,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "removeComments": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitUseStrict": false,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/config/*": ["src/config/*"],
      "@/controllers/*": ["src/controllers/*"],
      "@/middleware/*": ["src/middleware/*"],
      "@/services/*": ["src/services/*"],
      "@/utils/*": ["src/utils/*"],
      "@/types/*": ["src/types/*"],
      "@/routes/*": ["src/routes/*"],
      "@/validators/*": ["src/validators/*"]
    }
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "logs",
    "uploads",
    "**/*.test.ts",
    "**/*.spec.ts"
  ],
  "ts-node": {
    "require": ["tsconfig-paths/register"]
  }
}
</file>

<file path=".claude/agents/agent-lead.txt">
You are the Agent Lead and Orchestration Layer in a multi-agent coding system. You are the central coordinator that manages all specialized agents and their interactions.

================================================================================
CRITICAL REQUIREMENT - TODO LIST AGENT ASSIGNMENTS
================================================================================
When creating ANY todo list, you MUST indicate which agent (or [SELF]) will handle each task.
Format: ☒ [AGENT] Task description
Example: ☒ [@frontend-agent] Create user profile component
Example: ☒ [SELF] Review integration points
Never create a todo item without an agent assignment!

================================================================================
AVAILABLE SPECIALIZED AGENTS
================================================================================
1. @frontend-agent - React/TypeScript UI Development
2. @backend-agent - Node.js/Express API Development
3. @database-agent - PostgreSQL Database Management
4. @testing-agent - Comprehensive Testing Strategies
5. @devops-agent - Infrastructure and Deployment
6. @docs-writer-agent - Documentation and Guides

================================================================================
TASK ASSIGNMENT GUIDE
================================================================================
AGENT LEAD [SELF] handles:
- Requirement analysis and project planning
- Task breakdown and dependency mapping
- Agent coordination and orchestration
- Integration validation between components
- Architecture decisions affecting multiple layers
- Progress monitoring and reporting
- Final quality assurance and sign-off

@frontend-agent handles:
- React component development
- State management implementation
- UI/UX and responsive design
- Client-side routing
- API integration in frontend
- Form handling and validation

@backend-agent handles:
- RESTful API development
- Authentication/authorization systems
- Business logic implementation
- Middleware development
- Data validation and processing
- External service integration

@database-agent handles:
- Schema design and optimization
- Migration scripts
- Query optimization and indexing
- Data modeling and relationships
- Database performance tuning

@testing-agent handles:
- Unit and integration testing
- End-to-end testing
- Performance testing
- Security testing
- Test automation setup

@devops-agent handles:
- Docker containerization
- CI/CD pipeline configuration
- Cloud infrastructure setup
- Monitoring and logging
- Deployment configuration

@docs-writer-agent handles:
- API documentation
- User guides and tutorials
- Technical specifications
- Architecture documentation
- README and setup guides

================================================================================
TODO LIST FORMAT EXAMPLES
================================================================================
⏺ Implement User Authentication
  ⎿  ☒ [SELF] Analyze requirements and design flow
     ☒ [@database-agent] Create users and sessions tables
     ☒ [@backend-agent] Implement JWT authentication
     ☒ [@backend-agent] Create auth endpoints
     ☒ [@frontend-agent] Build login/signup components
     ☒ [@frontend-agent] Implement auth context
     ☒ [@testing-agent] Write auth integration tests
     ☐ [@devops-agent] Configure auth environment
     ☐ [@docs-writer-agent] Document auth API
     ☐ [SELF] Validate complete integration

⏺ Fix Performance Issues
  ⎿  ☒ [SELF] Identify bottlenecks
     ☒ [@database-agent] Optimize queries and indexes
     ☒ [@backend-agent] Implement caching layer
     ☒ [@frontend-agent] Add React optimizations
     ☒ [@testing-agent] Create performance benchmarks
     ☐ [@devops-agent] Configure CDN
     ☐ [SELF] Verify improvements

================================================================================
ORCHESTRATION WORKFLOW
================================================================================
1. Requirement Analysis: Break down user request into atomic tasks
2. Agent Assignment: Assign each task to appropriate agent using [AGENT] tags
3. Dependency Mapping: Identify task relationships and execution order
4. Parallel Coordination: Execute independent tasks simultaneously
5. Integration Management: Coordinate handoffs between agents
6. Quality Gates: Validate deliverables before proceeding
7. Final Validation: Ensure complete system integration

================================================================================
AGENT INVOCATION PROTOCOL
================================================================================
When invoking agents for complex tasks, use:
```
@[AGENT_NAME] - TASK: [specific task]
CONTEXT: [relevant background]
DEPENDENCIES: [what this task depends on]
DELIVERABLES: [expected outputs]
PRIORITY: [high/medium/low]
```

================================================================================
KEY PRINCIPLES
================================================================================
- ALWAYS specify agent assignments in todo lists using [AGENT] notation
- NEVER write code directly - delegate all implementation to specialized agents
- Coordinate parallel work when tasks are independent
- Validate integration points between agent deliverables
- Maintain clear communication channels between agents
- Ensure no task is forgotten or duplicated
- Monitor progress and report status regularly

================================================================================
REMEMBER
================================================================================
The Agent Lead is the ORCHESTRATOR, not the IMPLEMENTER. Your role is to:
- Plan and coordinate
- Assign and delegate
- Monitor and validate
- Integrate and verify

All coding, testing, deployment, and documentation tasks must be delegated to the appropriate specialized agents.
</file>

<file path=".claude/agents/database-agent.txt">
You are the Database Agent in a multi-agent coding system specializing in the Interactive Learning Platform. You focus on PostgreSQL database design for education technology systems.

EXPERTISE:
- PostgreSQL advanced features (JSONB, arrays, full-text search, partitioning)
- Educational data modeling (users, content, progress tracking, analytics)
- Multi-tenant database architecture with role-based data isolation
- Video metadata and milestone timestamp storage optimization
- Learning analytics and progress tracking schemas
- Database migrations with zero-downtime deployments
- Performance optimization for concurrent student sessions
- GDPR-compliant data structures and retention policies

RESPONSIBILITIES:
- Design PostgreSQL schemas for users (students/teachers/admins), lessons, videos, milestones, questions, and progress tracking
- Create efficient data models for video annotations and AI-generated questions
- Implement multi-tenant data isolation with role-based access patterns
- Design learning analytics tables for real-time progress tracking
- Optimize queries for concurrent video streaming and question delivery
- Implement JSONB storage for flexible question types and metadata
- Create indexes for fast video milestone lookups and progress queries
- Design audit trails for compliance and educational data protection

CRITICAL SAFEGUARDS - NEVER DELETE EXISTING SCHEMA STRUCTURE:
⚠️  ABSOLUTELY FORBIDDEN OPERATIONS:
- NEVER delete or drop existing tables without explicit user permission
- NEVER remove existing columns that have active code dependencies
- NEVER delete existing relationships/foreign keys without coordination
- NEVER remove enums or constraints that are referenced in codebase
- NEVER perform destructive operations on production-equivalent schemas

✅  SAFE OPERATIONS ONLY:
- ADD new tables, columns, indexes, or constraints
- MODIFY column types with safe migrations (widening types)
- ADD new relationships alongside existing ones
- CREATE new migrations that preserve existing data
- OPTIMIZE queries without changing table structure
- ADD indexes for performance improvements

🔍  MANDATORY CHECKS BEFORE ANY SCHEMA CHANGES:
1. Verify existing codebase dependencies with grep/search
2. Check for service layer references to affected models
3. Identify frontend components using the data structures  
4. Confirm with other agents about breaking changes
5. Create migration scripts that preserve all existing data
6. Test schema changes in development before proposing

WORKFLOW:
1. Analyze data requirements and relationships
2. Design normalized database schema with proper constraints
3. Create migration scripts for schema changes
4. Implement indexing strategies for query optimization
5. Set up database monitoring and alerting
6. Plan backup and disaster recovery procedures
7. Coordinate with other agents on data access patterns

COMMUNICATION WITH OTHER AGENTS:
- Back-End Agent: Define data access patterns, ORM configurations, and query interfaces
- Front-End Agent: Optimize data structures for client-side consumption
- Testing Agent: Provide test data fixtures and database testing strategies
- DevOps Agent: Coordinate database deployment, migration automation, and backup strategies
- Docs Writer: Document database schema, migration procedures, and best practices

DATABASE DESIGN PRINCIPLES:
- Normalization and denormalization strategies
- ACID properties and transaction management
- Referential integrity and foreign key constraints
- Indexing for performance optimization
- Data partitioning and sharding strategies
- Connection pooling and resource management

SECURITY CONSIDERATIONS:
- Role-based access control (RBAC)
- Data encryption at rest and in transit
- SQL injection prevention
- Database auditing and logging
- Sensitive data handling and compliance
- Regular security assessments

PLATFORM-SPECIFIC FOCUS:
- User management with role hierarchy (admin > teacher > student)
- Lesson structure: lessons → video groups → videos → milestones → questions
- Progress tracking with session persistence across devices
- Video metadata integration with Google Cloud Storage references
- AI-generated question storage with approval workflows
- Retry attempt tracking and grading systems
- Real-time analytics for teacher dashboards

DELIVERABLES:
- PostgreSQL schema for educational platform (users, content, progress)
- Migration scripts using Prisma/TypeORM with TypeScript
- Optimized queries for video streaming and milestone delivery
- Indexes for fast student progress lookups and analytics
- Multi-tenant data isolation and security constraints
- Learning analytics tables and reporting queries
- Integration schemas for Google Cloud Storage and AI APIs
- GDPR-compliant data retention and deletion procedures
</file>

<file path="database/seeds/001_initial_data.ts">
// Interactive Learning Platform - Database Seed Data
// Initial data for development and testing
// Generated: 2025-08-07

import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcrypt';

const prisma = new PrismaClient();

async function main() {
  console.log('🌱 Starting database seeding...');

  // ========================================
  // SYSTEM CONFIGURATION
  // ========================================
  
  const systemConfigs = [
    {
      key: 'app.name',
      value: { name: 'Interactive Learning Platform' },
      description: 'Application name',
      category: 'general',
      isPublic: true
    },
    {
      key: 'app.version',
      value: { version: '1.0.0' },
      description: 'Application version',
      category: 'general',
      isPublic: true
    },
    {
      key: 'video.maxFileSize',
      value: { maxSize: 2147483648 }, // 2GB in bytes
      description: 'Maximum video file size',
      category: 'video',
      isPublic: false
    },
    {
      key: 'video.allowedFormats',
      value: { 
        formats: ['mp4', 'webm', 'mov', 'avi'],
        codecs: ['h264', 'vp9', 'vp8']
      },
      description: 'Allowed video formats and codecs',
      category: 'video',
      isPublic: true
    },
    {
      key: 'ai.defaultProvider',
      value: { provider: 'OPENAI' },
      description: 'Default AI provider for question generation',
      category: 'ai',
      isPublic: false
    },
    {
      key: 'grading.defaultRetryLimit',
      value: { retryLimit: 3 },
      description: 'Default number of retry attempts for questions',
      category: 'grading',
      isPublic: false
    },
    {
      key: 'grading.passingThreshold',
      value: { threshold: 0.7 },
      description: 'Default passing threshold (70%)',
      category: 'grading',
      isPublic: false
    },
    {
      key: 'analytics.enableTracking',
      value: { enabled: true },
      description: 'Enable analytics tracking',
      category: 'analytics',
      isPublic: false
    },
    {
      key: 'session.timeoutMinutes',
      value: { timeout: 30 },
      description: 'Session timeout in minutes',
      category: 'session',
      isPublic: false
    },
    {
      key: 'features.enableAIGeneration',
      value: { enabled: true },
      description: 'Enable AI question generation',
      category: 'features',
      isPublic: false
    }
  ];

  console.log('Creating system configurations...');
  for (const config of systemConfigs) {
    await prisma.systemConfig.upsert({
      where: { key: config.key },
      update: config,
      create: config
    });
  }

  // ========================================
  // DEMO USERS
  // ========================================
  
  const passwordHash = await bcrypt.hash('Demo123!', 10);
  
  const adminUser = await prisma.user.upsert({
    where: { email: 'admin@example.com' },
    update: {},
    create: {
      email: 'admin@example.com',
      firstName: 'System',
      lastName: 'Administrator',
      role: 'ADMIN',
      status: 'ACTIVE',
      passwordHash,
      emailVerified: new Date()
    }
  });

  const teacherUser = await prisma.user.upsert({
    where: { email: 'teacher@example.com' },
    update: {},
    create: {
      email: 'teacher@example.com',
      firstName: 'Demo',
      lastName: 'Teacher',
      role: 'TEACHER',
      status: 'ACTIVE',
      passwordHash,
      emailVerified: new Date()
    }
  });

  const studentUser = await prisma.user.upsert({
    where: { email: 'student@example.com' },
    update: {},
    create: {
      email: 'student@example.com',
      firstName: 'Demo',
      lastName: 'Student',
      role: 'STUDENT',
      status: 'ACTIVE',
      passwordHash,
      emailVerified: new Date()
    }
  });

  console.log('Created demo users:', {
    admin: adminUser.email,
    teacher: teacherUser.email,
    student: studentUser.email
  });

  // ========================================
  // USER PREFERENCES
  // ========================================
  
  await prisma.userPreference.upsert({
    where: { userId: studentUser.id },
    update: {},
    create: {
      userId: studentUser.id,
      autoplay: true,
      playbackSpeed: 1.0,
      subtitles: false,
      theme: 'light',
      language: 'en',
      emailNotifications: true,
      progressNotifications: true,
      allowAnalytics: true
    }
  });

  // ========================================
  // AI CONFIGURATION
  // ========================================
  
  const aiConfig = await prisma.aIConfiguration.upsert({
    where: { id: 'default-openai' },
    update: {},
    create: {
      id: 'default-openai',
      provider: 'OPENAI',
      name: 'Default OpenAI Configuration',
      model: 'gpt-3.5-turbo',
      parameters: {
        temperature: 0.7,
        maxTokens: 2000,
        topP: 1.0,
        frequencyPenalty: 0.0,
        presencePenalty: 0.0
      },
      isActive: true,
      rateLimit: 60, // requests per minute
      maxTokens: 4000,
      costPerToken: 0.0000015 // Example cost per token
    }
  });

  console.log('Created AI configuration:', aiConfig.name);

  // ========================================
  // DEMO LESSON STRUCTURE
  // ========================================
  
  const demoLesson = await prisma.lesson.create({
    data: {
      title: 'Introduction to Interactive Learning',
      description: 'Learn how to use the interactive video platform effectively',
      status: 'PUBLISHED',
      order: 1,
      createdById: teacherUser.id,
      objectives: [
        'Understand the basics of interactive video learning',
        'Learn how to answer milestone questions',
        'Navigate the learning platform effectively'
      ],
      estimatedTime: 30, // 30 minutes
      difficulty: 'beginner',
      tags: ['introduction', 'tutorial', 'basics'],
      publishedAt: new Date(),
      metadata: {
        category: 'Tutorial',
        isDemo: true
      }
    }
  });

  const videoGroup = await prisma.videoGroup.create({
    data: {
      lessonId: demoLesson.id,
      title: 'Getting Started',
      description: 'Introduction videos for new users',
      order: 1
    }
  });

  const demoVideo = await prisma.video.create({
    data: {
      videoGroupId: videoGroup.id,
      title: 'Welcome to Interactive Learning',
      description: 'A brief introduction to the platform features',
      order: 1,
      status: 'READY',
      filePath: 'demo/welcome-video.mp4',
      fileName: 'welcome-video.mp4',
      duration: 300,
      size: BigInt(10485760), // 10MB
      mimeType: 'video/mp4',
      thumbnailPath: 'demo/welcome-thumbnail.jpg',
      processingStatus: 'COMPLETED',
      uploadedAt: new Date(),
      processedAt: new Date()
    }
  });

  // Create milestones with sample questions
  const milestone1 = await prisma.milestone.create({
    data: {
      videoId: demoVideo.id,
      timestamp: 60.0, // 1 minute mark
      title: 'Platform Overview Check',
      description: 'Test your understanding of the platform overview',
      order: 1,
      isRequired: true,
      retryLimit: 3
    }
  });

  const milestone2 = await prisma.milestone.create({
    data: {
      videoId: demoVideo.id,
      timestamp: 180.0, // 3 minute mark
      title: 'Navigation Features Check',
      description: 'Verify you understand the navigation features',
      order: 2,
      isRequired: true,
      retryLimit: 3
    }
  });

  // Create sample questions
  const question1 = await prisma.question.create({
    data: {
      milestoneId: milestone1.id,
      type: 'MULTIPLE_CHOICE',
      status: 'APPROVED',
      text: 'What is the main purpose of milestone questions in this platform?',
      explanation: 'Milestone questions ensure comprehension before allowing students to continue.',
      hints: [
        'Think about why the video pauses',
        'Consider the educational goal'
      ],
      difficulty: 'easy',
      questionData: {
        options: [
          { id: '1', text: 'To pause the video randomly', isCorrect: false },
          { id: '2', text: 'To ensure understanding before proceeding', isCorrect: true },
          { id: '3', text: 'To make the video longer', isCorrect: false },
          { id: '4', text: 'To test technical knowledge', isCorrect: false }
        ]
      },
      points: 1,
      passThreshold: 1.0,
      createdById: teacherUser.id
    }
  });

  console.log('Created demo lesson structure:', {
    lesson: demoLesson.title,
    videoGroup: videoGroup.title,
    video: demoVideo.title,
    milestones: 2,
    questions: 2
  });

  // ========================================
  // SAMPLE STUDENT PROGRESS
  // ========================================
  
  const studentProgress = await prisma.studentProgress.create({
    data: {
      studentId: studentUser.id,
      lessonId: demoLesson.id,
      isCompleted: false,
      completionPercent: 40.0,
      totalTimeSpent: 120, // 2 minutes
      totalMilestones: 2,
      completedMilestones: 1,
      averageScore: 100.0,
      totalAttempts: 1,
      successfulAttempts: 1,
      progressData: {
        milestoneProgress: {
          [milestone1.id]: {
            completed: true,
            attempts: 1,
            score: 100,
            timeSpent: 45
          },
          [milestone2.id]: {
            completed: false,
            attempts: 0,
            score: 0,
            timeSpent: 0
          }
        },
        videoProgress: {
          [demoVideo.id]: {
            watchTime: 120,
            completionPercentage: 40,
            lastPosition: 120
          }
        }
      }
    }
  });

  // Create a student session
  const studentSession = await prisma.studentSession.create({
    data: {
      studentId: studentUser.id,
      videoId: demoVideo.id,
      status: 'PAUSED',
      currentPosition: 120.0,
      lastMilestoneId: milestone1.id,
      completedMilestones: [milestone1.id],
      deviceInfo: {
        platform: 'Web',
        browser: 'Chrome',
        version: '91.0.4472.124',
        mobile: false,
        screenResolution: '1920x1080'
      },
      startedAt: new Date(Date.now() - 3600000), // Started 1 hour ago
      lastSeenAt: new Date(Date.now() - 1800000)  // Last seen 30 minutes ago
    }
  });

  // Create a sample question attempt
  const questionAttempt = await prisma.questionAttempt.create({
    data: {
      studentId: studentUser.id,
      questionId: question1.id,
      status: 'CORRECT',
      attemptNumber: 1,
      studentAnswer: { selectedOption: '2' },
      isCorrect: true,
      score: 1.0,
      timeSpent: 30,
      hintsUsed: [],
      feedback: 'Correct! Milestone questions ensure understanding.',
      submittedAt: new Date(Date.now() - 1800000)
    }
  });

  // Create grade record
  const grade = await prisma.grade.create({
    data: {
      studentId: studentUser.id,
      studentProgressId: studentProgress.id,
      totalPoints: 2,
      earnedPoints: 1,
      percentageScore: 50.0,
      status: 'IN_PROGRESS',
      totalAttempts: 1,
      remainingAttempts: 2,
      gradeBreakdown: {
        milestones: {
          [milestone1.id]: {
            totalPoints: 1,
            earnedPoints: 1,
            percentage: 100,
            attempts: 1
          },
          [milestone2.id]: {
            totalPoints: 1,
            earnedPoints: 0,
            percentage: 0,
            attempts: 0
          }
        },
        questionTypes: {
          'MULTIPLE_CHOICE': {
            totalQuestions: 1,
            correctAnswers: 1,
            averageScore: 100
          },
          'TRUE_FALSE': {
            totalQuestions: 1,
            correctAnswers: 0,
            averageScore: 0
          }
        },
        timeMetrics: {
          totalTime: 30,
          averageTimePerQuestion: 30,
          efficiency: 0.85
        }
      }
    }
  });

  console.log('Created sample student progress and session data');

  // ========================================
  // SAMPLE ANALYTICS EVENTS
  // ========================================
  
  const analyticsEvents = [
    {
      userId: studentUser.id,
      sessionId: studentSession.id,
      eventType: 'video_start',
      eventData: {
        videoId: demoVideo.id,
        position: 0,
        playbackSpeed: 1.0
      },
      context: {
        sessionId: studentSession.id,
        deviceType: 'desktop',
        browserName: 'Chrome',
        browserVersion: '91.0.4472.124',
        screenResolution: '1920x1080'
      },
      timestamp: new Date(Date.now() - 3600000)
    },
    {
      userId: studentUser.id,
      sessionId: studentSession.id,
      eventType: 'milestone_reached',
      eventData: {
        videoId: demoVideo.id,
        position: 60,
        milestoneId: milestone1.id
      },
      context: {
        sessionId: studentSession.id,
        deviceType: 'desktop',
        browserName: 'Chrome',
        browserVersion: '91.0.4472.124',
        screenResolution: '1920x1080'
      },
      timestamp: new Date(Date.now() - 3540000)
    },
    {
      userId: studentUser.id,
      sessionId: studentSession.id,
      eventType: 'question_attempt',
      eventData: {
        questionId: question1.id,
        questionType: 'MULTIPLE_CHOICE',
        attemptNumber: 1,
        correct: true,
        timeSpent: 30
      },
      context: {
        sessionId: studentSession.id,
        deviceType: 'desktop',
        browserName: 'Chrome',
        browserVersion: '91.0.4472.124',
        screenResolution: '1920x1080'
      },
      timestamp: new Date(Date.now() - 3510000)
    }
  ];

  for (const event of analyticsEvents) {
    await prisma.analyticsEvent.create({ data: event });
  }

  console.log('Created sample analytics events');

  // ========================================
  // AUDIT LOGS
  // ========================================
  
  await prisma.auditLog.create({
    data: {
      userId: teacherUser.id,
      action: 'CREATE',
      resource: 'lessons',
      resourceId: demoLesson.id,
      changes: {
        after: {
          title: demoLesson.title,
          status: 'PUBLISHED'
        }
      },
      metadata: {
        source: 'seed_script',
        reason: 'Initial demo content creation'
      }
    }
  });

  await prisma.auditLog.create({
    data: {
      userId: studentUser.id,
      action: 'LOGIN',
      resource: 'users',
      resourceId: studentUser.id,
      metadata: {
        source: 'seed_script',
        ipAddress: '127.0.0.1'
      }
    }
  });

  console.log('Created audit log entries');

  console.log('✅ Database seeding completed successfully!');
  
  // Summary
  console.log('\n📊 Seeding Summary:');
  console.log('- System configurations: 10');
  console.log('- Demo users: 3 (Admin, Teacher, Student)');
  console.log('- Demo lesson with video and milestones: 1');
  console.log('- Sample questions: 2');
  console.log('- Student progress tracking: Created');
  console.log('- Analytics events: 3');
  console.log('- Audit logs: 2');
  
  console.log('\n🔐 Demo Login Credentials:');
  console.log('Admin: admin@example.com / Demo123!');
  console.log('Teacher: teacher@example.com / Demo123!');
  console.log('Student: student@example.com / Demo123!');
}

main()
  .catch((e) => {
    console.error('❌ Error during seeding:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
</file>

<file path="docs/COMMON_ERRORS.md">
# Common Development Errors & Solutions

This document catalogs recurring errors encountered during development and their solutions to prevent future occurrences.

## JavaScript/Node.js Serialization Issues

### 1. BigInt Serialization Error

**Error Message:**
```
Do not know how to serialize a BigInt
```

**Root Cause:**
- Prisma database fields with `BigInt` type (e.g., file sizes, large numbers)
- Node.js `JSON.stringify()` cannot serialize BigInt values natively
- Occurs when returning API responses containing BigInt fields

**Database Schema Example:**
```prisma
model Video {
  id       String  @id @default(cuid())
  size     BigInt? // File size in bytes - THIS CAUSES THE ERROR
  // ... other fields
}
```

**Solution:**
Add BigInt-to-string conversion in controllers before sending responses:

```typescript
// Convert BigInt values to strings to avoid serialization issues
const processedData = JSON.parse(JSON.stringify(data, (key, value) =>
  typeof value === 'bigint' ? value.toString() : value
));

res.json({
  success: true,
  data: processedData
});
```

**Prevention:**
- Always test API endpoints after adding BigInt fields to schema
- Consider using `String` or `Int` types for most numeric fields
- Only use `BigInt` when truly necessary for large numbers (> 2^53)

## Prisma Common Issues

### 2. Query Performance with Nested Relations

**Symptoms:**
- Slow API responses
- High database CPU usage
- Timeouts on complex queries

**Common Causes:**
```typescript
// PROBLEMATIC: Deep nesting without select optimization
const lessons = await prisma.lesson.findMany({
  include: {
    videoGroups: {
      include: {
        videos: {
          include: {
            milestones: {
              include: {
                questions: true // TOO DEEP
              }
            }
          }
        }
      }
    }
  }
});
```

**Solution:**
```typescript
// OPTIMIZED: Use select to limit fields and depth
const lessons = await prisma.lesson.findMany({
  select: {
    id: true,
    title: true,
    description: true,
    videoGroups: {
      select: {
        id: true,
        title: true,
        videos: {
          select: {
            id: true,
            title: true,
            duration: true,
            _count: {
              select: { milestones: true }
            }
          }
        }
      }
    }
  }
});
```

### 3. Multi-tenant Data Isolation

**Error:** Students/teachers accessing data from other tenants

**Root Cause:** Missing tenant filtering in queries

**Solution:**
```typescript
// ALWAYS add tenant filtering when applicable
const where: any = { id };

// Multi-tenant filtering
if (currentUser.tenantId) {
  where.tenantId = currentUser.tenantId;
}

const lesson = await prisma.lesson.findFirst({ where });
```

## Express.js API Issues

### 4. Missing Error Handling

**Problem:** Unhandled promise rejections causing server crashes

**Solution Pattern:**
```typescript
export const controllerMethod = {
  async methodName(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      // Your logic here
      
      res.json({ success: true, data: result });
    } catch (error) {
      logger.error('Error in methodName:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to perform operation'
      });
      return; // Important: explicit return
    }
  }
};
```

### 5. Authentication Token Issues

**Symptoms:**
- 401 Unauthorized errors
- "jwt malformed" errors
- Expired token errors

**Common Causes:**
- Expired JWT tokens
- Missing Authorization header
- Incorrect Bearer token format

**Debug Steps:**
1. Check token expiration in JWT payload
2. Verify Authorization header format: `Bearer <token>`
3. Check JWT_SECRET environment variable
4. Validate token issuer/audience claims

## Frontend Integration Issues

### 6. Video Upload File/URL Mismatch

**Error Message:** "Video file is required"

**Symptoms:**
- Video upload fails with 400 Bad Request
- Request shows `"data": "{\"video\":{},\"title\":\"test\"}"`
- Content-Type is `application/json` instead of `multipart/form-data`
- Debug info shows `bodyKeys: ["video", "title"]` instead of `["videoUrl", "title"]`

**Root Cause:** Frontend sending wrong field names or using deprecated component:

1. **File Upload**: Requires `FormData` with actual file and `multipart/form-data`
2. **URL-based Video**: Requires JSON with `videoUrl` field and `application/json`

**Problematic Pattern:**
```typescript
// WRONG: Sending empty video object to file upload endpoint
await videoService.post('/videos/groups/123/videos', {
  video: {}, // ← Empty object instead of File or URL
  title: 'test'
})
```

**Solution - Use correct upload method:**

```typescript
// For FILE uploads - use uploadVideoFile()
await videoService.uploadVideoFile(groupId, file, {
  title: 'Video Title',
  description: 'Optional description'
})

// For URL-based videos - use addVideoToGroup()
await videoService.addVideoToGroup(groupId, {
  title: 'Video Title', 
  videoUrl: 'https://example.com/video.mp4',
  description: 'Optional description',
  duration: 300, // optional
  thumbnailUrl: 'https://example.com/thumb.jpg' // optional
})
```

**Backend Fix Applied:** Updated endpoint to handle both multipart file uploads and JSON URL requests conditionally.

### 7. Authentication Routing Issues

**Problem:** Teachers redirected to `/teacher/dashboard` instead of `/dashboard` after login

**Symptoms:**
- Users see empty page after successful login
- URL shows `/teacher/dashboard` which doesn't exist in routing
- Browser console shows navigation errors

**Root Cause:** Incorrect role-based redirects in `ProtectedRoute.tsx`:
```typescript
// PROBLEMATIC: Non-existent route
const roleRedirects = {
  STUDENT: '/dashboard',
  TEACHER: '/teacher/dashboard', // ← This route doesn't exist
  ADMIN: '/admin/dashboard'      // ← This route doesn't exist
}
```

**Solution:** All roles should redirect to the unified `/dashboard` route:
```typescript
// CORRECT: All roles use the same dashboard
const roleRedirects = {
  STUDENT: '/dashboard',
  TEACHER: '/dashboard',
  ADMIN: '/dashboard'
}
```

**Location:** `frontend/src/components/auth/ProtectedRoute.tsx` (lines 41-45 and 81-85)

### 7. CORS and Request Headers

**Error:** CORS policy blocks requests

**Solution:** Ensure proper headers in API requests:
```typescript
const response = await apiService.get('/endpoint', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
});
```

### 7. TypeScript Type Mismatches

**Problem:** Frontend types don't match API response structure

**Solution:** 
- Keep types synchronized between frontend and backend
- Use shared type definitions when possible
- Validate API responses in development

```typescript
// Shared types
interface LessonWithVideos {
  id: string;
  title: string;
  videoGroups: VideoGroup[];
  // Ensure BigInt fields are typed as strings after serialization
  size?: string; // Not BigInt!
}
```

## Database Migration Issues

### 8. Schema Changes Breaking Existing Data

**Prevention:**
- Always backup database before migrations
- Test migrations on development data first
- Use nullable fields for new required columns
- Consider data migration scripts for complex changes

```bash
# Safe migration workflow
npm run db:backup
npm run db:migrate:dev
npm run test
npm run db:migrate:production
```

## Testing & Debugging

### 9. Inconsistent Test Data

**Problem:** Tests passing locally but failing in CI

**Solution:**
- Use deterministic test data
- Clean database between tests
- Avoid timezone-dependent comparisons
- Mock external dependencies

### 10. Environment Variable Issues

**Symptoms:**
- Connection errors
- Missing configuration
- Different behavior between environments

**Checklist:**
- Verify `.env` file exists and is loaded
- Check all required variables are set
- Validate environment-specific values
- Use `.env.example` as template

```bash
# Debug environment variables
node -e "console.log(process.env.DATABASE_URL)"
```

## Monitoring & Production Issues

### 11. Memory Leaks

**Warning Signs:**
- Gradually increasing memory usage
- Server crashes with out-of-memory errors
- Slow response times over time

**Common Causes:**
- Unclosed database connections
- Event listeners not removed
- Large objects not garbage collected
- Missing connection pooling

**Prevention:**
```typescript
// Always handle cleanup
process.on('SIGTERM', async () => {
  await prisma.$disconnect();
  process.exit(0);
});
```

---

## Quick Reference Commands

```bash
# Check server logs
npm run dev

# Test specific endpoint
curl -H "Authorization: Bearer <token>" http://localhost:3000/api/v1/endpoint

# Database inspection
npx prisma studio

# Reset development database
npx prisma migrate reset --force

# Check environment variables
printenv | grep -E "(DATABASE_URL|JWT_SECRET)"
```

## Frontend Code Quality Issues

### 12. ESLint Common Violations

**Most Frequent Issues Found (130+ errors):**

1. **TypeScript `any` Type Usage (60+ occurrences)**
   - Files affected: Most service files, context files, utility files
   - Pattern: `@typescript-eslint/no-explicit-any`
   
   **Fix:** Replace `any` with proper types:
   ```typescript
   // BAD
   } catch (error: any) {
   
   // GOOD
   } catch (error: unknown) {
     const message = error instanceof Error ? error.message : 'Unknown error'
   ```

2. **React Refresh Export Issues (40+ occurrences)**
   - Files affected: Context files, utility files
   - Pattern: `react-refresh/only-export-components`
   
   **Fix:** Move non-component exports to separate files:
   ```typescript
   // BAD - mixing exports in component file
   export const useAuth = () => {...}
   export const AuthProvider = () => {...}
   
   // GOOD - separate files
   // hooks/useAuth.ts
   export const useAuth = () => {...}
   // components/AuthProvider.tsx
   export const AuthProvider = () => {...}
   ```

3. **Unused Variables (Multiple occurrences)**
   - Pattern: `@typescript-eslint/no-unused-vars`
   - Common in: Event handlers, destructured objects
   
   **Fix:** Prefix with underscore or remove:
   ```typescript
   // BAD
   const { data, error } = response // error unused
   
   // GOOD
   const { data, _error } = response
   // OR
   const { data } = response
   ```

4. **Case Block Declarations**
   - Pattern: `no-case-declarations`
   - Files: QuestionOverlay.tsx
   
   **Fix:** Wrap case blocks in braces:
   ```typescript
   // BAD
   switch(type) {
     case 'MULTIPLE_CHOICE':
       const options = data.options
       break
   }
   
   // GOOD
   switch(type) {
     case 'MULTIPLE_CHOICE': {
       const options = data.options
       break
     }
   }
   ```

5. **Missing useEffect Dependencies**
   - Pattern: `react-hooks/exhaustive-deps`
   - Files: VideoPlayer.tsx, BaseLessonPage.tsx
   
   **Fix:** Include all dependencies or use useCallback:
   ```typescript
   // Use useCallback for stable function references
   const loadData = useCallback(() => {
     // function body
   }, [dependencies])
   
   useEffect(() => {
     loadData()
   }, [loadData])
   ```

### 13. Dead Code and Unused Files

**Files to Review for Removal:**
- `frontend/src/contexts/AuthContext.old.tsx` - Old authentication context
- `frontend/src/services/api.old.ts` - Old API service
- `frontend/src/services/auth.old.ts` - Old auth service

**Recommendation:** Archive or remove `.old` files after confirming they're not needed.

---

*Last Updated: January 2025*  
*Maintainer: Development Team*
</file>

<file path="frontend/src/components/auth/ProtectedRoute.tsx">
import React from 'react'
import { Navigate, useLocation } from 'react-router-dom'
import { useAuthStatus } from '../../contexts/AuthContext'
import LoadingSpinner from '../ui/LoadingSpinner'

interface ProtectedRouteProps {
  children: React.ReactNode
  requiredRole?: 'STUDENT' | 'TEACHER' | 'ADMIN'
  fallback?: React.ReactNode
  redirectTo?: string
}

export function ProtectedRoute({ 
  children, 
  requiredRole,
  fallback = <LoadingSpinner fullScreen />,
  redirectTo = '/login'
}: ProtectedRouteProps) {
  const { isAuthenticated, isInitialized, isLoading, user } = useAuthStatus()
  const location = useLocation()

  // Show loading while auth is initializing
  if (!isInitialized || isLoading) {
    return <>{fallback}</>
  }

  // Not authenticated - redirect to login
  if (!isAuthenticated) {
    return (
      <Navigate 
        to={redirectTo} 
        state={{ from: location.pathname }} 
        replace 
      />
    )
  }

  // Check role if required
  if (requiredRole && user?.role !== requiredRole) {
    // Redirect based on user's actual role
    const roleRedirects = {
      STUDENT: '/dashboard',
      TEACHER: '/dashboard',
      ADMIN: '/dashboard'
    }
    
    const userRedirect = roleRedirects[user?.role as keyof typeof roleRedirects] || '/dashboard'
    
    return (
      <Navigate 
        to={userRedirect} 
        state={{ 
          message: `You don't have permission to access this page. Required role: ${requiredRole}` 
        }} 
        replace 
      />
    )
  }

  // All checks passed - render children
  return <>{children}</>
}

// Public route that redirects to dashboard if already authenticated
export function PublicRoute({ 
  children,
  redirectTo = '/dashboard'
}: {
  children: React.ReactNode
  redirectTo?: string
}) {
  const { isAuthenticated, isInitialized, user } = useAuthStatus()

  // Show loading while auth is initializing
  if (!isInitialized) {
    return <LoadingSpinner fullScreen />
  }

  // Already authenticated - redirect based on role
  if (isAuthenticated && user) {
    const roleRedirects = {
      STUDENT: '/dashboard',
      TEACHER: '/dashboard',
      ADMIN: '/dashboard'
    }
    
    const redirect = roleRedirects[user.role as keyof typeof roleRedirects] || redirectTo
    return <Navigate to={redirect} replace />
  }

  // Not authenticated - show public content
  return <>{children}</>
}
</file>

<file path="frontend/src/components/dashboard/AdminDashboard.tsx">
import { useState, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import type { User } from '../../types/auth'

interface AdminDashboardProps {
  user: User
}

interface AdminStats {
  totalUsers: number
  totalLessons: number
  totalVideos: number
  totalWatchHours: number
  systemHealth: {
    apiStatus: 'healthy' | 'warning' | 'critical'
    dbStatus: 'healthy' | 'warning' | 'critical'
    storageUsage: number
    activeUsers: number
  }
  recentUsers: Array<{
    id: string
    name: string
    role: string
    joinedAt: string
    lastActive: string
  }>
  platformActivity: Array<{
    type: 'user_registered' | 'lesson_created' | 'video_uploaded' | 'system_alert'
    description: string
    timestamp: string
    severity?: 'info' | 'warning' | 'critical'
  }>
}

export function AdminDashboard({ user }: AdminDashboardProps) {
  const navigate = useNavigate()
  const [stats, setStats] = useState<AdminStats | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    loadDashboardData()
  }, [])

  const loadDashboardData = async () => {
    try {
      // This would normally fetch from API
      // For now, using mock data
      setStats({
        totalUsers: 1247,
        totalLessons: 156,
        totalVideos: 842,
        totalWatchHours: 5420.5,
        systemHealth: {
          apiStatus: 'healthy',
          dbStatus: 'healthy',
          storageUsage: 68.5,
          activeUsers: 89
        },
        recentUsers: [
          {
            id: '1',
            name: 'Alice Johnson',
            role: 'STUDENT',
            joinedAt: '2024-01-15T10:30:00Z',
            lastActive: '2024-01-15T15:45:00Z'
          },
          {
            id: '2',
            name: 'Bob Smith',
            role: 'TEACHER',
            joinedAt: '2024-01-15T09:15:00Z',
            lastActive: '2024-01-15T14:20:00Z'
          },
          {
            id: '3',
            name: 'Carol Davis',
            role: 'STUDENT',
            joinedAt: '2024-01-14T16:45:00Z',
            lastActive: '2024-01-15T11:30:00Z'
          }
        ],
        platformActivity: [
          {
            type: 'user_registered',
            description: '5 new users registered today',
            timestamp: '2024-01-15T16:00:00Z',
            severity: 'info'
          },
          {
            type: 'lesson_created',
            description: 'Dr. Smith created "Advanced Machine Learning" lesson',
            timestamp: '2024-01-15T14:30:00Z',
            severity: 'info'
          },
          {
            type: 'system_alert',
            description: 'Database backup completed successfully',
            timestamp: '2024-01-15T12:00:00Z',
            severity: 'info'
          },
          {
            type: 'system_alert',
            description: 'Storage usage approaching 70% capacity',
            timestamp: '2024-01-15T10:15:00Z',
            severity: 'warning'
          }
        ]
      })
    } catch (error) {
      console.error('Error loading admin dashboard data:', error)
    } finally {
      setLoading(false)
    }
  }

  const formatDate = (dateString: string) => {
    const date = new Date(dateString)
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'healthy': return 'text-green-600 bg-green-100'
      case 'warning': return 'text-yellow-600 bg-yellow-100'
      case 'critical': return 'text-red-600 bg-red-100'
      default: return 'text-gray-600 bg-gray-100'
    }
  }

  const getActivityIcon = (type: string) => {
    switch (type) {
      case 'user_registered': return '👥'
      case 'lesson_created': return '📚'
      case 'video_uploaded': return '🎥'
      case 'system_alert': return '⚠️'
      default: return '📝'
    }
  }

  const getSeverityColor = (severity?: string) => {
    switch (severity) {
      case 'warning': return 'border-l-yellow-400 bg-yellow-50'
      case 'critical': return 'border-l-red-400 bg-red-50'
      default: return 'border-l-blue-400 bg-blue-50'
    }
  }

  if (loading) {
    return (
      <div className="p-6">
        <div className="flex items-center justify-center h-64">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading admin dashboard...</p>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="p-6">
      <div className="mb-8">
        <h1 className="text-2xl font-bold text-gray-900">
          Admin Dashboard
        </h1>
        <p className="text-gray-600">
          System overview and platform management tools.
        </p>
      </div>

      {/* System Stats Overview */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <div className="card text-center">
          <div className="text-3xl font-bold text-blue-600 mb-2">
            {stats?.totalUsers.toLocaleString() || 0}
          </div>
          <div className="text-sm text-gray-600">Total Users</div>
        </div>
        
        <div className="card text-center">
          <div className="text-3xl font-bold text-green-600 mb-2">
            {stats?.totalLessons || 0}
          </div>
          <div className="text-sm text-gray-600">Total Lessons</div>
        </div>
        
        <div className="card text-center">
          <div className="text-3xl font-bold text-purple-600 mb-2">
            {stats?.totalVideos || 0}
          </div>
          <div className="text-sm text-gray-600">Total Videos</div>
        </div>
        
        <div className="card text-center">
          <div className="text-3xl font-bold text-yellow-600 mb-2">
            {stats?.totalWatchHours.toLocaleString() || 0}h
          </div>
          <div className="text-sm text-gray-600">Total Watch Hours</div>
        </div>
      </div>

      {/* System Health */}
      <div className="card mb-8">
        <h3 className="text-lg font-semibold text-gray-900 mb-4">
          System Health
        </h3>
        
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          <div className="text-center">
            <div className={`inline-flex px-3 py-1 rounded-full text-sm font-medium ${getStatusColor(stats?.systemHealth.apiStatus || 'healthy')}`}>
              API: {stats?.systemHealth.apiStatus || 'Unknown'}
            </div>
          </div>
          
          <div className="text-center">
            <div className={`inline-flex px-3 py-1 rounded-full text-sm font-medium ${getStatusColor(stats?.systemHealth.dbStatus || 'healthy')}`}>
              Database: {stats?.systemHealth.dbStatus || 'Unknown'}
            </div>
          </div>
          
          <div className="text-center">
            <div className="text-sm text-gray-600 mb-1">Storage Usage</div>
            <div className="w-full bg-gray-200 rounded-full h-2">
              <div 
                className={`h-2 rounded-full ${
                  (stats?.systemHealth.storageUsage || 0) > 80 
                    ? 'bg-red-600' 
                    : (stats?.systemHealth.storageUsage || 0) > 60 
                    ? 'bg-yellow-600' 
                    : 'bg-green-600'
                }`}
                style={{ width: `${stats?.systemHealth.storageUsage || 0}%` }}
              ></div>
            </div>
            <div className="text-xs text-gray-500 mt-1">
              {stats?.systemHealth.storageUsage || 0}% used
            </div>
          </div>
          
          <div className="text-center">
            <div className="text-2xl font-bold text-blue-600">
              {stats?.systemHealth.activeUsers || 0}
            </div>
            <div className="text-sm text-gray-600">Active Users</div>
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
        {/* Recent Users */}
        <div className="card">
          <h3 className="text-lg font-semibold text-gray-900 mb-4">
            Recent Users
          </h3>
          
          {stats?.recentUsers && stats.recentUsers.length > 0 ? (
            <div className="space-y-3">
              {stats.recentUsers.map((user) => (
                <div key={user.id} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                  <div>
                    <h4 className="font-medium text-gray-900">{user.name}</h4>
                    <div className="flex items-center space-x-2 text-sm text-gray-600">
                      <span className={`px-2 py-1 rounded-full text-xs ${
                        user.role === 'ADMIN' ? 'bg-red-100 text-red-700' :
                        user.role === 'TEACHER' ? 'bg-blue-100 text-blue-700' :
                        'bg-gray-100 text-gray-700'
                      }`}>
                        {user.role}
                      </span>
                      <span>Joined {formatDate(user.joinedAt).split(' ')[0]}</span>
                    </div>
                  </div>
                  <div className="text-sm text-gray-500">
                    Last active: {formatDate(user.lastActive).split(' ')[1]}
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="text-center py-8 text-gray-500">
              No recent user activity
            </div>
          )}
        </div>

        {/* Platform Activity */}
        <div className="card">
          <h3 className="text-lg font-semibold text-gray-900 mb-4">
            Platform Activity
          </h3>
          
          {stats?.platformActivity && stats.platformActivity.length > 0 ? (
            <div className="space-y-3">
              {stats.platformActivity.map((activity, index) => (
                <div key={index} className={`flex items-start space-x-3 p-3 rounded-lg border-l-4 ${getSeverityColor(activity.severity)}`}>
                  <div className="text-lg">{getActivityIcon(activity.type)}</div>
                  <div className="flex-1">
                    <p className="text-sm font-medium text-gray-900">
                      {activity.description}
                    </p>
                    <p className="text-xs text-gray-500 mt-1">
                      {formatDate(activity.timestamp)}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="text-center py-8 text-gray-500">
              No recent platform activity
            </div>
          )}
        </div>
      </div>

      {/* Admin Actions */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <button
          onClick={() => navigate('/lessons')}
          className="card hover:bg-blue-50 border hover:border-blue-200 transition-all text-center p-6"
        >
          <div className="text-3xl mb-3">👥</div>
          <div className="font-semibold text-blue-600">Manage Users</div>
          <div className="text-sm text-gray-600 mt-2">
            View and manage user accounts
          </div>
        </button>

        <button
          onClick={() => navigate('/lessons')}
          className="card hover:bg-green-50 border hover:border-green-200 transition-all text-center p-6"
        >
          <div className="text-3xl mb-3">📚</div>
          <div className="font-semibold text-green-600">Content Management</div>
          <div className="text-sm text-gray-600 mt-2">
            Oversee lessons and content
          </div>
        </button>

        <button
          onClick={() => navigate('/lessons')}
          className="card hover:bg-purple-50 border hover:border-purple-200 transition-all text-center p-6"
        >
          <div className="text-3xl mb-3">📊</div>
          <div className="font-semibold text-purple-600">Analytics</div>
          <div className="text-sm text-gray-600 mt-2">
            Platform-wide analytics
          </div>
        </button>

        <button
          onClick={() => navigate('/lessons')}
          className="card hover:bg-yellow-50 border hover:border-yellow-200 transition-all text-center p-6"
        >
          <div className="text-3xl mb-3">⚙️</div>
          <div className="font-semibold text-yellow-600">System Settings</div>
          <div className="text-sm text-gray-600 mt-2">
            Configure platform settings
          </div>
        </button>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/dashboard/TeacherDashboard.tsx">
import { useState, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import type { User } from '../../types/auth'

interface TeacherDashboardProps {
  user: User
}

interface TeacherStats {
  totalLessons: number
  totalStudents: number
  totalWatchHours: number
  averageEngagement: number
  recentActivity: Array<{
    type: 'lesson_created' | 'student_completed' | 'question_answered'
    description: string
    timestamp: string
  }>
  topLessons: Array<{
    lessonId: string
    title: string
    completionRate: number
    studentCount: number
  }>
}

export function TeacherDashboard({ user }: TeacherDashboardProps) {
  const navigate = useNavigate()
  const [stats, setStats] = useState<TeacherStats | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    loadDashboardData()
  }, [])

  const loadDashboardData = async () => {
    try {
      // This would normally fetch from API
      // For now, using mock data
      setStats({
        totalLessons: 8,
        totalStudents: 45,
        totalWatchHours: 120.5,
        averageEngagement: 78.5,
        recentActivity: [
          {
            type: 'student_completed',
            description: 'Sarah Johnson completed "Introduction to React"',
            timestamp: '2024-01-15T14:30:00Z'
          },
          {
            type: 'lesson_created',
            description: 'Created new lesson "Advanced JavaScript Patterns"',
            timestamp: '2024-01-15T10:15:00Z'
          },
          {
            type: 'question_answered',
            description: '25 students answered questions in "JavaScript Fundamentals"',
            timestamp: '2024-01-14T16:45:00Z'
          }
        ],
        topLessons: [
          {
            lessonId: '1',
            title: 'Introduction to React',
            completionRate: 92,
            studentCount: 28
          },
          {
            lessonId: '2',
            title: 'JavaScript Fundamentals',
            completionRate: 85,
            studentCount: 35
          },
          {
            lessonId: '3',
            title: 'CSS Grid and Flexbox',
            completionRate: 78,
            studentCount: 22
          }
        ]
      })
    } catch (error) {
      console.error('Error loading teacher dashboard data:', error)
    } finally {
      setLoading(false)
    }
  }

  const formatDate = (dateString: string) => {
    const date = new Date(dateString)
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
  }

  const getActivityIcon = (type: string) => {
    switch (type) {
      case 'lesson_created':
        return '📚'
      case 'student_completed':
        return '🎉'
      case 'question_answered':
        return '💭'
      default:
        return '📝'
    }
  }

  if (loading) {
    return (
      <div className="p-6">
        <div className="flex items-center justify-center h-64">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading dashboard...</p>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="p-6">
      <div className="mb-8">
        <h1 className="text-2xl font-bold text-gray-900">
          Welcome back, {user.firstName}!
        </h1>
        <p className="text-gray-600">
          Here's an overview of your teaching activities and student progress.
        </p>
      </div>

      {/* Stats Overview */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <div className="card text-center">
          <div className="text-3xl font-bold text-blue-600 mb-2">
            {stats?.totalLessons || 0}
          </div>
          <div className="text-sm text-gray-600">Total Lessons</div>
        </div>
        
        <div className="card text-center">
          <div className="text-3xl font-bold text-green-600 mb-2">
            {stats?.totalStudents || 0}
          </div>
          <div className="text-sm text-gray-600">Active Students</div>
        </div>
        
        <div className="card text-center">
          <div className="text-3xl font-bold text-purple-600 mb-2">
            {stats?.totalWatchHours.toFixed(1) || 0}h
          </div>
          <div className="text-sm text-gray-600">Total Watch Hours</div>
        </div>
        
        <div className="card text-center">
          <div className="text-3xl font-bold text-yellow-600 mb-2">
            {stats?.averageEngagement.toFixed(1) || 0}%
          </div>
          <div className="text-sm text-gray-600">Avg Engagement</div>
        </div>
      </div>

      {/* Quick Actions */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
        <button
          onClick={() => navigate('/teacher/create-lesson')}
          className="card hover:bg-blue-50 border-2 border-dashed border-blue-300 hover:border-blue-400 transition-all text-center p-6"
        >
          <div className="text-4xl mb-3">➕</div>
          <div className="font-semibold text-blue-600">Create New Lesson</div>
          <div className="text-sm text-gray-600 mt-2">
            Start building your next interactive lesson
          </div>
        </button>

        <button
          onClick={() => navigate('/teacher/lessons')}
          className="card hover:bg-green-50 border hover:border-green-200 transition-all text-center p-6"
        >
          <div className="text-4xl mb-3">📊</div>
          <div className="font-semibold text-green-600">View Analytics</div>
          <div className="text-sm text-gray-600 mt-2">
            Track student progress and engagement
          </div>
        </button>

        <button
          onClick={() => navigate('/teacher/lessons')}
          className="card hover:bg-purple-50 border hover:border-purple-200 transition-all text-center p-6"
        >
          <div className="text-4xl mb-3">🎥</div>
          <div className="font-semibold text-purple-600">Manage Content</div>
          <div className="text-sm text-gray-600 mt-2">
            Edit existing lessons and videos
          </div>
        </button>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        {/* Recent Activity */}
        <div className="card">
          <h3 className="text-lg font-semibold text-gray-900 mb-4">
            Recent Activity
          </h3>
          
          {stats?.recentActivity && stats.recentActivity.length > 0 ? (
            <div className="space-y-4">
              {stats.recentActivity.map((activity, index) => (
                <div key={index} className="flex items-start space-x-3 p-3 bg-gray-50 rounded-lg">
                  <div className="text-xl">{getActivityIcon(activity.type)}</div>
                  <div className="flex-1">
                    <p className="text-sm font-medium text-gray-900">
                      {activity.description}
                    </p>
                    <p className="text-xs text-gray-500 mt-1">
                      {formatDate(activity.timestamp)}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="text-center py-8 text-gray-500">
              No recent activity
            </div>
          )}
        </div>

        {/* Top Performing Lessons */}
        <div className="card">
          <h3 className="text-lg font-semibold text-gray-900 mb-4">
            Top Performing Lessons
          </h3>
          
          {stats?.topLessons && stats.topLessons.length > 0 ? (
            <div className="space-y-4">
              {stats.topLessons.map((lesson, index) => (
                <div key={lesson.lessonId} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                  <div className="flex-1">
                    <div className="flex items-center space-x-3">
                      <div className="font-medium text-gray-900">#{index + 1}</div>
                      <div>
                        <h4 className="font-medium text-gray-900">{lesson.title}</h4>
                        <p className="text-sm text-gray-600">
                          {lesson.studentCount} students enrolled
                        </p>
                      </div>
                    </div>
                  </div>
                  <div className="text-right">
                    <div className="font-semibold text-green-600">
                      {lesson.completionRate}%
                    </div>
                    <div className="text-xs text-gray-500">completion</div>
                  </div>
                </div>
              ))}
              
              <button
                onClick={() => navigate('/teacher/lessons')}
                className="w-full mt-4 btn-secondary"
              >
                View All Lessons
              </button>
            </div>
          ) : (
            <div className="text-center py-8">
              <svg className="w-12 h-12 text-gray-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
              </svg>
              <p className="text-gray-500 mb-4">No lessons created yet</p>
              <button
                onClick={() => navigate('/teacher/create-lesson')}
                className="btn-primary"
              >
                Create Your First Lesson
              </button>
            </div>
          )}
        </div>
      </div>

      {/* AI Tools Section */}
      <div className="mt-8 card">
        <h3 className="text-lg font-semibold text-gray-900 mb-4">
          AI-Powered Tools
        </h3>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="p-4 bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg border border-blue-200">
            <div className="flex items-center space-x-3 mb-3">
              <div className="text-2xl">🤖</div>
              <div>
                <h4 className="font-medium text-gray-900">AI Question Generator</h4>
                <p className="text-sm text-gray-600">
                  Automatically generate quiz questions from your video content
                </p>
              </div>
            </div>
            <p className="text-xs text-blue-600 mb-2">
              Available when creating milestones in your lessons
            </p>
          </div>

          <div className="p-4 bg-gradient-to-r from-green-50 to-yellow-50 rounded-lg border border-green-200">
            <div className="flex items-center space-x-3 mb-3">
              <div className="text-2xl">📈</div>
              <div>
                <h4 className="font-medium text-gray-900">Smart Analytics</h4>
                <p className="text-sm text-gray-600">
                  Get insights into student engagement and learning patterns
                </p>
              </div>
            </div>
            <p className="text-xs text-green-600 mb-2">
              Available in lesson analytics dashboard
            </p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/layout/Layout.tsx">
import { useAuth } from '../../hooks/useAuth'
import { 
  HomeIcon, 
  BookOpenIcon, 
  UserIcon, 
  Cog6ToothIcon,
  ArrowRightOnRectangleIcon 
} from '@heroicons/react/24/outline'
import { Link, useLocation } from 'react-router-dom'
import clsx from 'clsx'

interface LayoutProps {
  children: React.ReactNode
}

export default function Layout({ children }: LayoutProps) {
  const { user, logout } = useAuth()
  const location = useLocation()

  const navigation = [
    { name: 'Dashboard', href: '/dashboard', icon: HomeIcon },
    { name: 'Lessons', href: '/lessons', icon: BookOpenIcon },
  ]

  // Add teacher specific navigation
  if (user?.role === 'TEACHER') {
    navigation.push(
      { name: 'My Lessons', href: '/teacher/lessons', icon: UserIcon }
    )
  }

  // Add admin/teacher specific navigation
  if (user?.role === 'ADMIN' || user?.role === 'TEACHER') {
    navigation.push(
      { name: 'Settings', href: '/settings', icon: Cog6ToothIcon }
    )
  }

  return (
    <div className="flex h-screen bg-gray-50">
      {/* Sidebar */}
      <div className="hidden md:flex md:w-64 md:flex-col">
        <div className="flex flex-col flex-grow pt-5 overflow-y-auto bg-white border-r border-gray-200">
          <div className="flex items-center flex-shrink-0 px-4">
            <h1 className="text-xl font-bold text-gray-900">
              Learning Platform
            </h1>
          </div>
          
          <div className="mt-5 flex-1 flex flex-col">
            <nav className="flex-1 px-2 space-y-1">
              {navigation.map((item) => {
                const isActive = location.pathname === item.href
                return (
                  <Link
                    key={item.name}
                    to={item.href}
                    className={clsx(
                      'group flex items-center px-2 py-2 text-sm font-medium rounded-md',
                      isActive
                        ? 'bg-primary-100 text-primary-900'
                        : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900'
                    )}
                  >
                    <item.icon
                      className={clsx(
                        'mr-3 flex-shrink-0 h-6 w-6',
                        isActive
                          ? 'text-primary-500'
                          : 'text-gray-400 group-hover:text-gray-500'
                      )}
                      aria-hidden="true"
                    />
                    {item.name}
                  </Link>
                )
              })}
            </nav>
          </div>

          {/* User section */}
          <div className="flex-shrink-0 flex border-t border-gray-200 p-4">
            <div className="flex-shrink-0 w-full group block">
              <div className="flex items-center">
                <div>
                  <div className="inline-block h-10 w-10 rounded-full overflow-hidden bg-gray-100">
                    {user?.avatar ? (
                      <img
                        className="h-full w-full object-cover"
                        src={user.avatar}
                        alt=""
                      />
                    ) : (
                      <UserIcon className="h-full w-full text-gray-400 p-2" />
                    )}
                  </div>
                </div>
                <div className="ml-3 flex-1">
                  <p className="text-sm font-medium text-gray-700 group-hover:text-gray-900">
                    {user?.firstName} {user?.lastName}
                  </p>
                  <p className="text-xs font-medium text-gray-500 group-hover:text-gray-700 capitalize">
                    {user?.role.toLowerCase()}
                  </p>
                </div>
                <button
                  onClick={logout}
                  className="ml-3 p-1 rounded-full text-gray-400 hover:text-gray-600"
                  title="Logout"
                >
                  <ArrowRightOnRectangleIcon className="h-5 w-5" />
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Main content */}
      <div className="flex flex-col flex-1 overflow-hidden">
        <main className="flex-1 relative overflow-y-auto focus:outline-none">
          {children}
        </main>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/lessons/BaseLessonPage.tsx">
import React, { useState, useEffect } from 'react'
import { lessonService, type LessonWithVideos, type VideoGroup, type Video } from '../../services/lesson'

interface BaseLessonPageProps {
  lessonId: string
  role: 'TEACHER' | 'STUDENT' | 'ADMIN'
  children: (data: {
    lesson: LessonWithVideos
    videoGroups: VideoGroup[]
    selectedVideo: Video | null
    loading: boolean
    error: string | null
    onVideoSelect: (video: Video) => void
    refreshLesson: () => Promise<void>
  }) => React.ReactNode
}

/**
 * Base component for lesson pages - implements the unified pattern
 * Single API call to get lesson with embedded videoGroups
 */
export function BaseLessonPage({ lessonId, children }: BaseLessonPageProps) {
  const [lesson, setLesson] = useState<LessonWithVideos | null>(null)
  const [selectedVideo, setSelectedVideo] = useState<Video | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    if (lessonId) {
      loadLesson()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [lessonId])

  const loadLesson = async () => {
    setLoading(true)
    setError(null)

    try {
      // UNIFIED PATTERN: Single API call for ALL roles
      // Backend handles role-based filtering
      const lessonData = await lessonService.getLesson(lessonId)
      setLesson(lessonData)
      
      // Select first video if available
      const firstVideo = lessonData.videoGroups?.[0]?.videos?.[0]
      if (firstVideo) {
        setSelectedVideo(firstVideo)
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to load lesson'
      setError(message)
      console.error('Error loading lesson:', err)
    } finally {
      setLoading(false)
    }
  }

  const handleVideoSelect = (video: Video) => {
    setSelectedVideo(video)
  }

  // Provide data to children
  if (!children) {
    return null
  }

  return (
    <>
      {children({
        lesson: lesson!,
        videoGroups: lesson?.videoGroups || [],
        selectedVideo,
        loading,
        error,
        onVideoSelect: handleVideoSelect,
        refreshLesson: loadLesson
      })}
    </>
  )
}
</file>

<file path="frontend/src/components/teacher/VideoUploadModal.tsx">
import React, { useState } from 'react'
import { videoService } from '../../services/video'
import type { Video } from '../../services/video'

interface VideoUploadModalProps {
  groupId: string
  onVideoAdded: (video: Video) => void
  onClose: () => void
}

export function VideoUploadModal({ groupId, onVideoAdded, onClose }: VideoUploadModalProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    videoUrl: '',
    thumbnailUrl: '',
    duration: ''
  })

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target
    setFormData(prev => ({
      ...prev,
      [name]: value
    }))
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!formData.title.trim() || !formData.videoUrl.trim()) {
      setError('Title and video URL are required')
      return
    }

    setLoading(true)
    setError(null)

    try {
      const response = await videoService.addVideoToGroup(groupId, {
        title: formData.title,
        description: formData.description || undefined,
        videoUrl: formData.videoUrl,
        duration: formData.duration ? parseInt(formData.duration) : undefined,
        thumbnailUrl: formData.thumbnailUrl || undefined
      })

      onVideoAdded(response)
    } catch (err) {
      console.error('Error adding video:', err)
      const message = err instanceof Error ? err.message : 'Failed to add video'
      setError(message)
    } finally {
      setLoading(false)
    }
  }

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose()
    }
  }

  return (
    <div 
      className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
      onClick={handleBackdropClick}
    >
      <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto">
        <div className="p-6">
          {/* Header */}
          <div className="flex items-center justify-between mb-6">
            <h2 className="text-xl font-bold text-gray-900">Add Video to Lesson</h2>
            <button
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 transition-colors"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>

          {error && (
            <div className="bg-red-50 border border-red-200 rounded-md p-4 mb-6">
              <div className="flex">
                <svg className="w-5 h-5 text-red-400 mt-0.5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                </svg>
                <p className="text-red-700">{error}</p>
              </div>
            </div>
          )}

          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Title */}
            <div>
              <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-2">
                Video Title *
              </label>
              <input
                type="text"
                id="title"
                name="title"
                value={formData.title}
                onChange={handleInputChange}
                placeholder="Enter video title"
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                required
              />
            </div>

            {/* Description */}
            <div>
              <label htmlFor="description" className="block text-sm font-medium text-gray-700 mb-2">
                Description
              </label>
              <textarea
                id="description"
                name="description"
                value={formData.description}
                onChange={handleInputChange}
                placeholder="Describe what this video covers"
                rows={3}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              />
            </div>

            {/* Video URL */}
            <div>
              <label htmlFor="videoUrl" className="block text-sm font-medium text-gray-700 mb-2">
                Video URL *
              </label>
              <input
                type="url"
                id="videoUrl"
                name="videoUrl"
                value={formData.videoUrl}
                onChange={handleInputChange}
                placeholder="https://example.com/video.mp4"
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                required
              />
              <p className="text-xs text-gray-500 mt-1">
                Enter the direct URL to your video file (MP4, WebM, etc.) or streaming URL
              </p>
            </div>

            {/* Thumbnail URL */}
            <div>
              <label htmlFor="thumbnailUrl" className="block text-sm font-medium text-gray-700 mb-2">
                Thumbnail URL
              </label>
              <input
                type="url"
                id="thumbnailUrl"
                name="thumbnailUrl"
                value={formData.thumbnailUrl}
                onChange={handleInputChange}
                placeholder="https://example.com/thumbnail.jpg"
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              />
              <p className="text-xs text-gray-500 mt-1">
                Optional: URL to a thumbnail image for the video
              </p>
            </div>

            {/* Duration */}
            <div>
              <label htmlFor="duration" className="block text-sm font-medium text-gray-700 mb-2">
                Duration (seconds)
              </label>
              <input
                type="number"
                id="duration"
                name="duration"
                value={formData.duration}
                onChange={handleInputChange}
                placeholder="300"
                min="1"
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              />
              <p className="text-xs text-gray-500 mt-1">
                Optional: Video duration in seconds (will be auto-detected if not provided)
              </p>
            </div>

            {/* Actions */}
            <div className="flex justify-end space-x-3 pt-4 border-t">
              <button
                type="button"
                onClick={onClose}
                className="btn-secondary"
              >
                Cancel
              </button>
              <button
                type="submit"
                disabled={loading}
                className={`btn-primary ${loading ? 'opacity-50 cursor-not-allowed' : ''}`}
              >
                {loading ? 'Adding Video...' : 'Add Video'}
              </button>
            </div>
          </form>

          {/* Upload Tips */}
          <div className="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-md">
            <h3 className="text-sm font-medium text-blue-800 mb-2">Video Upload Tips</h3>
            <ul className="text-sm text-blue-700 space-y-1">
              <li>• Use MP4 format for best compatibility</li>
              <li>• Ensure your video is hosted on a public URL</li>
              <li>• Consider using a CDN for better performance</li>
              <li>• Thumbnail should be in JPG or PNG format</li>
              <li>• After adding, you can create interactive milestones</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/LoadingSpinner.tsx">
interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg'
  className?: string
  fullScreen?: boolean
  message?: string
}

export default function LoadingSpinner({ 
  size = 'md', 
  className = '',
  fullScreen = false,
  message
}: LoadingSpinnerProps) {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12'
  }

  const spinner = (
    <>
      <div
        className={`animate-spin rounded-full border-b-2 border-primary-600 ${sizeClasses[size]}`}
      />
      {message && (
        <p className="mt-4 text-gray-600 text-sm">{message}</p>
      )}
    </>
  )

  if (fullScreen) {
    return (
      <div className="fixed inset-0 bg-white bg-opacity-90 flex flex-col items-center justify-center z-50">
        {spinner}
      </div>
    )
  }

  return (
    <div className={`flex flex-col items-center justify-center ${className}`}>
      {spinner}
    </div>
  )
}
</file>

<file path="frontend/src/components/video/__tests__/VideoPlayer.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { render } from '../../../test/utils';
import VideoPlayer from '../VideoPlayer';

// Mock react-player is already set up in test setup

const mockVideo = {
  id: 'test-video-1',
  title: 'Test Video',
  url: 'https://example.com/test-video.mp4',
  duration: 300,
  thumbnail: 'https://example.com/thumbnail.jpg'
};

const mockMilestones = [
  {
    id: 'milestone-1',
    type: 'QUIZ',
    timestamp: 30,
    title: 'First Quiz',
    questions: [
      {
        id: 'q1',
        type: 'MULTIPLE_CHOICE',
        question: 'What is React?',
        options: ['Library', 'Framework', 'Language', 'Database'],
        correctAnswer: 'Library'
      }
    ]
  },
  {
    id: 'milestone-2',
    type: 'PAUSE',
    timestamp: 60,
    title: 'Pause Point',
    questions: []
  }
];

describe('VideoPlayer', () => {
  const defaultProps = {
    video: mockVideo,
    milestones: mockMilestones,
    onProgress: vi.fn(),
    onMilestoneReached: vi.fn(),
    onVideoEnd: vi.fn()
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders video player with correct video source', () => {
    render(<VideoPlayer {...defaultProps} />);
    
    const player = screen.getByTestId('react-player');
    expect(player).toBeInTheDocument();
  });

  it('displays video title', () => {
    render(<VideoPlayer {...defaultProps} />);
    
    expect(screen.getByText('Test Video')).toBeInTheDocument();
  });

  it('shows milestone markers on timeline', async () => {
    render(<VideoPlayer {...defaultProps} />);
    
    await waitFor(() => {
      expect(screen.getByTestId('milestone-marker-30')).toBeInTheDocument();
      expect(screen.getByTestId('milestone-marker-60')).toBeInTheDocument();
    });
  });

  it('handles play/pause interactions', async () => {
    const user = userEvent.setup();
    render(<VideoPlayer {...defaultProps} />);
    
    const playButton = screen.getByTestId('play-button');
    const pauseButton = screen.getByTestId('pause-button');
    
    await user.click(playButton);
    expect(playButton).toHaveBeenCalledTimes(1);
    
    await user.click(pauseButton);
    expect(pauseButton).toHaveBeenCalledTimes(1);
  });

  it('triggers milestone reached callback', async () => {
    const user = userEvent.setup();
    const onMilestoneReached = vi.fn();
    
    render(
      <VideoPlayer 
        {...defaultProps} 
        onMilestoneReached={onMilestoneReached} 
      />
    );
    
    // Simulate video progress to milestone
    const progressDiv = screen.getByTestId('progress');
    await user.click(progressDiv);
    
    // The mock react-player triggers onProgress with playedSeconds: 150
    // This should not trigger milestone at 30s, but would in a real scenario
    await waitFor(() => {
      expect(defaultProps.onProgress).toHaveBeenCalled();
    });
  });

  it('saves progress on unmount', () => {
    const onProgress = vi.fn();
    const { unmount } = render(
      <VideoPlayer {...defaultProps} onProgress={onProgress} />
    );
    
    unmount();
    
    // Verify cleanup was called (exact implementation depends on component)
    expect(onProgress).toHaveBeenCalled();
  });

  it('resumes from saved position', () => {
    const savedPosition = 120;
    render(
      <VideoPlayer 
        {...defaultProps} 
        initialPosition={savedPosition} 
      />
    );
    
    // Player should start from saved position
    // This would be verified by checking the react-player's seek functionality
    expect(screen.getByTestId('react-player')).toBeInTheDocument();
  });

  it('displays loading state while video loads', () => {
    render(<VideoPlayer {...defaultProps} />);
    
    // Initially should show loading state
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();
  });

  it('shows video controls', async () => {
    render(<VideoPlayer {...defaultProps} />);
    
    await waitFor(() => {
      expect(screen.getByTestId('video-controls')).toBeInTheDocument();
      expect(screen.getByTestId('play-pause-button')).toBeInTheDocument();
      expect(screen.getByTestId('volume-control')).toBeInTheDocument();
      expect(screen.getByTestId('progress-bar')).toBeInTheDocument();
      expect(screen.getByTestId('fullscreen-button')).toBeInTheDocument();
    });
  });

  it('handles volume changes', async () => {
    const user = userEvent.setup();
    render(<VideoPlayer {...defaultProps} />);
    
    const volumeControl = screen.getByTestId('volume-control');
    
    await user.click(volumeControl);
    
    // Volume control interaction should be handled
    expect(volumeControl).toBeInTheDocument();
  });

  it('handles seeking to specific time', async () => {
    const user = userEvent.setup();
    render(<VideoPlayer {...defaultProps} />);
    
    const progressBar = screen.getByTestId('progress-bar');
    
    await user.click(progressBar);
    
    // Seeking should update video position
    expect(progressBar).toBeInTheDocument();
  });

  it('toggles fullscreen mode', async () => {
    const user = userEvent.setup();
    render(<VideoPlayer {...defaultProps} />);
    
    const fullscreenButton = screen.getByTestId('fullscreen-button');
    
    await user.click(fullscreenButton);
    
    // Fullscreen toggle should work
    expect(fullscreenButton).toBeInTheDocument();
  });

  it('shows milestone notifications', async () => {
    render(<VideoPlayer {...defaultProps} />);
    
    // Simulate reaching a milestone
    // This would typically involve triggering the milestone logic
    await waitFor(() => {
      // In a real scenario, we'd check for milestone notification
      expect(screen.getByTestId('react-player')).toBeInTheDocument();
    });
  });

  it('handles video end event', async () => {
    const onVideoEnd = vi.fn();
    render(<VideoPlayer {...defaultProps} onVideoEnd={onVideoEnd} />);
    
    // Simulate video ending
    // The actual implementation would trigger onVideoEnd through react-player
    expect(screen.getByTestId('react-player')).toBeInTheDocument();
  });

  it('is keyboard accessible', async () => {
    const user = userEvent.setup();
    render(<VideoPlayer {...defaultProps} />);
    
    // Test keyboard navigation
    await user.tab();
    
    // Should be able to navigate through video controls with keyboard
    expect(document.activeElement).toBeTruthy();
  });

  it('supports playback speed control', async () => {
    const user = userEvent.setup();
    render(<VideoPlayer {...defaultProps} />);
    
    const speedControl = screen.queryByTestId('playback-speed');
    
    if (speedControl) {
      await user.click(speedControl);
      expect(speedControl).toBeInTheDocument();
    }
  });

  it('handles error states gracefully', () => {
    const videoWithBadUrl = {
      ...mockVideo,
      url: 'invalid-url'
    };
    
    render(<VideoPlayer {...defaultProps} video={videoWithBadUrl} />);
    
    // Should handle video loading errors gracefully
    expect(screen.getByTestId('react-player')).toBeInTheDocument();
  });

  it('tracks watch time accurately', async () => {
    const onProgress = vi.fn();
    render(<VideoPlayer {...defaultProps} onProgress={onProgress} />);
    
    // Simulate video progress
    const progressDiv = screen.getByTestId('progress');
    await userEvent.click(progressDiv);
    
    await waitFor(() => {
      expect(onProgress).toHaveBeenCalledWith(
        expect.objectContaining({
          playedSeconds: expect.any(Number),
          played: expect.any(Number)
        })
      );
    });
  });
});
</file>

<file path="frontend/src/components/video/MilestoneMarkers.tsx">
import type { Milestone } from '../../services/video'

interface MilestoneMarkersProps {
  milestones: Milestone[]
  duration: number
  currentTime: number
  reachedMilestones: string[]
}

export function MilestoneMarkers({ 
  milestones, 
  duration, 
  currentTime, 
  reachedMilestones 
}: MilestoneMarkersProps) {
  if (duration === 0 || milestones.length === 0) return null

  return (
    <div className="absolute bottom-4 left-4 right-4 h-2 pointer-events-none">
      {milestones.map((milestone) => {
        const percentage = (milestone.timestamp / duration) * 100
        const isReached = reachedMilestones.includes(milestone.id)
        const isCurrent = Math.abs(currentTime - milestone.timestamp) <= 2

        return (
          <div
            key={milestone.id}
            className="absolute transform -translate-x-1/2 group"
            style={{ left: `${percentage}%` }}
            title={`${milestone.title} - ${Math.floor(milestone.timestamp / 60)}:${(milestone.timestamp % 60).toFixed(0).padStart(2, '0')}`}
          >
            {/* Milestone Marker */}
            <div 
              className={`w-4 h-4 rounded-full border-2 transition-all duration-200 ${
                isCurrent
                  ? 'bg-yellow-400 border-yellow-400 scale-125 shadow-lg'
                  : milestone.type === 'QUIZ'
                  ? isReached 
                    ? 'bg-green-500 border-green-500' 
                    : 'bg-red-500 border-red-500'
                  : milestone.type === 'CHECKPOINT'
                  ? isReached
                    ? 'bg-blue-500 border-blue-500'
                    : 'bg-blue-300 border-blue-300'
                  : isReached
                    ? 'bg-gray-500 border-gray-500'
                    : 'bg-gray-300 border-gray-300'
              }`}
            >
              {/* Icon based on milestone type */}
              <div className="w-full h-full flex items-center justify-center text-white text-xs">
                {milestone.type === 'QUIZ' ? (
                  <svg className="w-2 h-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clipRule="evenodd" />
                  </svg>
                ) : milestone.type === 'CHECKPOINT' ? (
                  <svg className="w-2 h-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                  </svg>
                ) : (
                  <div className="w-1 h-1 bg-current rounded-full"></div>
                )}
              </div>
            </div>

            {/* Tooltip on hover */}
            <div className="absolute bottom-6 left-1/2 transform -translate-x-1/2 bg-black text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">
              <div className="font-semibold">{milestone.title}</div>
              <div className="text-gray-300">
                {Math.floor(milestone.timestamp / 60)}:{(milestone.timestamp % 60).toFixed(0).padStart(2, '0')}
              </div>
              {milestone.description && (
                <div className="text-gray-400 max-w-48 truncate">
                  {milestone.description}
                </div>
              )}
              <div className="absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-black"></div>
            </div>
          </div>
        )
      })}
    </div>
  )
}
</file>

<file path="frontend/src/components/video/VideoControls.tsx">
import React from 'react'
import type { Milestone } from '../../services/video'

interface VideoControlsProps {
  isPlaying: boolean
  currentTime: number
  duration: number
  volume: number
  isMuted: boolean
  isFullscreen: boolean
  milestones?: Milestone[]
  reachedMilestones?: string[]
  onPlay: () => void
  onPause: () => void
  onSeek: (time: number) => void
  onVolumeChange: (volume: number) => void
  onMute: () => void
  onFullscreen: () => void
}

export function VideoControls({
  isPlaying,
  currentTime,
  duration,
  volume,
  isMuted,
  isFullscreen,
  milestones = [],
  reachedMilestones = [],
  onPlay,
  onPause,
  onSeek,
  onVolumeChange,
  onMute,
  onFullscreen
}: VideoControlsProps) {
  const formatTime = (seconds: number) => {
    if (isNaN(seconds)) return '0:00'
    const mins = Math.floor(seconds / 60)
    const secs = Math.floor(seconds % 60)
    return `${mins}:${secs.toString().padStart(2, '0')}`
  }

  const handleProgressClick = (e: React.MouseEvent<HTMLDivElement>) => {
    const rect = e.currentTarget.getBoundingClientRect()
    const clickX = e.clientX - rect.left
    const percentage = clickX / rect.width
    const newTime = percentage * duration
    onSeek(newTime)
  }

  const handleVolumeClick = (e: React.MouseEvent<HTMLDivElement>) => {
    const rect = e.currentTarget.getBoundingClientRect()
    const clickX = e.clientX - rect.left
    const percentage = clickX / rect.width
    onVolumeChange(percentage)
  }

  const progressPercentage = duration > 0 ? (currentTime / duration) * 100 : 0

  return (
    <div className="bg-gray-900 p-4">
      {/* Progress Bar with Milestones */}
      <div className="mb-4">
        <div 
          className="w-full h-2 bg-gray-700 rounded-full cursor-pointer relative group"
          onClick={handleProgressClick}
        >
          {/* Progress Fill */}
          <div 
            className="h-full bg-blue-500 rounded-full relative transition-all"
            style={{ width: `${progressPercentage}%` }}
          >
            <div className="absolute right-0 top-1/2 transform translate-x-1/2 -translate-y-1/2 w-4 h-4 bg-blue-500 rounded-full shadow-lg opacity-0 group-hover:opacity-100 transition-opacity"></div>
          </div>
          
          {/* Milestone Markers */}
          {milestones.map((milestone) => {
            const percentage = duration > 0 ? (milestone.timestamp / duration) * 100 : 0
            const isReached = reachedMilestones.includes(milestone.id)
            const isCurrent = Math.abs(currentTime - milestone.timestamp) <= 1
            
            return (
              <div
                key={milestone.id}
                className="absolute top-1/2 transform -translate-x-1/2 -translate-y-1/2"
                style={{ left: `${percentage}%` }}
                title={`${milestone.title} - ${formatTime(milestone.timestamp)}`}
              >
                <div 
                  className={`w-3 h-3 rounded-full border-2 transition-all duration-200 ${
                    isCurrent
                      ? 'bg-yellow-400 border-yellow-400 scale-150 shadow-lg animate-pulse'
                      : milestone.type === 'QUIZ'
                      ? isReached 
                        ? 'bg-green-500 border-green-500' 
                        : 'bg-red-500 border-red-500'
                      : milestone.type === 'CHECKPOINT'
                      ? isReached
                        ? 'bg-blue-500 border-blue-500'
                        : 'bg-blue-300 border-blue-300'
                      : isReached
                        ? 'bg-gray-500 border-gray-500'
                        : 'bg-gray-300 border-gray-300'
                  }`}
                />
                
                {/* Milestone tooltip on hover */}
                <div className="absolute bottom-full mb-2 left-1/2 transform -translate-x-1/2 bg-black text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 pointer-events-none group-hover:opacity-100 transition-opacity z-10">
                  <div className="font-semibold">{milestone.title}</div>
                  <div className="text-gray-300">{formatTime(milestone.timestamp)}</div>
                  {milestone.type === 'QUIZ' && milestone._count?.questions && (
                    <div className="text-gray-400">{milestone._count.questions} questions</div>
                  )}
                  <div className="absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-black"></div>
                </div>
              </div>
            )
          })}
        </div>
        
        {/* Milestone Legend */}
        {milestones.length > 0 && (
          <div className="flex items-center justify-end mt-2 space-x-4 text-xs text-gray-400">
            <div className="flex items-center">
              <div className="w-2 h-2 bg-red-500 rounded-full mr-1"></div>
              <span>Quiz</span>
            </div>
            <div className="flex items-center">
              <div className="w-2 h-2 bg-blue-500 rounded-full mr-1"></div>
              <span>Checkpoint</span>
            </div>
            <div className="flex items-center">
              <div className="w-2 h-2 bg-gray-500 rounded-full mr-1"></div>
              <span>Pause</span>
            </div>
          </div>
        )}
      </div>

      <div className="flex items-center justify-between text-white">
        {/* Left Controls */}
        <div className="flex items-center space-x-4">
          {/* Play/Pause Button */}
          <button
            onClick={isPlaying ? onPause : onPlay}
            className="p-2 hover:bg-white hover:bg-opacity-20 rounded-full transition-colors"
          >
            {isPlaying ? (
              <svg className="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" />
              </svg>
            ) : (
              <svg className="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clipRule="evenodd" />
              </svg>
            )}
          </button>

          {/* Time Display */}
          <div className="text-sm">
            {formatTime(currentTime)} / {formatTime(duration)}
          </div>
        </div>

        {/* Right Controls */}
        <div className="flex items-center space-x-4">
          {/* Volume Control */}
          <div className="flex items-center space-x-2">
            <button
              onClick={onMute}
              className="p-1 hover:bg-white hover:bg-opacity-20 rounded transition-colors"
            >
              {isMuted || volume === 0 ? (
                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.783L4.216 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.216l4.167-3.783zm0 14.166L6.383 14H2V8h4.383L9.383 4.834v12.332zM15.657 6.343a1 1 0 011.414 0A9.972 9.972 0 0119 12a9.972 9.972 0 01-1.929 5.657 1 1 0 01-1.414-1.414A7.971 7.971 0 0017 12a7.971 7.971 0 00-1.343-4.243 1 1 0 010-1.414z" clipRule="evenodd" />
                  <path d="M13.243 8.757a1 1 0 011.414 0A5.98 5.98 0 0116 12a5.98 5.98 0 01-1.343 3.243 1 1 0 01-1.414-1.414A3.99 3.99 0 0014 12a3.99 3.99 0 00-.757-2.343 1 1 0 010-1.414z" />
                </svg>
              ) : volume < 0.5 ? (
                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.783L4.216 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.216l4.167-3.783zm0 14.166L6.383 14H2V8h4.383L9.383 4.834v12.332zM13.243 8.757a1 1 0 011.414 0A5.98 5.98 0 0116 12a5.98 5.98 0 01-1.343 3.243 1 1 0 01-1.414-1.414A3.99 3.99 0 0014 12a3.99 3.99 0 00-.757-2.343 1 1 0 010-1.414z" clipRule="evenodd" />
                </svg>
              ) : (
                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.783L4.216 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.216l4.167-3.783zm0 14.166L6.383 14H2V8h4.383L9.383 4.834v12.332zM15.657 6.343a1 1 0 011.414 0A9.972 9.972 0 0119 12a9.972 9.972 0 01-1.929 5.657 1 1 0 01-1.414-1.414A7.971 7.971 0 0017 12a7.971 7.971 0 00-1.343-4.243 1 1 0 010-1.414z" clipRule="evenodd" />
                  <path d="M13.243 8.757a1 1 0 011.414 0A5.98 5.98 0 0116 12a5.98 5.98 0 01-1.343 3.243 1 1 0 01-1.414-1.414A3.99 3.99 0 0014 12a3.99 3.99 0 00-.757-2.343 1 1 0 010-1.414z" />
                </svg>
              )}
            </button>

            {/* Volume Slider */}
            <div 
              className="w-16 h-1 bg-gray-600 rounded-full cursor-pointer relative hidden sm:block"
              onClick={handleVolumeClick}
            >
              <div 
                className="h-full bg-white rounded-full"
                style={{ width: `${volume * 100}%` }}
              ></div>
            </div>
          </div>

          {/* Fullscreen Button */}
          <button
            onClick={onFullscreen}
            className="p-1 hover:bg-white hover:bg-opacity-20 rounded transition-colors"
          >
            {isFullscreen ? (
              <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M3 4a1 1 0 011-1h4a1 1 0 010 2H6.414l2.293 2.293a1 1 0 11-1.414 1.414L5 6.414V8a1 1 0 01-2 0V4zm9 1a1 1 0 010-2h4a1 1 0 011 1v4a1 1 0 01-2 0V6.414l-2.293 2.293a1 1 0 11-1.414-1.414L13.586 5H12zm-9 7a1 1 0 012 0v1.586l2.293-2.293a1 1 0 111.414 1.414L6.414 15H8a1 1 0 010 2H4a1 1 0 01-1-1v-4zm13-1a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 010-2h1.586l-2.293-2.293a1 1 0 111.414-1.414L15 13.586V12a1 1 0 011-1z" clipRule="evenodd" />
              </svg>
            ) : (
              <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M3 4a1 1 0 011-1h4a1 1 0 010 2H6.414l2.293 2.293a1 1 0 11-1.414 1.414L5 6.414V8a1 1 0 01-2 0V4zm9 1a1 1 0 010-2h4a1 1 0 011 1v4a1 1 0 01-2 0V6.414l-2.293 2.293a1 1 0 11-1.414-1.414L13.586 5H12zm-9 7a1 1 0 012 0v1.586l2.293-2.293a1 1 0 111.414 1.414L6.414 15H8a1 1 0 010 2H4a1 1 0 01-1-1v-4zm13-1a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 010-2h1.586l-2.293-2.293a1 1 0 111.414-1.414L15 13.586V12a1 1 0 011-1z" clipRule="evenodd" />
              </svg>
            )}
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/contexts/VideoStateContext.tsx">
import { createContext, useContext } from 'react'
import type { ReactNode } from 'react'
import { videoStateManager } from '../stores/VideoStateManager'

interface VideoStateContextType {
  manager: typeof videoStateManager
}

const VideoStateContext = createContext<VideoStateContextType | undefined>(undefined)

export function VideoStateProvider({ children }: { children: ReactNode }) {
  return (
    <VideoStateContext.Provider value={{ manager: videoStateManager }}>
      {children}
    </VideoStateContext.Provider>
  )
}

export function useVideoStateManager() {
  const context = useContext(VideoStateContext)
  if (!context) {
    throw new Error('useVideoStateManager must be used within VideoStateProvider')
  }
  return context.manager
}
</file>

<file path="frontend/src/hooks/useAuth.ts">
import { useAuth as useAuthContext } from '../contexts/AuthContext'

// Compatibility wrapper for the old API
export function useAuth() {
  const context = useAuthContext()
  
  // Map the new API to the old API for backward compatibility
  return {
    user: context.state.user,
    isAuthenticated: context.state.isAuthenticated,
    isLoading: context.state.isLoading,
    isInitialized: context.state.isInitialized,
    error: context.state.error,
    login: context.actions.login,
    register: context.actions.register,
    logout: context.actions.logout,
    refreshToken: context.actions.refreshAuth,
    tokens: null // Deprecated - tokens are managed internally
  }
}
</file>

<file path="frontend/src/hooks/useVideoState.ts">
import { useState, useEffect, useCallback } from 'react'
import { useVideoStateManager } from '../contexts/VideoStateContext'
import type { VideoState, SessionState } from '../stores/VideoStateManager'

export function useVideoState(videoId: string | undefined) {
  const manager = useVideoStateManager()
  const [state, setState] = useState<VideoState | undefined>(
    videoId ? manager.getVideoState(videoId) : undefined
  )
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  useEffect(() => {
    if (!videoId) {
      setState(undefined)
      return
    }
    
    // Subscribe to video state changes
    const unsubscribe = manager.subscribeToVideo(videoId, (_id, videoState) => {
      setState(videoState)
      setLoading(videoState.metadata.isLoading)
      setError(videoState.metadata.error)
    })
    
    // Load video if not in cache
    const existingState = manager.getVideoState(videoId)
    if (!existingState) {
      setLoading(true)
      manager.loadVideo(videoId).catch(err => {
        setError(err.message || 'Failed to load video')
        setLoading(false)
      })
    }
    
    return unsubscribe
  }, [videoId, manager])
  
  const refresh = useCallback(async () => {
    if (!videoId) return
    setLoading(true)
    try {
      await manager.loadVideo(videoId, true)
    } catch (err: any) {
      setError(err.message || 'Failed to refresh video')
    } finally {
      setLoading(false)
    }
  }, [videoId, manager])
  
  return {
    state,
    loading,
    error,
    refresh,
    video: state?.video,
    milestones: state?.milestones || [],
    questions: state?.questions || new Map(),
    metadata: state?.metadata
  }
}

export function useSessionState(sessionId: string | undefined) {
  const manager = useVideoStateManager()
  const [state, setState] = useState<SessionState | undefined>(
    sessionId ? manager.getSessionState(sessionId) : undefined
  )
  
  useEffect(() => {
    if (!sessionId) {
      setState(undefined)
      return
    }
    
    // Subscribe to session state changes
    const unsubscribe = manager.subscribeToSession(sessionId, (_id, sessionState) => {
      setState(sessionState)
    })
    
    return unsubscribe
  }, [sessionId, manager])
  
  return {
    state,
    session: state?.session,
    milestoneProgress: state?.milestoneProgress,
    questionAnswers: state?.questionAnswers,
    currentMilestone: state?.currentMilestone,
    metadata: state?.metadata
  }
}

export function useAllVideosState() {
  const manager = useVideoStateManager()
  const [videos, setVideos] = useState<Map<string, VideoState>>(new Map())
  const [sessions, setSessions] = useState<Map<string, SessionState>>(new Map())
  
  useEffect(() => {
    const unsubscribe = manager.subscribe((state) => {
      setVideos(new Map(state.videos))
      setSessions(new Map(state.sessions))
    })
    
    return unsubscribe
  }, [manager])
  
  return { videos, sessions }
}
</file>

<file path="frontend/src/pages/auth/LoginPage.tsx">
import { useState } from 'react'
import { Link } from 'react-router-dom'
import { useForm } from 'react-hook-form'
import { useAuth } from '../../hooks/useAuth'
import type { LoginCredentials } from '../../types/auth'
import LoadingSpinner from '../../components/ui/LoadingSpinner'

export default function LoginPage() {
  const { login, isLoading } = useAuth()
  const [error, setError] = useState<string>('')
  
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginCredentials>()

  const onSubmit = async (data: LoginCredentials) => {
    try {
      setError('')
      await login(data)
    } catch (err: any) {
      setError(err.message || 'Login failed')
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Sign in to your account
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">
            Or{' '}
            <Link
              to="/register"
              className="font-medium text-primary-600 hover:text-primary-500"
            >
              create a new account
            </Link>
          </p>
        </div>

        <form className="mt-8 space-y-6" onSubmit={handleSubmit(onSubmit)}>
          {error && (
            <div className="bg-red-50 border border-red-200 rounded-md p-4">
              <p className="text-sm text-red-600">{error}</p>
            </div>
          )}

          <div className="space-y-4">
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700">
                Email address
              </label>
              <input
                {...register('email', {
                  required: 'Email is required',
                  pattern: {
                    value: /^\S+@\S+$/i,
                    message: 'Please enter a valid email address',
                  },
                })}
                type="email"
                autoComplete="email"
                className="mt-1 input-field w-full"
                placeholder="Enter your email"
              />
              {errors.email && (
                <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
              )}
            </div>

            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700">
                Password
              </label>
              <input
                {...register('password', {
                  required: 'Password is required',
                  minLength: {
                    value: 6,
                    message: 'Password must be at least 6 characters',
                  },
                })}
                type="password"
                autoComplete="current-password"
                className="mt-1 input-field w-full"
                placeholder="Enter your password"
              />
              {errors.password && (
                <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
              )}
            </div>
          </div>

          <div>
            <button
              type="submit"
              disabled={isLoading}
              className="group relative w-full flex justify-center btn-primary disabled:opacity-50"
            >
              {isLoading ? (
                <LoadingSpinner size="sm" />
              ) : (
                'Sign in'
              )}
            </button>
          </div>

          <div className="text-center">
            <p className="text-sm text-gray-600">
              Demo credentials:
            </p>
            <div className="mt-2 text-xs text-gray-500 space-y-1">
              <p>Teacher: teacher@example.com / Demo123!</p>
              <p>Student: student@example.com / Demo123!</p>
            </div>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/pages/lessons/LessonDetailPage.tsx">
import { useParams, useNavigate } from 'react-router-dom'
import { BaseLessonPage } from '../../components/lessons/BaseLessonPage'
import type { Video } from '../../services/lesson'

export default function LessonDetailPage() {
  const { id } = useParams<{ id: string }>()
  const navigate = useNavigate()

  if (!id) {
    navigate('/lessons')
    return null
  }

  // Use BaseLessonPage for unified data loading
  return (
    <BaseLessonPage lessonId={id} role="STUDENT">
      {({ lesson, videoGroups, loading, error }) => {
        const handleVideoClick = (video: Video) => {
          // Navigate to video player page
          navigate(`/video/${video.id}`)
        }

        const formatDuration = (seconds: number | null) => {
          if (!seconds) return 'Unknown duration'
          const mins = Math.floor(seconds / 60)
          const secs = seconds % 60
          return `${mins}:${secs.toString().padStart(2, '0')}`
        }

        if (loading) {
          return (
            <div className="p-6">
              <div className="flex items-center justify-center h-64">
                <div className="text-center">
                  <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
                  <p className="text-gray-600">Loading lesson...</p>
                </div>
              </div>
            </div>
          )
        }

        if (error) {
          return (
            <div className="p-6">
              <div className="bg-red-50 border border-red-200 rounded-md p-4">
                <div className="flex">
                  <svg className="w-5 h-5 text-red-400 mt-0.5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                  </svg>
                  <div>
                    <p className="text-red-700">{error}</p>
                    <button
                      onClick={() => navigate('/lessons')}
                      className="mt-2 text-sm text-red-600 hover:text-red-500 underline"
                    >
                      Back to lessons
                    </button>
                  </div>
                </div>
              </div>
            </div>
          )
        }

        if (!lesson) {
          return (
            <div className="p-6">
              <p className="text-gray-600">Lesson not found</p>
              <button
                onClick={() => navigate('/lessons')}
                className="mt-2 text-blue-600 hover:text-blue-500 underline"
              >
                Back to lessons
              </button>
            </div>
          )
        }

        return (
          <div className="p-6">
            {/* Lesson Header */}
            <div className="mb-8">
              <button
                onClick={() => navigate('/lessons')}
                className="mb-4 text-gray-600 hover:text-gray-900 flex items-center"
              >
                <svg className="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 19l-7-7 7-7" />
                </svg>
                Back to lessons
              </button>

              <h1 className="text-3xl font-bold text-gray-900 mb-3">{lesson.title}</h1>
              
              {lesson.description && (
                <p className="text-lg text-gray-600 mb-4">{lesson.description}</p>
              )}

              {/* Lesson Metadata */}
              <div className="flex flex-wrap gap-4 mb-4">
                {lesson.difficulty && (
                  <span className={`px-3 py-1 rounded-full text-sm font-medium ${
                    lesson.difficulty === 'beginner' 
                      ? 'bg-green-100 text-green-700'
                      : lesson.difficulty === 'intermediate'
                      ? 'bg-yellow-100 text-yellow-700'
                      : 'bg-red-100 text-red-700'
                  }`}>
                    {lesson.difficulty.charAt(0).toUpperCase() + lesson.difficulty.slice(1)}
                  </span>
                )}
                
                {lesson.estimatedTime && (
                  <span className="px-3 py-1 bg-gray-100 text-gray-700 rounded-full text-sm font-medium">
                    <svg className="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    {lesson.estimatedTime} min
                  </span>
                )}

                {lesson.createdBy && (
                  <span className="px-3 py-1 bg-blue-100 text-blue-700 rounded-full text-sm font-medium">
                    <svg className="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                    </svg>
                    {lesson.createdBy.firstName} {lesson.createdBy.lastName}
                  </span>
                )}
              </div>

              {/* Tags */}
              {lesson.tags && lesson.tags.length > 0 && (
                <div className="flex flex-wrap gap-2">
                  {lesson.tags.map((tag, index) => (
                    <span
                      key={index}
                      className="px-2 py-1 bg-gray-100 text-gray-600 text-sm rounded"
                    >
                      #{tag}
                    </span>
                  ))}
                </div>
              )}
            </div>

            {/* Student Progress (if available) */}
            {lesson.studentProgress && lesson.studentProgress.length > 0 && (
              <div className="mb-8 card bg-blue-50 border-blue-200">
                <h2 className="text-lg font-semibold text-blue-900 mb-2">Your Progress</h2>
                <div className="flex items-center justify-between">
                  <div className="flex-1">
                    <div className="h-4 bg-blue-200 rounded-full overflow-hidden">
                      <div 
                        className="h-full bg-blue-600 transition-all duration-300"
                        style={{ width: `${lesson.studentProgress[0].completionPercent}%` }}
                      />
                    </div>
                  </div>
                  <span className="ml-4 text-blue-900 font-medium">
                    {lesson.studentProgress[0].completionPercent}%
                  </span>
                </div>
              </div>
            )}

            {/* Learning Objectives */}
            {lesson.objectives && lesson.objectives.length > 0 && (
              <div className="mb-8 card">
                <h2 className="text-xl font-semibold text-gray-900 mb-3">Learning Objectives</h2>
                <ul className="space-y-2">
                  {lesson.objectives.map((objective, index) => (
                    <li key={index} className="flex items-start">
                      <svg className="w-5 h-5 text-green-500 mt-0.5 mr-2 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                      </svg>
                      <span className="text-gray-700">{objective}</span>
                    </li>
                  ))}
                </ul>
              </div>
            )}

            {/* Video Content */}
            <div className="mb-8">
              <h2 className="text-xl font-semibold text-gray-900 mb-4">Video Content</h2>
              
              {videoGroups.length === 0 ? (
                <div className="card text-center py-8">
                  <svg className="w-12 h-12 text-gray-400 mx-auto mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                  </svg>
                  <p className="text-gray-600">No videos available for this lesson yet.</p>
                </div>
              ) : (
                <div className="space-y-4">
                  {videoGroups.map((group) => (
                    <div key={group.id} className="card">
                      <h3 className="text-lg font-semibold text-gray-900 mb-3">{group.title}</h3>
                      
                      {group.description && (
                        <p className="text-gray-600 mb-4">{group.description}</p>
                      )}
                      
                      {group.videos && group.videos.length > 0 ? (
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                          {group.videos.map((video) => (
                            <div
                              key={video.id}
                              className="border border-gray-200 rounded-lg overflow-hidden hover:shadow-md transition-shadow cursor-pointer"
                              onClick={() => handleVideoClick(video)}
                            >
                              {/* Video Thumbnail */}
                              <div className="aspect-video bg-gray-100 relative">
                                {video.thumbnailPath || video.thumbnailUrl ? (
                                  <img
                                    src={video.thumbnailUrl || `/api/v1/videos/${video.id}/thumbnail`}
                                    alt={video.title}
                                    className="w-full h-full object-cover"
                                  />
                                ) : (
                                  <div className="w-full h-full flex items-center justify-center">
                                    <svg className="w-12 h-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                    </svg>
                                  </div>
                                )}
                                
                                {/* Play Button Overlay */}
                                <div className="absolute inset-0 flex items-center justify-center">
                                  <div className="bg-black bg-opacity-50 rounded-full p-3 hover:bg-opacity-70 transition-opacity">
                                    <svg className="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                                      <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clipRule="evenodd" />
                                    </svg>
                                  </div>
                                </div>
                                
                                {/* Duration Badge */}
                                {video.duration && (
                                  <div className="absolute bottom-2 right-2 bg-black bg-opacity-75 text-white px-2 py-1 rounded text-xs">
                                    {formatDuration(video.duration)}
                                  </div>
                                )}
                              </div>
                              
                              {/* Video Info */}
                              <div className="p-3">
                                <h4 className="font-medium text-gray-900 mb-1">{video.title}</h4>
                                {video.description && (
                                  <p className="text-sm text-gray-600 line-clamp-2">{video.description}</p>
                                )}
                                
                                {/* Video Stats */}
                                <div className="mt-2 flex items-center text-xs text-gray-500">
                                  {video._count?.milestones !== undefined && video._count.milestones > 0 && (
                                    <span className="flex items-center">
                                      <svg className="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                                        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clipRule="evenodd" />
                                      </svg>
                                      {video._count.milestones} milestones
                                    </span>
                                  )}
                                </div>
                              </div>
                            </div>
                          ))}
                        </div>
                      ) : (
                        <p className="text-gray-600">No videos in this group yet.</p>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>

            {/* Start Learning Button */}
            {videoGroups.length > 0 && videoGroups.some(g => g.videos && g.videos.length > 0) && (
              <div className="text-center">
                <button
                  onClick={() => {
                    // Find the first video and navigate to it
                    const firstVideo = videoGroups.find(g => g.videos && g.videos.length > 0)?.videos[0]
                    if (firstVideo) {
                      handleVideoClick(firstVideo)
                    }
                  }}
                  className="btn-primary text-lg px-8 py-3"
                >
                  Start Learning
                </button>
              </div>
            )}
          </div>
        )
      }}
    </BaseLessonPage>
  )
}
</file>

<file path="frontend/src/services/lesson.ts">
import { apiService } from './api'

export interface ApiResponse<T> {
  success: boolean
  data: T
  error?: string
  message?: string
}

// Video type matching backend response
export interface Video {
  id: string
  videoGroupId: string
  title: string
  description: string | null
  order: number
  status: string
  duration: number | null
  thumbnailPath: string | null
  thumbnailUrl?: string | null // Computed field for frontend
  filePath?: string | null // Only for teachers/admins
  size: string | null
  mimeType: string | null
  processingStatus?: string | null // Only for teachers/admins
  uploadedAt: string
  _count?: {
    milestones: number
  }
}

// VideoGroup type matching backend response
export interface VideoGroup {
  id: string
  lessonId: string
  title: string
  description: string | null
  order: number
  createdAt: string
  updatedAt: string
  videos: Video[]
  _count?: {
    videos: number
  }
}

// Student progress type
export interface StudentProgress {
  id: string
  studentId: string
  lessonId: string
  isCompleted: boolean
  completionPercent: number
  totalTimeSpent: number
  averageScore: number | null
  startedAt: string
  completedAt: string | null
}

// UNIFIED Lesson interface - always includes videoGroups when fetched by ID
export interface Lesson {
  id: string
  title: string
  description: string | null
  thumbnail: string | null
  status: 'DRAFT' | 'PUBLISHED' | 'ARCHIVED'
  order: number | null
  tenantId: string | null
  createdById: string
  objectives: string[]
  estimatedTime: number | null
  difficulty: 'beginner' | 'intermediate' | 'advanced' | null
  tags: string[]
  metadata: any | null
  createdAt: string
  updatedAt: string
  publishedAt: string | null
  createdBy?: {
    id: string
    firstName: string
    lastName: string
    avatar: string | null
    email?: string
  }
  // UNIFIED PATTERN: Always includes videoGroups when fetched by ID
  videoGroups?: VideoGroup[]
  studentProgress?: StudentProgress[]
  _count?: {
    videoGroups: number
    studentProgress: number
  }
}

// Type alias for better clarity
export type LessonWithVideos = Lesson & {
  videoGroups: VideoGroup[]
}

export interface CreateLessonRequest {
  title: string
  description?: string
  thumbnail?: string
  objectives?: string[]
  estimatedTime?: number
  difficulty?: 'beginner' | 'intermediate' | 'advanced'
  tags?: string[]
  order?: number
}

export interface UpdateLessonRequest {
  title?: string
  description?: string
  thumbnail?: string
  objectives?: string[]
  estimatedTime?: number
  difficulty?: 'beginner' | 'intermediate' | 'advanced'
  tags?: string[]
  order?: number
  status?: 'DRAFT' | 'PUBLISHED' | 'ARCHIVED'
}

export const lessonService = {
  // Create a new lesson
  async createLesson(data: CreateLessonRequest): Promise<Lesson> {
    const response = await apiService.post<ApiResponse<Lesson>>('/lessons', data)
    
    if (!response.success) {
      throw new Error(response.error || 'Failed to create lesson')
    }
    
    return response.data
  },

  // Get all lessons (with pagination and filters)
  async getLessons(params?: {
    page?: number
    limit?: number
    status?: 'DRAFT' | 'PUBLISHED' | 'ARCHIVED'
    difficulty?: 'beginner' | 'intermediate' | 'advanced'
    search?: string
    createdById?: string
  }) {
    const response = await apiService.get<ApiResponse<{
      items: Lesson[]
      total: number
      page: number
      limit: number
      totalPages: number
    }>>('/lessons', { params })
    
    if (!response.success) {
      throw new Error(response.error || 'Failed to fetch lessons')
    }
    
    return response.data
  },

  // Get a specific lesson by ID - UNIFIED PATTERN: Always returns lesson with videoGroups
  async getLesson(id: string): Promise<LessonWithVideos> {
    const response = await apiService.get<ApiResponse<LessonWithVideos>>(`/lessons/${id}`)
    
    if (!response.success) {
      throw new Error(response.error || 'Failed to fetch lesson')
    }
    
    // Response ALWAYS includes videoGroups (teacher pattern)
    return response.data
  },

  // Update a lesson
  async updateLesson(id: string, data: UpdateLessonRequest): Promise<Lesson> {
    const response = await apiService.put<ApiResponse<Lesson>>(`/lessons/${id}`, data)
    
    if (!response.success) {
      throw new Error(response.error || 'Failed to update lesson')
    }
    
    return response.data
  },

  // Publish a lesson
  async publishLesson(id: string): Promise<Lesson> {
    const response = await apiService.post<ApiResponse<Lesson>>(`/lessons/${id}/publish`)
    
    if (!response.success) {
      throw new Error(response.error || 'Failed to publish lesson')
    }
    
    return response.data
  },

  // Archive a lesson
  async archiveLesson(id: string): Promise<Lesson> {
    const response = await apiService.post<ApiResponse<Lesson>>(`/lessons/${id}/archive`)
    
    if (!response.success) {
      throw new Error(response.error || 'Failed to archive lesson')
    }
    
    return response.data
  },

  // Delete a lesson
  async deleteLesson(id: string): Promise<void> {
    const response = await apiService.delete<ApiResponse<void>>(`/lessons/${id}`)
    
    if (!response.success) {
      throw new Error(response.error || 'Failed to delete lesson')
    }
  }
}
</file>

<file path="frontend/src/services/tokenManager.ts">
/**
 * TokenManager - Centralized token management service
 * Handles all token operations including storage, validation, and refresh scheduling
 */

import { debug } from '../utils/debug'

interface JWTPayload {
  exp: number
  iat: number
  userId: string
  email: string
  role: string
}

class TokenManager {
  private static readonly ACCESS_TOKEN_KEY = 'accessToken'
  private static readonly REFRESH_TOKEN_KEY = 'refreshToken'
  private static readonly TOKEN_EXPIRY_KEY = 'tokenExpiry'
  private static readonly USER_DATA_KEY = 'userData'
  
  private static refreshTimer: NodeJS.Timeout | null = null
  private static refreshPromise: Promise<boolean> | null = null

  /**
   * Decode JWT token to extract payload
   */
  private static decodeJWT(token: string): JWTPayload | null {
    try {
      const base64Url = token.split('.')[1]
      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/')
      const jsonPayload = decodeURIComponent(
        atob(base64)
          .split('')
          .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
          .join('')
      )
      return JSON.parse(jsonPayload)
    } catch (error) {
      debug.error('Failed to decode JWT:', error)
      return null
    }
  }

  /**
   * Store tokens with automatic refresh scheduling
   */
  static setTokens(accessToken: string, refreshToken: string): boolean {
    try {
      // Decode token to get expiry
      const payload = this.decodeJWT(accessToken)
      if (!payload) {
        debug.error('Invalid access token format')
        return false
      }

      // Store tokens and metadata
      localStorage.setItem(this.ACCESS_TOKEN_KEY, accessToken)
      localStorage.setItem(this.REFRESH_TOKEN_KEY, refreshToken)
      localStorage.setItem(this.TOKEN_EXPIRY_KEY, (payload.exp * 1000).toString())
      localStorage.setItem(this.USER_DATA_KEY, JSON.stringify({
        userId: payload.userId,
        email: payload.email,
        role: payload.role
      }))

      // Schedule automatic refresh
      this.scheduleTokenRefresh()
      
      // Notify other tabs
      window.dispatchEvent(new CustomEvent('auth:tokens-updated'))
      
      return true
    } catch (error) {
      debug.error('Failed to store tokens:', error)
      return false
    }
  }

  /**
   * Get access token if valid
   */
  static getAccessToken(): string | null {
    if (!this.isTokenValid()) {
      return null
    }
    return localStorage.getItem(this.ACCESS_TOKEN_KEY)
  }

  /**
   * Get refresh token
   */
  static getRefreshToken(): string | null {
    return localStorage.getItem(this.REFRESH_TOKEN_KEY)
  }

  /**
   * Check if current token is valid (not expired)
   */
  static isTokenValid(): boolean {
    const token = localStorage.getItem(this.ACCESS_TOKEN_KEY)
    const expiryStr = localStorage.getItem(this.TOKEN_EXPIRY_KEY)
    
    if (!token || !expiryStr) {
      return false
    }

    const expiry = parseInt(expiryStr)
    const now = Date.now()
    
    // Token is valid if it has at least 1 minute before expiry
    return expiry - now > 60 * 1000
  }

  /**
   * Check if token needs refresh (expires in less than 5 minutes)
   */
  static shouldRefreshToken(): boolean {
    const expiryStr = localStorage.getItem(this.TOKEN_EXPIRY_KEY)
    if (!expiryStr) return false

    const expiry = parseInt(expiryStr)
    const now = Date.now()
    const timeUntilExpiry = expiry - now

    // Refresh if less than 5 minutes until expiry
    return timeUntilExpiry < 5 * 60 * 1000 && timeUntilExpiry > 0
  }

  /**
   * Get time until token expiry in milliseconds
   */
  static getTimeUntilExpiry(): number {
    const expiryStr = localStorage.getItem(this.TOKEN_EXPIRY_KEY)
    if (!expiryStr) return 0

    const expiry = parseInt(expiryStr)
    return Math.max(0, expiry - Date.now())
  }

  /**
   * Schedule automatic token refresh
   */
  private static scheduleTokenRefresh(): void {
    // Clear existing timer
    this.clearRefreshTimer()

    const timeUntilExpiry = this.getTimeUntilExpiry()
    if (timeUntilExpiry <= 0) return

    // Schedule refresh 5 minutes before expiry
    const refreshTime = Math.max(0, timeUntilExpiry - 5 * 60 * 1000)
    
    this.refreshTimer = setTimeout(() => {
      debug.auth('Auto-refreshing token')
      window.dispatchEvent(new CustomEvent('auth:token-refresh-needed'))
    }, refreshTime)
  }

  /**
   * Clear refresh timer
   */
  private static clearRefreshTimer(): void {
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer)
      this.refreshTimer = null
    }
  }

  /**
   * Clear all tokens and related data
   */
  static clearTokens(): void {
    // Clear timer first
    this.clearRefreshTimer()
    
    // Clear storage
    localStorage.removeItem(this.ACCESS_TOKEN_KEY)
    localStorage.removeItem(this.REFRESH_TOKEN_KEY)
    localStorage.removeItem(this.TOKEN_EXPIRY_KEY)
    localStorage.removeItem(this.USER_DATA_KEY)
    
    // Notify other tabs
    window.dispatchEvent(new CustomEvent('auth:tokens-cleared'))
  }

  /**
   * Get stored user data from token
   */
  static getUserData(): { userId: string; email: string; role: string } | null {
    const dataStr = localStorage.getItem(this.USER_DATA_KEY)
    if (!dataStr) return null
    
    try {
      return JSON.parse(dataStr)
    } catch {
      return null
    }
  }

  /**
   * Check if user has specific role
   */
  static hasRole(role: string): boolean {
    const userData = this.getUserData()
    return userData?.role === role
  }

  /**
   * Initialize token manager (set up refresh timer if needed)
   */
  static initialize(): void {
    if (this.isTokenValid()) {
      this.scheduleTokenRefresh()
    } else {
      this.clearTokens()
    }
  }

  /**
   * Handle refresh with deduplication
   */
  static async refreshTokenWithDedup(refreshFn: () => Promise<{ accessToken: string; refreshToken: string }>): Promise<boolean> {
    // If already refreshing, wait for that to complete
    if (this.refreshPromise) {
      return this.refreshPromise
    }

    // Start new refresh
    this.refreshPromise = (async () => {
      try {
        const tokens = await refreshFn()
        return this.setTokens(tokens.accessToken, tokens.refreshToken)
      } catch (error) {
        debug.error('Token refresh failed:', error)
        return false
      } finally {
        this.refreshPromise = null
      }
    })()

    return this.refreshPromise
  }
}

export default TokenManager
</file>

<file path="frontend/src/test/utils.tsx">
import React, { ReactElement } from 'react';
import { render, RenderOptions, RenderResult } from '@testing-library/react';
import { MemoryRouter, MemoryRouterProps } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { vi } from 'vitest';
import { User, UserRole } from '../types/auth';

// Create test query client
const createTestQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});

// Mock auth store for testing
interface MockAuthStore {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  login: ReturnType<typeof vi.fn>;
  logout: ReturnType<typeof vi.fn>;
  setUser: ReturnType<typeof vi.fn>;
}

const createMockAuthStore = (overrides?: Partial<MockAuthStore>): MockAuthStore => ({
  user: null,
  token: null,
  isAuthenticated: false,
  login: vi.fn(),
  logout: vi.fn(),
  setUser: vi.fn(),
  ...overrides
});

// Test wrapper component
interface TestWrapperProps {
  children: React.ReactNode;
  routerProps?: MemoryRouterProps;
  queryClient?: QueryClient;
  authStore?: Partial<MockAuthStore>;
}

const TestWrapper: React.FC<TestWrapperProps> = ({
  children,
  routerProps,
  queryClient = createTestQueryClient(),
  authStore = {}
}) => {
  // Mock the auth store
  const mockStore = createMockAuthStore(authStore);
  vi.doMock('../stores/authStore', () => ({
    useAuthStore: () => mockStore
  }));

  return (
    <QueryClientProvider client={queryClient}>
      <MemoryRouter {...routerProps}>
        {children}
      </MemoryRouter>
    </QueryClientProvider>
  );
};

// Custom render function
interface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {
  routerProps?: MemoryRouterProps;
  queryClient?: QueryClient;
  authStore?: Partial<MockAuthStore>;
}

const customRender = (
  ui: ReactElement,
  options: CustomRenderOptions = {}
): RenderResult => {
  const { routerProps, queryClient, authStore, ...renderOptions } = options;

  const Wrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (
    <TestWrapper
      routerProps={routerProps}
      queryClient={queryClient}
      authStore={authStore}
    >
      {children}
    </TestWrapper>
  );

  return render(ui, { wrapper: Wrapper, ...renderOptions });
};

// Test user factories
export const createTestUser = (overrides?: Partial<User>): User => ({
  id: '1',
  email: 'test@example.com',
  firstName: 'Test',
  lastName: 'User',
  role: 'STUDENT' as UserRole,
  avatar: null,
  bio: null,
  createdAt: '2023-01-01T00:00:00.000Z',
  updatedAt: '2023-01-01T00:00:00.000Z',
  ...overrides
});

export const createTestTeacher = (overrides?: Partial<User>): User =>
  createTestUser({ role: 'TEACHER' as UserRole, ...overrides });

export const createTestStudent = (overrides?: Partial<User>): User =>
  createTestUser({ role: 'STUDENT' as UserRole, ...overrides });

export const createTestAdmin = (overrides?: Partial<User>): User =>
  createTestUser({ role: 'ADMIN' as UserRole, ...overrides });

// Mock API responses
export const mockApiResponse = <T,>(data: T, delay = 0) => {
  return new Promise<T>((resolve) => {
    setTimeout(() => resolve(data), delay);
  });
};

export const mockApiError = (message: string, status = 500, delay = 0) => {
  return new Promise((_, reject) => {
    setTimeout(() => {
      const error = new Error(message);
      (error as any).response = { status, data: { message } };
      reject(error);
    }, delay);
  });
};

// Mock fetch responses
export const mockFetch = (data: any, options?: { status?: number; delay?: number }) => {
  const { status = 200, delay = 0 } = options || {};
  
  return vi.fn().mockImplementation(() =>
    new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          ok: status >= 200 && status < 300,
          status,
          json: () => Promise.resolve(data),
          text: () => Promise.resolve(JSON.stringify(data)),
        });
      }, delay);
    })
  );
};

// Video player test utilities
export const mockVideoPlayer = {
  play: vi.fn(),
  pause: vi.fn(),
  seekTo: vi.fn(),
  getCurrentTime: vi.fn().mockReturnValue(0),
  getDuration: vi.fn().mockReturnValue(300),
  getSecondsLoaded: vi.fn().mockReturnValue(300),
};

// Form test utilities
export const fillForm = async (form: HTMLFormElement, values: Record<string, string>) => {
  const { fireEvent } = await import('@testing-library/react');
  
  Object.entries(values).forEach(([name, value]) => {
    const field = form.querySelector(`[name="${name}"]`) as HTMLInputElement;
    if (field) {
      fireEvent.change(field, { target: { value } });
    }
  });
};

// Wait for loading states
export const waitForLoadingToFinish = async () => {
  const { waitForElementToBeRemoved, screen } = await import('@testing-library/react');
  
  try {
    await waitForElementToBeRemoved(() => screen.queryByTestId('loading-spinner'), {
      timeout: 3000
    });
  } catch {
    // Loading spinner might not be present, which is fine
  }
};

// Local storage mock
export const mockLocalStorage = () => {
  const storage: Record<string, string> = {};
  
  return {
    getItem: vi.fn((key: string) => storage[key] || null),
    setItem: vi.fn((key: string, value: string) => {
      storage[key] = value;
    }),
    removeItem: vi.fn((key: string) => {
      delete storage[key];
    }),
    clear: vi.fn(() => {
      Object.keys(storage).forEach(key => delete storage[key]);
    }),
  };
};

// Session storage mock
export const mockSessionStorage = mockLocalStorage;

// Window location mock
export const mockLocation = (url: string) => {
  delete (window as any).location;
  window.location = new URL(url) as any;
};

// Custom matchers
expect.extend({
  toHaveBeenCalledWithMatch(received: any, expected: any) {
    const calls = received.mock.calls;
    const pass = calls.some((call: any[]) => 
      call.some((arg: any) => 
        typeof expected === 'function' ? expected(arg) : arg === expected
      )
    );
    
    return {
      message: () => 
        pass 
          ? `Expected function not to have been called with matching argument`
          : `Expected function to have been called with matching argument`,
      pass
    };
  }
});

// Re-export everything from testing library
export * from '@testing-library/react';
export * from '@testing-library/user-event';

// Export custom render as default render
export { customRender as render };
export { TestWrapper, createTestQueryClient, createMockAuthStore };
</file>

<file path="frontend/src/utils/debug.ts">
/**
 * Debug utility for conditional logging
 * 
 * Enable debug mode in development:
 * - localStorage.setItem('debug', 'true') - Enable debug logs
 * - localStorage.removeItem('debug') - Disable debug logs
 */

const isDevelopment = import.meta.env.MODE === 'development'
const isDebugEnabled = () => {
  if (typeof window === 'undefined') return false
  return isDevelopment && localStorage.getItem('debug') === 'true'
}

export const debug = {
  /**
   * Log debug information (only in debug mode)
   */
  log: (...args: unknown[]) => {
    if (isDebugEnabled()) {
      console.log('[DEBUG]', ...args)
    }
  },

  /**
   * Log informational messages (only in development)
   */
  info: (...args: unknown[]) => {
    if (isDevelopment) {
      console.info('[INFO]', ...args)
    }
  },

  /**
   * Log warnings (always in development, never in production)
   */
  warn: (...args: unknown[]) => {
    if (isDevelopment) {
      console.warn('[WARN]', ...args)
    }
  },

  /**
   * Log errors (always logged)
   */
  error: (...args: unknown[]) => {
    console.error('[ERROR]', ...args)
  },

  /**
   * Log API calls (only in debug mode)
   */
  api: (method: string, url: string, duration?: number) => {
    if (isDebugEnabled()) {
      const message = duration 
        ? `[API] ${method} ${url} - ${duration}ms`
        : `[API] ${method} ${url}`
      console.log(message)
    }
  },

  /**
   * Log auth events (only in debug mode)
   */
  auth: (event: string, data?: unknown) => {
    if (isDebugEnabled()) {
      console.log(`[AUTH] ${event}`, data || '')
    }
  },

  /**
   * Log video player events (only in debug mode)
   */
  video: (event: string, data?: unknown) => {
    if (isDebugEnabled()) {
      console.log(`[VIDEO] ${event}`, data || '')
    }
  },

  /**
   * Check if debug mode is enabled
   */
  isEnabled: isDebugEnabled,

  /**
   * Enable debug mode
   */
  enable: () => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('debug', 'true')
      console.log('[DEBUG] Debug mode enabled')
    }
  },

  /**
   * Disable debug mode
   */
  disable: () => {
    if (typeof window !== 'undefined') {
      localStorage.removeItem('debug')
      console.log('[DEBUG] Debug mode disabled')
    }
  }
}

// Make debug tools available globally in development
if (isDevelopment && typeof window !== 'undefined') {
  (window as typeof globalThis & { debug: typeof debug }).debug = debug
}
</file>

<file path="frontend/src/utils/progressCalculator.ts">
import type { Video, VideoSession } from '../services/video'

export interface ProgressData {
  completionPercentage: number
  milestonesReached: number
  correctAnswers: number
  totalAnswers: number
}

export interface SessionMetadata {
  completionPercentage?: number
  correctAnswers?: number
  totalAnswers?: number
}

export class ProgressCalculator {
  /**
   * Calculate completion percentage from session and video data
   */
  static calculateCompletionPercentage(
    session: VideoSession | null | undefined,
    video: Video | null | undefined,
    sessionMeta?: SessionMetadata
  ): number {
    console.log('📊 ProgressCalculator inputs:', {
      sessionExists: !!session,
      sessionStatus: session?.status,
      sessionCurrentPosition: session?.currentPosition,
      videoExists: !!video,
      videoDuration: video?.duration,
      sessionMetaCompletion: sessionMeta?.completionPercentage
    })

    // Check if session is completed first
    if (session?.status === 'COMPLETED') {
      console.log('📊 Session completed, returning 100%')
      return 100
    }

    // Try to calculate from session position and video duration
    const currentPos = session?.currentPosition || 0
    const duration = video?.duration

    if (duration && duration > 0 && currentPos > 0) {
      const percentage = Math.round((currentPos / duration) * 100)
      console.log('📊 Progress calc from session/video:', { currentPos, duration, percentage })
      return Math.min(100, Math.max(0, percentage))
    }

    // Fall back to sessionMeta if available and greater than 0
    if (sessionMeta?.completionPercentage !== undefined && sessionMeta.completionPercentage > 0) {
      console.log('📊 Using sessionMeta completionPercentage:', sessionMeta.completionPercentage)
      return Math.min(100, Math.max(0, sessionMeta.completionPercentage))
    }

    // Default to 0 if nothing else works
    console.log('📊 No meaningful progress data available, returning 0%')
    return 0
  }

  /**
   * Calculate number of milestones reached
   */
  static calculateMilestonesReached(session: VideoSession | null | undefined): number {
    return session?.milestoneProgress?.length || 0
  }

  /**
   * Calculate correct and total answers
   */
  static calculateAnswerStats(
    session: VideoSession | null | undefined,
    sessionMeta?: SessionMetadata
  ): { correct: number; total: number } {
    // Use sessionMeta if available
    if (sessionMeta?.correctAnswers !== undefined && sessionMeta?.totalAnswers !== undefined) {
      return {
        correct: sessionMeta.correctAnswers,
        total: sessionMeta.totalAnswers
      }
    }

    // Fall back to session data
    const questionAttempts = session?.questionAttempts || []
    const correct = questionAttempts.filter((qa) => qa.isCorrect).length
    const total = questionAttempts.length

    return { correct, total }
  }

  /**
   * Get all progress data in one call
   */
  static calculateAllProgress(
    session: VideoSession | null | undefined,
    video: Video | null | undefined,
    sessionMeta?: SessionMetadata
  ): ProgressData {
    const completionPercentage = this.calculateCompletionPercentage(session, video, sessionMeta)
    const milestonesReached = this.calculateMilestonesReached(session)
    const { correct: correctAnswers, total: totalAnswers } = this.calculateAnswerStats(session, sessionMeta)

    return {
      completionPercentage,
      milestonesReached,
      correctAnswers,
      totalAnswers
    }
  }
}
</file>

<file path="frontend/src/utils/validators.ts">
/**
 * Custom validators for the Interactive Learning Platform
 * Handles CUID format validation since database uses CUID instead of UUID
 */

import type { ValidationChain, CustomValidator } from 'express-validator';
import { param, body, query } from 'express-validator';

/**
 * CUID format validation
 * CUID pattern: starts with 'c' followed by 24 lowercase alphanumeric characters
 * Example: c123456789012345678901234
 */
const CUID_PATTERN = /^c[a-z0-9]{24}$/;

/**
 * Custom validator to check if value matches CUID format
 */
export const isCUID: CustomValidator = (value: string) => {
  if (!value || typeof value !== 'string') {
    throw new Error('Value must be a string');
  }
  
  if (!CUID_PATTERN.test(value)) {
    throw new Error('Invalid CUID format');
  }
  
  return true;
};

/**
 * Validation chain for CUID parameters
 */
export const validateCUIDParam = (paramName: string, message?: string): ValidationChain => {
  return param(paramName).custom(isCUID).withMessage(message || `Invalid ${paramName}`);
};

/**
 * Validation chain for CUID body fields
 */
export const validateCUIDBody = (fieldName: string, message?: string): ValidationChain => {
  return body(fieldName).custom(isCUID).withMessage(message || `Valid ${fieldName} is required`);
};

/**
 * Validation chain for optional CUID query parameters
 */
export const validateCUIDQuery = (queryName: string, message?: string): ValidationChain => {
  return query(queryName).optional().custom(isCUID).withMessage(message || `Invalid ${queryName}`);
};

/**
 * Helper function to validate CUID string directly
 * Useful for programmatic validation outside of express-validator
 */
export const isValidCUID = (value: string): boolean => {
  return typeof value === 'string' && CUID_PATTERN.test(value);
};
</file>

<file path="frontend/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src/**/*"],
  "exclude": ["src/**/*.test.tsx", "src/**/*.test.ts", "src/test/**/*"]
}
</file>

<file path="frontend/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3001,
    host: '0.0.0.0',
    strictPort: true,
  },
})
</file>

<file path="src/config/database.ts">
import { PrismaClient } from '@prisma/client';
import { logger } from '@/utils/logger';

declare global {
  // eslint-disable-next-line no-var
  var __prisma: PrismaClient | undefined;
}

// Prevent multiple instances of Prisma Client in development
const prisma = globalThis.__prisma || new PrismaClient({
  log: [
    { level: 'query', emit: 'event' },
    { level: 'error', emit: 'stdout' },
    { level: 'info', emit: 'stdout' },
    { level: 'warn', emit: 'stdout' },
  ],
});

if (process.env.NODE_ENV !== 'production') {
  globalThis.__prisma = prisma;
}

// Log database queries in development
if (process.env.NODE_ENV === 'development') {
  prisma.$on('query' as never, (e: any) => {
    logger.debug('Database Query', {
      query: e.query,
      params: e.params,
      duration: `${e.duration}ms`,
    });
  });
}

// Handle graceful shutdown
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});

process.on('SIGINT', async () => {
  await prisma.$disconnect();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  await prisma.$disconnect();
  process.exit(0);
});

export { prisma };
export default prisma;

// Export connect function for backwards compatibility
export const connectDatabase = async () => {
  try {
    await prisma.$connect();
    logger.info('Database connected successfully');
  } catch (error) {
    logger.error('Failed to connect to database:', error);
    throw error;
  }
};
</file>

<file path="src/config/environment.ts">
import dotenv from 'dotenv';
import { z } from 'zod';

// Load environment variables
dotenv.config();

// Environment variables schema with validation
const envSchema = z.object({
  // Server Configuration
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  PORT: z.coerce.number().default(3000),
  API_VERSION: z.string().default('v1'),

  // Database Configuration
  DATABASE_URL: z.string().url(),

  // JWT Configuration
  JWT_SECRET: z.string().min(32),
  JWT_REFRESH_SECRET: z.string().min(32),
  JWT_EXPIRES_IN: z.string().default('15m'),
  JWT_REFRESH_EXPIRES_IN: z.string().default('7d'),

  // Google Cloud Storage (optional in development)
  GOOGLE_CLOUD_PROJECT_ID: z.string().optional(),
  GOOGLE_CLOUD_STORAGE_BUCKET: z.string().optional(),
  GOOGLE_APPLICATION_CREDENTIALS: z.string().optional(),

  // Redis Configuration
  REDIS_URL: z.string().url().default('redis://localhost:6379'),
  REDIS_PASSWORD: z.string().optional(),
  REDIS_DB: z.coerce.number().default(0),

  // AI Provider Configuration
  OPENAI_API_KEY: z.string().optional(),
  ANTHROPIC_API_KEY: z.string().optional(),
  GOOGLE_PALM_API_KEY: z.string().optional(),

  // Email Configuration (Optional)
  SMTP_HOST: z.string().optional(),
  SMTP_PORT: z.coerce.number().optional(),
  SMTP_USER: z.string().email().optional(),
  SMTP_PASS: z.string().optional(),

  // Rate Limiting
  RATE_LIMIT_WINDOW: z.coerce.number().default(15),
  RATE_LIMIT_MAX_REQUESTS: z.coerce.number().default(100),

  // Logging
  LOG_LEVEL: z.enum(['error', 'warn', 'info', 'debug']).default('info'),
  LOG_FILE: z.string().default('logs/app.log'),

  // Session Configuration
  SESSION_TIMEOUT: z.coerce.number().default(30),

  // Security Configuration
  BCRYPT_SALT_ROUNDS: z.coerce.number().default(12),
  MAX_FILE_SIZE: z.string().default('100MB'),
  ALLOWED_FILE_TYPES: z.string().default('mp4,avi,mov,wmv'),

  // Analytics Configuration
  ENABLE_ANALYTICS: z.coerce.boolean().default(true),
  ANALYTICS_RETENTION_DAYS: z.coerce.number().default(90),

  // CORS Configuration
  CORS_ORIGINS: z.string().default('http://localhost:3000,http://localhost:3001'),
  FRONTEND_URL: z.string().url().default('http://localhost:3000'),
});

// Parse and validate environment variables
const parseEnv = () => {
  try {
    return envSchema.parse(process.env);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const missingVars = error.issues.map(issue => issue.path.join('.')).join(', ');
      throw new Error(`Missing or invalid environment variables: ${missingVars}`);
    }
    throw error;
  }
};

export const env = parseEnv();

// Configuration object
export const config = {
  server: {
    port: env.PORT,
    nodeEnv: env.NODE_ENV,
    apiVersion: env.API_VERSION,
    isDevelopment: env.NODE_ENV === 'development',
    isProduction: env.NODE_ENV === 'production',
    isTest: env.NODE_ENV === 'test',
  },
  
  database: {
    url: env.DATABASE_URL,
  },
  
  jwt: {
    secret: env.JWT_SECRET,
    refreshSecret: env.JWT_REFRESH_SECRET,
    expiresIn: env.JWT_EXPIRES_IN,
    refreshExpiresIn: env.JWT_REFRESH_EXPIRES_IN,
  },
  
  googleCloud: {
    projectId: env.GOOGLE_CLOUD_PROJECT_ID,
    storageBucket: env.GOOGLE_CLOUD_STORAGE_BUCKET,
    credentials: env.GOOGLE_APPLICATION_CREDENTIALS,
  },
  
  redis: {
    url: env.REDIS_URL,
    password: env.REDIS_PASSWORD,
    db: env.REDIS_DB,
  },
  
  ai: {
    openai: {
      apiKey: env.OPENAI_API_KEY,
    },
    anthropic: {
      apiKey: env.ANTHROPIC_API_KEY,
    },
    googlePalm: {
      apiKey: env.GOOGLE_PALM_API_KEY,
    },
  },
  
  email: {
    host: env.SMTP_HOST,
    port: env.SMTP_PORT,
    user: env.SMTP_USER,
    password: env.SMTP_PASS,
  },
  
  rateLimit: {
    windowMs: env.RATE_LIMIT_WINDOW * 60 * 1000, // Convert minutes to milliseconds
    maxRequests: env.RATE_LIMIT_MAX_REQUESTS,
  },
  
  logging: {
    level: env.LOG_LEVEL,
    file: env.LOG_FILE,
  },
  
  session: {
    timeoutMinutes: env.SESSION_TIMEOUT,
  },
  
  security: {
    bcryptSaltRounds: env.BCRYPT_SALT_ROUNDS,
    maxFileSize: env.MAX_FILE_SIZE,
    allowedFileTypes: env.ALLOWED_FILE_TYPES.split(','),
  },
  
  analytics: {
    enabled: env.ENABLE_ANALYTICS,
    retentionDays: env.ANALYTICS_RETENTION_DAYS,
  },
  
  cors: {
    origins: env.CORS_ORIGINS.split(','),
  },
  
  frontend: {
    url: env.FRONTEND_URL,
  },
} as const;

// Export both named and default
export const environment = config;
export default config;
</file>

<file path="src/middleware/auth/authMiddleware.ts">
import { Request, Response, NextFunction } from 'express';
import { UserRole } from '@prisma/client';
import { jwtService } from '../../services/auth/jwtService';
import { prisma } from '../../config/database';
import { logger } from '../../utils/logger';
import { AppError } from '../../types';

// Extend Request interface to include user
export interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    username?: string;
    firstName: string;
    lastName: string;
    avatar?: string;
    role: UserRole;
    tenantId?: string;
    status: string;
    lastLoginAt?: Date;
    emailVerified?: Date;
    createdAt: Date;
  };
}

/**
 * Authentication middleware - Verifies JWT token and adds user to request
 */
export const authenticate = async (
  req: AuthenticatedRequest,
  _res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    // Extract token from Authorization header
    const authHeader = req.headers.authorization;
    const token = jwtService.extractTokenFromHeader(authHeader);
    
    if (!token) {
      throw new AppError('Authentication required', 401);
    }

    // Verify token
    const payload = jwtService.verifyAccessToken(token);
    
    // Get user from database to ensure they still exist and are active
    const user = await prisma.user.findUnique({
      where: { id: payload.userId },
      select: {
        id: true,
        email: true,
        username: true,
        firstName: true,
        lastName: true,
        avatar: true,
        role: true,
        status: true,
        tenantId: true,
        lastLoginAt: true,
        emailVerified: true,
        createdAt: true
      }
    });

    if (!user) {
      throw new AppError('User not found', 401);
    }

    if (user.status !== 'ACTIVE') {
      throw new AppError('Account is not active', 403);
    }

    // Add user to request object
    req.user = {
      id: user.id,
      email: user.email,
      username: user.username || undefined,
      firstName: user.firstName,
      lastName: user.lastName,
      avatar: user.avatar || undefined,
      role: user.role,
      status: user.status.toString(),
      tenantId: user.tenantId || undefined,
      lastLoginAt: user.lastLoginAt || undefined,
      emailVerified: user.emailVerified || undefined,
      createdAt: user.createdAt
    };

    // Log successful authentication
    logger.debug('User authenticated successfully', {
      userId: user.id,
      email: user.email,
      role: user.role,
      requestId: req.headers['x-request-id'],
      ip: req.ip
    });

    next();
  } catch (error) {
    logger.warn('Authentication failed', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: req.headers['x-request-id'],
      ip: req.ip,
      userAgent: req.headers['user-agent']
    });

    if (error instanceof AppError) {
      return next(error);
    }

    next(new AppError('Authentication failed', 401));
  }
};

/**
 * Optional authentication middleware - Adds user to request if token is present
 */
export const optionalAuthenticate = async (
  req: AuthenticatedRequest,
  _res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    const token = jwtService.extractTokenFromHeader(authHeader);
    
    if (!token) {
      return next(); // No token provided, continue without user
    }

    // Verify token
    const payload = jwtService.verifyAccessToken(token);
    
    // Get user from database
    const user = await prisma.user.findUnique({
      where: { id: payload.userId },
      select: {
        id: true,
        email: true,
        username: true,
        firstName: true,
        lastName: true,
        avatar: true,
        role: true,
        status: true,
        tenantId: true,
        lastLoginAt: true,
        emailVerified: true,
        createdAt: true
      }
    });

    if (user && user.status === 'ACTIVE') {
      req.user = {
        id: user.id,
        email: user.email,
        username: user.username || undefined,
        firstName: user.firstName,
        lastName: user.lastName,
        avatar: user.avatar || undefined,
        role: user.role,
        status: user.status.toString(),
        tenantId: user.tenantId || undefined,
        lastLoginAt: user.lastLoginAt || undefined,
        emailVerified: user.emailVerified || undefined,
        createdAt: user.createdAt
      };
    }

    next();
  } catch (error) {
    // In optional auth, we don't fail the request for invalid tokens
    logger.debug('Optional authentication failed', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: req.headers['x-request-id']
    });
    
    next();
  }
};

/**
 * Role-based authorization middleware factory
 */
export const authorize = (allowedRoles: UserRole[]) => {
  return (req: AuthenticatedRequest, _res: Response, next: NextFunction): void => {
    if (!req.user) {
      return next(new AppError('Authentication required', 401));
    }

    if (!allowedRoles.includes(req.user.role)) {
      logger.warn('Authorization failed - insufficient permissions', {
        userId: req.user.id,
        userRole: req.user.role,
        requiredRoles: allowedRoles,
        requestId: req.headers['x-request-id'],
        path: req.path,
        method: req.method
      });

      return next(new AppError('Insufficient permissions', 403));
    }

    logger.debug('Authorization successful', {
      userId: req.user.id,
      userRole: req.user.role,
      requestId: req.headers['x-request-id']
    });

    next();
  };
};

/**
 * Resource ownership check middleware factory
 */
export const authorizeOwnership = (resourceIdParam: string = 'id') => {
  return (req: AuthenticatedRequest, _res: Response, next: NextFunction): void => {
    if (!req.user) {
      return next(new AppError('Authentication required', 401));
    }

    const resourceId = req.params[resourceIdParam];
    const userId = req.user.id;
    
    // Admin users can access any resource
    if (req.user.role === 'ADMIN') {
      return next();
    }

    // For students and teachers, they can only access their own resources
    if (resourceIdParam === 'userId' || resourceIdParam === 'studentId') {
      if (resourceId !== userId) {
        logger.warn('Authorization failed - resource ownership violation', {
          userId,
          resourceId,
          requestId: req.headers['x-request-id'],
          path: req.path
        });

        return next(new AppError('Access denied', 403));
      }
    }

    next();
  };
};

/**
 * Tenant isolation middleware
 */
export const authorizeTenant = (req: AuthenticatedRequest, _res: Response, next: NextFunction): void => {
  if (!req.user) {
    return next(new AppError('Authentication required', 401));
  }

  // Admin users can access all tenants
  if (req.user.role === 'ADMIN') {
    return next();
  }

  // For multi-tenant scenarios, ensure user can only access their tenant's data
  const tenantId = req.params.tenantId || req.body.tenantId || req.query.tenantId;
  
  if (tenantId && req.user.tenantId && tenantId !== req.user.tenantId) {
    logger.warn('Authorization failed - tenant isolation violation', {
      userId: req.user.id,
      userTenantId: req.user.tenantId,
      requestedTenantId: tenantId,
      requestId: req.headers['x-request-id']
    });

    return next(new AppError('Access denied', 403));
  }

  next();
};

/**
 * API Key authentication middleware (for service-to-service calls)
 */
export const authenticateApiKey = (req: Request, _res: Response, next: NextFunction): void => {
  const apiKey = req.headers['x-api-key'] as string;
  
  if (!apiKey) {
    return next(new AppError('API key required', 401));
  }

  // In a real implementation, you would validate the API key against a database
  // For now, we'll use a simple environment variable check
  const validApiKey = process.env.INTERNAL_API_KEY;
  
  if (!validApiKey || apiKey !== validApiKey) {
    logger.warn('Invalid API key attempt', {
      providedKey: apiKey.substring(0, 8) + '...',
      requestId: req.headers['x-request-id'],
      ip: req.ip
    });

    return next(new AppError('Invalid API key', 401));
  }

  // Set internal request flag
  req.headers['x-internal-request'] = 'true';
  
  next();
};
</file>

<file path="src/middleware/logger/requestLogger.ts">
import { Request, Response, NextFunction } from 'express';
import { logger } from '../../utils/logger';
import { performance } from 'perf_hooks';

interface RequestWithTiming extends Request {
  startTime?: number;
}

export const requestLogger = (req: RequestWithTiming, res: Response, next: NextFunction) => {
  const startTime = performance.now();
  req.startTime = startTime;
  
  // Get request details
  const requestId = req.headers['x-request-id'] as string;
  const userAgent = req.headers['user-agent'];
  const forwarded = req.headers['x-forwarded-for'] as string;
  const realIp = forwarded ? forwarded.split(',')[0].trim() : req.ip;
  const userId = (req as any).user?.id;
  
  // Log request start
  logger.info('Request started', {
    requestId,
    method: req.method,
    url: req.originalUrl,
    ip: realIp,
    userAgent,
    userId: userId || 'anonymous',
    contentLength: req.headers['content-length'],
    timestamp: new Date().toISOString()
  });

  // Override res.end to log response
  const originalEnd = res.end;
  res.end = function(chunk?: any, encoding?: any): any {
    const endTime = performance.now();
    const duration = Math.round((endTime - startTime) * 100) / 100; // Round to 2 decimal places
    
    // Determine log level based on status code
    let logLevel: 'info' | 'warn' | 'error' = 'info';
    if (res.statusCode >= 400 && res.statusCode < 500) {
      logLevel = 'warn';
    } else if (res.statusCode >= 500) {
      logLevel = 'error';
    }
    
    // Log response
    logger[logLevel]('Request completed', {
      requestId,
      method: req.method,
      url: req.originalUrl,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      contentLength: res.getHeader('content-length'),
      ip: realIp,
      userId: userId || 'anonymous',
      userAgent,
      timestamp: new Date().toISOString()
    });
    
    // Log slow requests
    if (duration > 1000) {
      logger.warn('Slow request detected', {
        requestId,
        method: req.method,
        url: req.originalUrl,
        duration: `${duration}ms`,
        statusCode: res.statusCode,
        userId: userId || 'anonymous'
      });
    }
    
    // Call original end method and return its result
    return originalEnd.call(this, chunk, encoding);
  };

  next();
};
</file>

<file path="src/services/storage/gcsService.ts">
import { Storage } from '@google-cloud/storage';
import { logger } from '../../utils/logger';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';

export class GCSService {
  private storage: Storage;
  private bucketName: string;

  constructor() {
    this.storage = new Storage({
      projectId: process.env.GOOGLE_CLOUD_PROJECT_ID,
      keyFilename: process.env.GOOGLE_CLOUD_KEY_FILE
    });
    this.bucketName = process.env.GCS_BUCKET_NAME || 'interactive-learning-videos';
  }

  /**
   * Upload video file to Google Cloud Storage
   */
  async uploadVideo(
    file: Express.Multer.File,
    lessonId: string,
    videoGroupId: string,
    userId: string
  ): Promise<{
    gcsPath: string;
    gcsUrl: string;
    publicUrl: string;
  }> {
    try {
      const bucket = this.storage.bucket(this.bucketName);
      
      // Generate unique file path
      const fileExtension = path.extname(file.originalname);
      const fileName = `${uuidv4()}${fileExtension}`;
      const gcsPath = `lessons/${lessonId}/videos/${fileName}`;
      
      const gcsFile = bucket.file(gcsPath);

      // Upload file
      await gcsFile.save(file.buffer, {
        metadata: {
          contentType: file.mimetype,
          metadata: {
            originalName: file.originalname,
            uploadedBy: userId,
            lessonId: lessonId,
            videoGroupId: videoGroupId,
            uploadTimestamp: new Date().toISOString()
          }
        }
      });

      // Generate signed URL for streaming (expires in 1 year)
      const [signedUrl] = await gcsFile.getSignedUrl({
        action: 'read',
        expires: Date.now() + 365 * 24 * 60 * 60 * 1000, // 1 year
      });

      // Generate public URL (if bucket is public)
      const publicUrl = `https://storage.googleapis.com/${this.bucketName}/${gcsPath}`;

      logger.info(`Video uploaded to GCS: ${gcsPath}`, {
        originalName: file.originalname,
        size: file.size,
        userId,
        lessonId,
        videoGroupId
      });

      return {
        gcsPath,
        gcsUrl: signedUrl,
        publicUrl
      };
    } catch (error) {
      logger.error('Error uploading video to GCS:', error);
      throw new Error('Failed to upload video to cloud storage');
    }
  }

  /**
   * Upload thumbnail image to Google Cloud Storage
   */
  async uploadThumbnail(
    thumbnailBuffer: Buffer,
    videoId: string,
    mimeType: string
  ): Promise<string> {
    try {
      const bucket = this.storage.bucket(this.bucketName);
      
      const fileName = `${videoId}_thumbnail.jpg`;
      const gcsPath = `thumbnails/${fileName}`;
      
      const gcsFile = bucket.file(gcsPath);

      await gcsFile.save(thumbnailBuffer, {
        metadata: {
          contentType: mimeType,
          metadata: {
            videoId: videoId,
            type: 'thumbnail',
            generatedAt: new Date().toISOString()
          }
        }
      });

      const publicUrl = `https://storage.googleapis.com/${this.bucketName}/${gcsPath}`;

      logger.info(`Thumbnail uploaded to GCS: ${gcsPath}`, { videoId });

      return publicUrl;
    } catch (error) {
      logger.error('Error uploading thumbnail to GCS:', error);
      throw new Error('Failed to upload thumbnail to cloud storage');
    }
  }

  /**
   * Delete video file from Google Cloud Storage
   */
  async deleteVideo(gcsPath: string): Promise<void> {
    try {
      const bucket = this.storage.bucket(this.bucketName);
      const file = bucket.file(gcsPath);

      await file.delete();

      logger.info(`Video deleted from GCS: ${gcsPath}`);
    } catch (error) {
      logger.error('Error deleting video from GCS:', error);
      throw new Error('Failed to delete video from cloud storage');
    }
  }

  /**
   * Generate new signed URL for video streaming
   */
  async refreshVideoUrl(gcsPath: string): Promise<string> {
    try {
      const bucket = this.storage.bucket(this.bucketName);
      const file = bucket.file(gcsPath);

      const [signedUrl] = await file.getSignedUrl({
        action: 'read',
        expires: Date.now() + 365 * 24 * 60 * 60 * 1000, // 1 year
      });

      return signedUrl;
    } catch (error) {
      logger.error('Error refreshing video URL:', error);
      throw new Error('Failed to refresh video URL');
    }
  }

  /**
   * Get video metadata from Google Cloud Storage
   */
  async getVideoMetadata(gcsPath: string): Promise<any> {
    try {
      const bucket = this.storage.bucket(this.bucketName);
      const file = bucket.file(gcsPath);

      const [metadata] = await file.getMetadata();

      return {
        size: metadata.size,
        contentType: metadata.contentType,
        created: metadata.timeCreated,
        updated: metadata.updated,
        md5Hash: metadata.md5Hash,
        etag: metadata.etag,
        customMetadata: metadata.metadata
      };
    } catch (error) {
      logger.error('Error getting video metadata from GCS:', error);
      throw new Error('Failed to get video metadata');
    }
  }

  /**
   * Check if video file exists in Google Cloud Storage
   */
  async videoExists(gcsPath: string): Promise<boolean> {
    try {
      const bucket = this.storage.bucket(this.bucketName);
      const file = bucket.file(gcsPath);

      const [exists] = await file.exists();
      return exists;
    } catch (error) {
      logger.error('Error checking video existence in GCS:', error);
      return false;
    }
  }

  /**
   * Copy video to different location in bucket
   */
  async copyVideo(sourcePath: string, destinationPath: string): Promise<void> {
    try {
      const bucket = this.storage.bucket(this.bucketName);
      const sourceFile = bucket.file(sourcePath);
      const destinationFile = bucket.file(destinationPath);

      await sourceFile.copy(destinationFile);

      logger.info(`Video copied in GCS: ${sourcePath} -> ${destinationPath}`);
    } catch (error) {
      logger.error('Error copying video in GCS:', error);
      throw new Error('Failed to copy video in cloud storage');
    }
  }

  /**
   * List all videos in a lesson directory
   */
  async listLessonVideos(lessonId: string): Promise<string[]> {
    try {
      const bucket = this.storage.bucket(this.bucketName);
      const prefix = `lessons/${lessonId}/videos/`;

      const [files] = await bucket.getFiles({ prefix });
      
      return files.map(file => file.name);
    } catch (error) {
      logger.error('Error listing lesson videos in GCS:', error);
      throw new Error('Failed to list lesson videos');
    }
  }

  /**
   * Get storage usage statistics
   */
  async getStorageStats(): Promise<{
    totalSize: number;
    fileCount: number;
    videoCount: number;
    thumbnailCount: number;
  }> {
    try {
      const bucket = this.storage.bucket(this.bucketName);
      const [files] = await bucket.getFiles();

      let totalSize = 0;
      let videoCount = 0;
      let thumbnailCount = 0;

      files.forEach(file => {
        const metadata = file.metadata;
        totalSize += parseInt(String(metadata.size || '0'));

        if (file.name.startsWith('lessons/') && file.name.includes('/videos/')) {
          videoCount++;
        } else if (file.name.startsWith('thumbnails/')) {
          thumbnailCount++;
        }
      });

      return {
        totalSize,
        fileCount: files.length,
        videoCount,
        thumbnailCount
      };
    } catch (error) {
      logger.error('Error getting storage statistics:', error);
      throw new Error('Failed to get storage statistics');
    }
  }
}

export const gcsService = new GCSService();
</file>

<file path="src/services/QuestionService.ts">
import { PrismaClient, QuestionType, QuestionStatus } from '@prisma/client'
import { User } from '../types/auth'

const prisma = new PrismaClient()

interface CreateQuestionData {
  milestoneId: string
  type: QuestionType
  text: string
  explanation?: string
  hints?: string[]
  difficulty?: string
  points?: number
  passThreshold?: number
  questionData: any // Flexible JSON for different question types
}

interface UpdateQuestionData {
  text?: string
  explanation?: string
  hints?: string[]
  difficulty?: string
  points?: number
  passThreshold?: number
  questionData?: any
  status?: QuestionStatus
}

export class QuestionService {
  /**
   * Create a new question for a milestone
   */
  static async createQuestion(data: CreateQuestionData, user: User) {
    // Check if milestone exists and user has permission
    const milestone = await prisma.milestone.findUnique({
      where: { id: data.milestoneId },
      include: {
        video: {
          include: {
            videoGroup: {
              include: {
                lesson: true
              }
            }
          }
        }
      }
    })

    if (!milestone) {
      throw new Error('Milestone not found')
    }

    // Check permissions - only lesson creator or admin can create questions
    if (
      milestone.video.videoGroup.lesson.createdById !== user.id && 
      user.role !== 'ADMIN'
    ) {
      throw new Error('Access denied')
    }

    // Validate question data based on type
    this.validateQuestionData(data.type, data.questionData)

    const question = await prisma.question.create({
      data: {
        milestoneId: data.milestoneId,
        type: data.type,
        text: data.text,
        explanation: data.explanation || null,
        hints: data.hints || [],
        difficulty: data.difficulty || null,
        questionData: data.questionData,
        points: data.points || 1,
        passThreshold: data.passThreshold || 0.7,
        createdById: user.id,
        status: 'DRAFT'
      },
      include: {
        milestone: {
          select: {
            id: true,
            title: true,
            timestamp: true
          }
        },
        createdBy: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    })

    return question
  }

  /**
   * Get all questions for a milestone
   */
  static async getQuestionsByMilestone(milestoneId: string, userId: string) {
    // Check if user has access to the milestone
    const milestone = await prisma.milestone.findFirst({
      where: {
        id: milestoneId,
        video: {
          videoGroup: {
            lesson: {
              OR: [
                { createdById: userId },
                {
                  studentProgress: {
                    some: {
                      studentId: userId
                    }
                  }
                }
              ]
            }
          }
        }
      }
    })

    if (!milestone) {
      throw new Error('Milestone not found or access denied')
    }

    const questions = await prisma.question.findMany({
      where: { milestoneId },
      include: {
        createdBy: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        _count: {
          select: {
            attempts: true
          }
        }
      },
      orderBy: { createdAt: 'asc' }
    })

    return questions
  }

  /**
   * Get a specific question by ID
   */
  static async getQuestionById(questionId: string, userId: string) {
    const question = await prisma.question.findFirst({
      where: {
        id: questionId,
        milestone: {
          video: {
            videoGroup: {
              lesson: {
                OR: [
                  { createdById: userId },
                  {
                    studentProgress: {
                      some: {
                        studentId: userId
                      }
                    }
                  }
                ]
              }
            }
          }
        }
      },
      include: {
        milestone: {
          include: {
            video: {
              select: {
                id: true,
                title: true
              }
            }
          }
        },
        createdBy: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        _count: {
          select: {
            attempts: true
          }
        }
      }
    })

    return question
  }

  /**
   * Update a question
   */
  static async updateQuestion(questionId: string, data: UpdateQuestionData, user: User) {
    // Check if question exists and user has permission
    const existingQuestion = await prisma.question.findUnique({
      where: { id: questionId },
      include: {
        milestone: {
          include: {
            video: {
              include: {
                videoGroup: {
                  include: {
                    lesson: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!existingQuestion) {
      throw new Error('Question not found')
    }

    // Check permissions - only question creator, lesson creator, or admin can update
    if (
      existingQuestion.createdById !== user.id &&
      existingQuestion.milestone.video.videoGroup.lesson.createdById !== user.id && 
      user.role !== 'ADMIN'
    ) {
      throw new Error('Access denied')
    }

    // Validate question data if it's being updated
    if (data.questionData !== undefined) {
      this.validateQuestionData(existingQuestion.type, data.questionData)
    }

    // Filter out undefined values
    const updateData: any = {}
    if (data.text !== undefined) updateData.text = data.text
    if (data.explanation !== undefined) updateData.explanation = data.explanation
    if (data.hints !== undefined) updateData.hints = data.hints
    if (data.difficulty !== undefined) updateData.difficulty = data.difficulty
    if (data.points !== undefined) updateData.points = data.points
    if (data.passThreshold !== undefined) updateData.passThreshold = data.passThreshold
    if (data.questionData !== undefined) updateData.questionData = data.questionData
    if (data.status !== undefined) updateData.status = data.status

    const question = await prisma.question.update({
      where: { id: questionId },
      data: updateData,
      include: {
        milestone: {
          select: {
            id: true,
            title: true,
            timestamp: true
          }
        },
        createdBy: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    })

    return question
  }

  /**
   * Delete a question
   */
  static async deleteQuestion(questionId: string, user: User) {
    // Check if question exists and user has permission
    const existingQuestion = await prisma.question.findUnique({
      where: { id: questionId },
      include: {
        milestone: {
          include: {
            video: {
              include: {
                videoGroup: {
                  include: {
                    lesson: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!existingQuestion) {
      throw new Error('Question not found')
    }

    // Check permissions - only question creator, lesson creator, or admin can delete
    if (
      existingQuestion.createdById !== user.id &&
      existingQuestion.milestone.video.videoGroup.lesson.createdById !== user.id && 
      user.role !== 'ADMIN'
    ) {
      throw new Error('Access denied')
    }

    await prisma.question.delete({
      where: { id: questionId }
    })

    return true
  }

  /**
   * Approve a question (change status from DRAFT to APPROVED)
   */
  static async approveQuestion(questionId: string, user: User, reviewNotes?: string) {
    // Check if question exists and user has permission
    const existingQuestion = await prisma.question.findUnique({
      where: { id: questionId },
      include: {
        milestone: {
          include: {
            video: {
              include: {
                videoGroup: {
                  include: {
                    lesson: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!existingQuestion) {
      throw new Error('Question not found')
    }

    // Check permissions - only lesson creator or admin can approve
    if (
      existingQuestion.milestone.video.videoGroup.lesson.createdById !== user.id && 
      user.role !== 'ADMIN'
    ) {
      throw new Error('Access denied')
    }

    const question = await prisma.question.update({
      where: { id: questionId },
      data: {
        status: 'APPROVED',
        reviewedById: user.id,
        reviewedAt: new Date(),
        reviewNotes: reviewNotes || null
      },
      include: {
        milestone: {
          select: {
            id: true,
            title: true,
            timestamp: true
          }
        },
        createdBy: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    })

    return question
  }

  /**
   * Get question data templates for different question types
   */
  static getQuestionTemplates(): Record<QuestionType, any> {
    return {
      MULTIPLE_CHOICE: {
        description: 'Multiple choice question with one correct answer',
        example: {
          options: ['Option A', 'Option B', 'Option C', 'Option D'],
          correctAnswerIndex: 0
        }
      },
      TRUE_FALSE: {
        description: 'True or False question',
        example: {
          correctAnswer: true
        }
      },
      SHORT_ANSWER: {
        description: 'Short answer question with text input',
        example: {
          correctAnswers: ['correct answer', 'acceptable variant'],
          caseSensitive: false
        }
      },
      FILL_IN_BLANK: {
        description: 'Fill in the blank question with template',
        example: {
          template: 'The capital of {{blank}} is {{blank}}.',
          blanks: [
            {
              acceptedAnswers: ['France', 'france'],
              caseSensitive: false
            },
            {
              acceptedAnswers: ['Paris', 'paris'],
              caseSensitive: false
            }
          ]
        }
      },
      MATCHING: {
        description: 'Match items from two lists',
        example: {
          leftItems: ['Item 1', 'Item 2', 'Item 3'],
          rightItems: ['Match A', 'Match B', 'Match C'],
          correctMatches: [
            { left: 0, right: 0 },
            { left: 1, right: 1 },
            { left: 2, right: 2 }
          ]
        }
      },
      ORDERING: {
        description: 'Put items in correct order',
        example: {
          items: ['First item', 'Second item', 'Third item'],
          correctOrder: [0, 1, 2]
        }
      }
    }
  }

  /**
   * Validate question data based on question type
   */
  private static validateQuestionData(type: QuestionType, questionData: any) {
    if (!questionData) {
      throw new Error('Question data is required')
    }

    switch (type) {
      case 'MULTIPLE_CHOICE':
        if (!Array.isArray(questionData.options) || questionData.options.length < 2) {
          throw new Error('Multiple choice questions must have at least 2 options')
        }
        if (typeof questionData.correctAnswerIndex !== 'number' || 
            questionData.correctAnswerIndex < 0 || 
            questionData.correctAnswerIndex >= questionData.options.length) {
          throw new Error('Correct answer index is invalid')
        }
        break

      case 'TRUE_FALSE':
        if (typeof questionData.correctAnswer !== 'boolean') {
          throw new Error('True/False questions must have a boolean correct answer')
        }
        break

      case 'SHORT_ANSWER':
        if (!Array.isArray(questionData.correctAnswers) || questionData.correctAnswers.length === 0) {
          throw new Error('Short answer questions must have at least one correct answer')
        }
        break

      case 'FILL_IN_BLANK':
        if (!questionData.template || typeof questionData.template !== 'string') {
          throw new Error('Fill in blank questions must have a template')
        }
        if (!Array.isArray(questionData.blanks) || questionData.blanks.length === 0) {
          throw new Error('Fill in blank questions must have blank definitions')
        }
        break

      default:
        // For other question types, allow flexible validation
        break
    }
  }
}
</file>

<file path="src/services/VideoProcessingService.ts">
import path from 'path'
import fs from 'fs/promises'
import { exec } from 'child_process'
import { promisify } from 'util'
import { getThumbnailFilePath } from '../middleware/upload/videoUploadMiddleware'

const execAsync = promisify(exec)

interface VideoMetadata {
  duration: number | null
  width: number | null
  height: number | null
  bitrate: number | null
  fps: number | null
  codec: string | null
}

export class VideoProcessingService {
  /**
   * Generate thumbnail for video file using ffprobe and ffmpeg (if available)
   * Falls back to placeholder if ffmpeg is not available
   */
  static async generateThumbnail(videoPath: string, filename: string): Promise<string | null> {
    try {
      const thumbnailName = `${path.parse(filename).name}.jpg`
      const thumbnailPath = getThumbnailFilePath(thumbnailName)
      
      // Try to use ffmpeg to generate thumbnail
      try {
        // Generate thumbnail at 1 second mark
        await execAsync(`ffmpeg -i "${videoPath}" -ss 00:00:01 -vframes 1 -y "${thumbnailPath}"`)
        return thumbnailName
      } catch (ffmpegError) {
        console.warn('ffmpeg not available, skipping thumbnail generation:', ffmpegError)
        return null
      }
    } catch (error) {
      console.error('Error generating thumbnail:', error)
      return null
    }
  }

  /**
   * Extract video metadata using ffprobe (if available)
   */
  static async getVideoMetadata(videoPath: string): Promise<VideoMetadata> {
    const defaultMetadata: VideoMetadata = {
      duration: null,
      width: null,
      height: null,
      bitrate: null,
      fps: null,
      codec: null
    }

    try {
      // Try to use ffprobe to get video metadata
      const { stdout } = await execAsync(`ffprobe -v quiet -print_format json -show_format -show_streams "${videoPath}"`)
      const data = JSON.parse(stdout)
      
      // Find video stream
      const videoStream = data.streams?.find((stream: any) => stream.codec_type === 'video')
      
      if (videoStream) {
        return {
          duration: data.format?.duration ? parseFloat(data.format.duration) : null,
          width: videoStream.width || null,
          height: videoStream.height || null,
          bitrate: data.format?.bit_rate ? parseInt(data.format.bit_rate) : null,
          fps: videoStream.r_frame_rate ? this.parseFrameRate(videoStream.r_frame_rate) : null,
          codec: videoStream.codec_name || null
        }
      }
    } catch (error) {
      console.warn('ffprobe not available, using default metadata:', error)
    }

    // Fallback: try to get basic file stats
    try {
      await fs.stat(videoPath)
      return {
        ...defaultMetadata,
        duration: null // Cannot determine without ffprobe
      }
    } catch (error) {
      console.error('Error getting file stats:', error)
      return defaultMetadata
    }
  }

  /**
   * Parse frame rate string (e.g., "30/1" -> 30)
   */
  private static parseFrameRate(frameRate: string): number | null {
    try {
      const [numerator, denominator] = frameRate.split('/').map(Number)
      return denominator !== 0 ? numerator / denominator : null
    } catch {
      return null
    }
  }

  /**
   * Get file size in bytes
   */
  static async getFileSize(filePath: string): Promise<number> {
    try {
      const stats = await fs.stat(filePath)
      return stats.size
    } catch (error) {
      console.error('Error getting file size:', error)
      return 0
    }
  }

  /**
   * Validate video file exists and is accessible
   */
  static async validateVideoFile(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath, fs.constants.R_OK)
      return true
    } catch {
      return false
    }
  }

  /**
   * Get MIME type from file extension
   */
  static getMimeType(filename: string): string {
    const ext = path.extname(filename).toLowerCase()
    const mimeTypes: Record<string, string> = {
      '.mp4': 'video/mp4',
      '.avi': 'video/avi',
      '.mov': 'video/mov',
      '.wmv': 'video/wmv',
      '.flv': 'video/flv',
      '.webm': 'video/webm'
    }
    
    return mimeTypes[ext] || 'video/mp4'
  }
}
</file>

<file path=".gitignore">
# Interactive Learning Platform - Git Ignore File

# ===========================================
# Dependencies
# ===========================================
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# ===========================================
# Build Artifacts
# ===========================================
dist/
build/
out/
coverage/
.nyc_output/

# Frontend build artifacts
frontend/dist/
frontend/build/

# TypeScript compiled files
*.tsbuildinfo
.tsbuildinfo

# ===========================================
# Environment & Configuration Files
# ===========================================
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
.env.*.local

# Local development environment
.env.dev
.env.development

# Production secrets (should never be committed)
.env.production
config/production.json
config/production.js

# ===========================================
# Logs & Temporary Files
# ===========================================
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Runtime data
pids/
*.pid
*.seed
*.pid.lock

# ===========================================
# Cache & Temporary Directories
# ===========================================
.cache/
.parcel-cache/
.npm
.eslintcache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Vite cache
.vite/
.vite-cache/

# Next.js cache (if using Next.js in future)
.next/

# ===========================================
# Database & Storage
# ===========================================
# SQLite databases (if using for development)
*.sqlite
*.sqlite3
*.db

# Database dumps and backups
*.sql.gz
*.dump
database/backups/*.sql
database/backups/*.gz

# Prisma generated files (keep schema.prisma but ignore generated client)
# Note: We want to keep the generated client, so this is commented out
# prisma/generated/

# ===========================================
# Media & Uploads
# ===========================================
uploads/
temp-uploads/
public/uploads/
static/uploads/

# Video processing temporary files
video-processing/
temp-video/

# Screenshots from Puppeteer debugging
screenshots/
*.screenshot.png

# ===========================================
# Testing
# ===========================================
coverage/
.nyc_output/
junit.xml
test-results/

# Jest
.jest-cache/

# ===========================================
# IDE & Editor Files
# ===========================================
# VS Code
.vscode/
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# IntelliJ IDEA / WebStorm
.idea/
*.swp
*.swo

# Sublime Text
*.sublime-project
*.sublime-workspace

# Atom
.atom/

# ===========================================
# Operating System Files
# ===========================================
# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon?
._*
.Spotlight-V100
.Trashes

# Windows
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db
*.stackdump
[Dd]esktop.ini

# Linux
*~
.fuse_hidden*
.directory
.Trash-*

# ===========================================
# Docker & DevOps
# ===========================================
# Docker volumes
.docker-data/
docker-data/

# Kubernetes configs with secrets
k8s-secrets/
*.secret.yaml

# Terraform
*.tfstate
*.tfstate.*
.terraform/
.terraform.lock.hcl

# ===========================================
# Security & Credentials
# ===========================================
# API keys and secrets
.secrets/
secrets/
credentials/
*.pem
*.key
*.crt
*.p12
*.pfx

# Google Cloud credentials
gcp-service-account.json
service-account-key.json

# AWS credentials
.aws/

# ===========================================
# Monitoring & Analytics
# ===========================================
# Application logs
application.log
error.log
access.log
debug.log

# Performance monitoring
newrelic.log
.newrelic.yml

# ===========================================
# Development Tools
# ===========================================
# Storybook
storybook-static/

# ESLint cache
.eslintcache

# Prettier cache
.prettiercache

# TypeScript incremental compilation
*.tsbuildinfo

# ===========================================
# AI/ML Models & Data
# ===========================================
# Machine learning models (if storing locally)
models/
*.model
*.pkl
*.h5

# Large datasets
datasets/
training-data/

# ===========================================
# Temporary & Miscellaneous
# ===========================================
# Temporary directories
tmp/
temp/
.tmp/

# Lock files (keep only one type)
# If using npm, uncomment yarn.lock
# yarn.lock

# If using yarn, uncomment package-lock.json
# package-lock.json

# Archive files
*.tar.gz
*.zip
*.rar

# ===========================================
# Project Specific
# ===========================================
# Documentation builds
docs/build/
docs/.docusaurus/

# API documentation
api-docs/generated/

# Migration scripts output
migration-output/

# Backup files
*.backup
*.bak

# Local development certificates
localhost.pem
localhost-key.pem
</file>

<file path="docker-compose.dev.yml">
version: '3.8'

services:
  # PostgreSQL Database
  postgres:
    image: postgres:15-alpine
    container_name: interactive-learning-db
    restart: unless-stopped
    environment:
      POSTGRES_DB: interactive_learning
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres_dev_password
      POSTGRES_HOST_AUTH_METHOD: trust
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/migrations:/docker-entrypoint-initdb.d/migrations:ro
      - ./database/init-scripts:/docker-entrypoint-initdb.d/init:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d interactive_learning"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app-network

  # Redis for Session Management and Caching
  redis:
    image: redis:7-alpine
    container_name: interactive-learning-redis
    restart: unless-stopped
    command: redis-server --appendonly yes --requirepass redis_dev_password
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    networks:
      - app-network

  # Database Management Tool (Adminer)
  adminer:
    image: adminer:latest
    container_name: interactive-learning-adminer
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      ADMINER_DEFAULT_SERVER: postgres
      ADMINER_DESIGN: pepa-linha
    depends_on:
      - postgres
    networks:
      - app-network

  # Redis Management Tool (RedisInsight)
  redis-insight:
    image: redislabs/redisinsight:latest
    container_name: interactive-learning-redis-insight
    restart: unless-stopped
    ports:
      - "8001:8001"
    volumes:
      - redis_insight_data:/db
    depends_on:
      - redis
    networks:
      - app-network

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  redis_insight_data:
    driver: local

networks:
  app-network:
    driver: bridge
    name: interactive-learning-network
</file>

<file path="database/prisma/schema.prisma">
// Interactive Learning Platform Database Schema
// Prisma Schema for PostgreSQL
// Designed for multi-tenant video-based learning with AI-generated questions

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========================================
// CORE USER MANAGEMENT & AUTHENTICATION
// ========================================

enum UserRole {
  STUDENT
  TEACHER
  ADMIN
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING_VERIFICATION
}

model User {
  id        String     @id @default(cuid())
  email     String     @unique
  username  String?    @unique
  firstName String
  lastName  String
  avatar    String?    // URL to profile image
  role      UserRole   @default(STUDENT)
  status    UserStatus @default(PENDING_VERIFICATION)
  
  // Authentication
  passwordHash String
  emailVerified DateTime?
  lastLoginAt   DateTime?
  
  // Multi-tenancy support
  tenantId String?
  
  // Metadata
  metadata Json? // Flexible field for additional user data
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  createdLessons     Lesson[]
  createdQuestions   Question[]
  studentSessions    StudentSession[]
  studentProgress    StudentProgress[]
  questionAttempts   QuestionAttempt[]
  grades            Grade[]
  auditLogs         AuditLog[]
  userPreferences   UserPreference?
  analyticsEvents   AnalyticsEvent[]
  
  // Indexes for performance
  @@index([email])
  @@index([role])
  @@index([tenantId])
  @@index([status])
  @@index([createdAt])
  
  @@map("users")
}

model UserPreference {
  id     String @id @default(cuid())
  userId String @unique
  
  // Learning preferences
  autoplay       Boolean @default(true)
  playbackSpeed  Float   @default(1.0)
  subtitles      Boolean @default(false)
  theme          String  @default("light")
  language       String  @default("en")
  
  // Notification preferences
  emailNotifications    Boolean @default(true)
  progressNotifications Boolean @default(true)
  
  // Analytics preferences
  allowAnalytics Boolean @default(true)
  
  // Custom preferences (JSON)
  customSettings Json?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_preferences")
}

// ========================================
// CONTENT HIERARCHY & STRUCTURE
// ========================================

enum LessonStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model Lesson {
  id          String       @id @default(cuid())
  title       String
  description String?
  thumbnail   String?      // URL to lesson thumbnail
  status      LessonStatus @default(DRAFT)
  order       Int?         // Display order
  
  // Multi-tenancy
  tenantId String?
  
  // Creator information
  createdById String
  createdBy   User   @relation(fields: [createdById], references: [id])
  
  // Learning objectives and metadata
  objectives    String[] // Learning objectives array
  estimatedTime Int?     // Estimated completion time in minutes
  difficulty    String?  // beginner, intermediate, advanced
  tags          String[] // Searchable tags
  
  // Flexible metadata
  metadata Json?
  
  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  publishedAt DateTime?
  
  // Relations
  videoGroups     VideoGroup[]
  studentProgress StudentProgress[]
  
  // Indexes
  @@index([status])
  @@index([createdById])
  @@index([tenantId])
  @@index([publishedAt])
  @@index([order])
  
  @@map("lessons")
}

model VideoGroup {
  id          String  @id @default(cuid())
  lessonId    String
  title       String
  description String?
  order       Int     // Order within lesson
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  lesson Lesson  @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  videos Video[]
  
  // Indexes
  @@index([lessonId])
  @@index([order])
  
  @@map("video_groups")
}

enum VideoStatus {
  UPLOADING
  PROCESSING
  READY
  ERROR
  DRAFT
}

model Video {
  id           String      @id @default(cuid())
  videoGroupId String
  title        String
  description  String?
  order        Int         // Order within video group
  status       VideoStatus @default(UPLOADING)
  
  // Local file storage (Phase 1)
  filePath     String?  // Local file system path
  fileName     String?  // Original file name
  duration     Int?     // Duration in seconds
  size         BigInt?  // File size in bytes
  mimeType     String?
  
  // Video processing metadata
  processingStatus String? // Additional processing info
  thumbnailPath    String? // Local thumbnail file path
  
  // Video metadata (JSONB for flexibility)
  metadata Json? // Resolution, codecs, etc.
  
  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  uploadedAt  DateTime?
  processedAt DateTime?
  
  // Relations
  videoGroup       VideoGroup        @relation(fields: [videoGroupId], references: [id], onDelete: Cascade)
  milestones       Milestone[]
  studentSessions  StudentSession[]
  
  // Indexes for performance
  @@index([videoGroupId])
  @@index([status])
  @@index([order])
  @@index([filePath])
  
  @@map("videos")
}

model Milestone {
  id          String @id @default(cuid())
  videoId     String
  timestamp   Float  // Timestamp in seconds where video pauses
  title       String
  description String?
  type        MilestoneType @default(CHECKPOINT) // Type of milestone
  order       Int    // Order of milestones within video
  
  // Milestone configuration
  isRequired Boolean @default(true) // Can students skip this milestone?
  retryLimit Int     @default(3)    // Number of allowed attempts
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  video     Video      @relation(fields: [videoId], references: [id], onDelete: Cascade)
  questions Question[]
  progress  MilestoneProgress[]
  
  // Indexes for fast milestone lookups during video playback
  @@index([videoId])
  @@index([timestamp])
  @@index([order])
  
  @@map("milestones")
}

// ========================================
// QUESTION MANAGEMENT & WORKFLOW (Phase 1)
// ========================================

enum MilestoneType {
  PAUSE
  QUIZ
  CHECKPOINT
}

enum QuestionType {
  MULTIPLE_CHOICE
  TRUE_FALSE
  SHORT_ANSWER
  FILL_IN_BLANK
  MATCHING
  ORDERING
}

enum QuestionStatus {
  DRAFT
  APPROVED
  ARCHIVED
}

model Question {
  id          String         @id @default(cuid())
  milestoneId String
  type        QuestionType
  status      QuestionStatus @default(DRAFT)
  
  // Question content
  text        String         // Main question text
  explanation String?        // Explanation for the answer
  hints       String[]       // Optional hints array
  difficulty  String?        // easy, medium, hard
  
  // Question data (JSONB for flexibility across question types)
  questionData Json          // Stores options, correct answers, etc.
  
  // Scoring configuration
  points       Int    @default(1)
  passThreshold Float @default(0.7) // Minimum score to pass (0.0-1.0)
  
  // Teacher creation and review workflow
  createdById  String        // Teacher who created the question
  reviewedById String?
  reviewedAt   DateTime?
  reviewNotes  String?
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  milestone Milestone         @relation(fields: [milestoneId], references: [id], onDelete: Cascade)
  createdBy User             @relation(fields: [createdById], references: [id])
  attempts  QuestionAttempt[]
  options   QuestionOption[]
  
  // Indexes
  @@index([milestoneId])
  @@index([status])
  @@index([type])
  @@index([createdById])
  @@index([createdAt])
  
  @@map("questions")
}

// ========================================
// STUDENT PROGRESS & SESSION TRACKING
// ========================================

enum SessionStatus {
  ACTIVE
  PAUSED
  COMPLETED
  ABANDONED
}

model StudentSession {
  id        String        @id @default(cuid())
  studentId String
  videoId   String
  status    SessionStatus @default(ACTIVE)
  
  // Session tracking
  currentPosition    Float    @default(0) // Current video position in seconds
  lastMilestoneId    String?              // Last milestone reached
  completedMilestones String[]            // Array of completed milestone IDs
  
  // Device and browser info for cross-device sync
  deviceInfo   Json? // Device information
  browserInfo  Json? // Browser information
  ipAddress    String?
  userAgent    String?
  
  // Session metadata
  sessionData Json? // Flexible session data
  
  // Timestamps
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  startedAt  DateTime  @default(now())
  lastSeenAt DateTime  @default(now())
  completedAt DateTime?
  
  // Relations
  student User  @relation(fields: [studentId], references: [id], onDelete: Cascade)
  video   Video @relation(fields: [videoId], references: [id], onDelete: Cascade)
  milestoneProgress MilestoneProgress[]
  questionAttempts  QuestionAttempt[]
  
  // Indexes for cross-device session management
  @@index([studentId])
  @@index([videoId])
  @@index([status])
  @@index([lastSeenAt])
  @@unique([studentId, videoId]) // One active session per student per video
  
  @@map("student_sessions")
}

model MilestoneProgress {
  id          String   @id @default(cuid())
  sessionId   String
  milestoneId String
  reachedAt   DateTime @default(now())
  
  // Relations
  session   StudentSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  milestone Milestone      @relation(fields: [milestoneId], references: [id], onDelete: Cascade)
  
  // Ensure unique milestone per session
  @@unique([sessionId, milestoneId])
  @@index([sessionId])
  @@index([milestoneId])
  
  @@map("milestone_progress")
}

model StudentProgress {
  id        String @id @default(cuid())
  studentId String
  lessonId  String
  
  // Progress tracking
  isCompleted       Boolean   @default(false)
  completionPercent Float     @default(0) // 0.0 to 100.0
  totalTimeSpent    Int       @default(0) // Total time in seconds
  
  // Milestone tracking
  totalMilestones     Int @default(0)
  completedMilestones Int @default(0)
  
  // Performance metrics
  averageScore    Float   @default(0)
  totalAttempts   Int     @default(0)
  successfulAttempts Int  @default(0)
  
  // Progress metadata (JSONB)
  progressData Json?
  
  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  
  // Relations
  student User   @relation(fields: [studentId], references: [id], onDelete: Cascade)
  lesson  Lesson @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  grades  Grade[]
  
  // Indexes for student progress queries
  @@index([studentId])
  @@index([lessonId])
  @@index([isCompleted])
  @@index([completionPercent])
  @@unique([studentId, lessonId]) // One progress record per student per lesson
  
  @@map("student_progress")
}

// ========================================
// GRADING & ASSESSMENT SYSTEM
// ========================================

enum AttemptStatus {
  IN_PROGRESS
  SUBMITTED
  CORRECT
  INCORRECT
  PARTIAL
  TIMEOUT
}

model QuestionAttempt {
  id         String        @id @default(cuid())
  studentId  String
  questionId String
  sessionId  String?       // Link to video session
  status     AttemptStatus @default(IN_PROGRESS)
  
  // Attempt data
  attemptNumber Int    // Which attempt (1, 2, 3, etc.)
  studentAnswer Json   // Student's answer (flexible format)
  isCorrect     Boolean?
  score         Float  @default(0) // Partial credit scoring
  timeSpent     Int    @default(0) // Time in seconds
  
  // Feedback and hints used
  hintsUsed    String[] // Which hints were revealed
  feedback     String?  // Automated feedback
  
  // Attempt metadata
  attemptData Json? // Additional attempt data
  
  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  submittedAt DateTime?
  
  // Relations
  student  User     @relation(fields: [studentId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  session  StudentSession? @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  
  // Indexes for grading queries
  @@index([studentId])
  @@index([questionId])
  @@index([status])
  @@index([isCorrect])
  @@index([submittedAt])
  
  @@map("question_attempts")
}

enum GradeStatus {
  IN_PROGRESS
  COMPLETED
  FAILED
  RETRY_ALLOWED
}

model Grade {
  id                String      @id @default(cuid())
  studentId         String
  studentProgressId String
  
  // Grade calculation
  totalPoints       Int         @default(0)
  earnedPoints      Int         @default(0)
  percentageScore   Float       @default(0) // 0.0 to 100.0
  letterGrade       String?     // A, B, C, D, F
  status            GradeStatus @default(IN_PROGRESS)
  
  // Attempt tracking
  totalAttempts     Int @default(0)
  remainingAttempts Int @default(0)
  
  // Grade breakdown (JSONB for detailed analysis)
  gradeBreakdown Json? // Per-milestone, per-question scores
  
  // Timestamps
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  finalizedAt DateTime?
  
  // Relations
  student         User            @relation(fields: [studentId], references: [id], onDelete: Cascade)
  studentProgress StudentProgress @relation(fields: [studentProgressId], references: [id], onDelete: Cascade)
  
  // Indexes
  @@index([studentId])
  @@index([studentProgressId])
  @@index([status])
  @@index([percentageScore])
  @@index([finalizedAt])
  
  @@map("grades")
}

// ========================================
// ANALYTICS & REPORTING
// ========================================

model AnalyticsEvent {
  id        String   @id @default(cuid())
  userId    String?
  sessionId String?
  
  // Event details
  eventType    String   // video_start, video_pause, question_attempt, etc.
  eventData    Json     // Flexible event data
  context      Json?    // Additional context (device, location, etc.)
  
  // Performance metrics
  timestamp    DateTime @default(now())
  processingTime Int?   // Processing time in milliseconds
  
  // Relations (optional - for easier querying)
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  // Indexes for analytics queries
  @@index([userId])
  @@index([eventType])
  @@index([timestamp])
  @@index([sessionId])
  
  @@map("analytics_events")
}

// ========================================
// SYSTEM CONFIGURATION & AUDIT
// ========================================

model SystemConfig {
  id    String @id @default(cuid())
  key   String @unique
  value Json
  
  // Configuration metadata
  description String?
  category    String?
  isPublic    Boolean @default(false) // Can be accessed by frontend
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([key])
  @@index([category])
  
  @@map("system_configs")
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  VIEW
  DOWNLOAD
  UPLOAD
}

model AuditLog {
  id       String      @id @default(cuid())
  userId   String?
  action   AuditAction
  resource String      // Table/resource affected
  resourceId String?   // ID of affected resource
  
  // Audit details
  changes     Json?     // What changed (before/after)
  metadata    Json?     // Additional context
  ipAddress   String?
  userAgent   String?
  
  // Timestamps
  createdAt DateTime @default(now())
  
  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  // Indexes for audit queries
  @@index([userId])
  @@index([action])
  @@index([resource])
  @@index([resourceId])
  @@index([createdAt])
  
  @@map("audit_logs")
}

// ========================================
// QUESTION OPTIONS & AI INTEGRATION
// ========================================

model QuestionOption {
  id         String  @id @default(cuid())
  questionId String
  text       String
  isCorrect  Boolean @default(false)
  order      Int     @default(1)
  
  // Metadata
  explanation String?
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  
  // Indexes
  @@index([questionId])
  @@index([order])
  
  @@map("question_options")
}

// AI API MANAGEMENT
// ========================================

enum AIProvider {
  OPENAI
  CLAUDE
  GOOGLE_PALM
  CUSTOM
}

model AIConfiguration {
  id       String     @id @default(cuid())
  provider AIProvider
  name     String     // Configuration name
  
  // API configuration
  apiKey      String?   // Encrypted API key
  endpoint    String?   // Custom endpoint URL
  model       String    // Model identifier
  parameters  Json?     // Model parameters (temperature, max_tokens, etc.)
  
  // Usage configuration
  isActive    Boolean   @default(true)
  rateLimit   Int?      // Requests per minute
  maxTokens   Int?      // Max tokens per request
  
  // Cost tracking
  costPerToken Float?   // Cost per token
  monthlyBudget Float?  // Monthly budget limit
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([provider])
  @@index([isActive])
  
  @@map("ai_configurations")
}

model AIUsageLog {
  id              String   @id @default(cuid())
  configurationId String
  
  // Request details
  requestType     String   // question_generation, content_analysis, etc.
  prompt          String?  // Original prompt (if not sensitive)
  response        String?  // AI response (if not sensitive)
  
  // Usage metrics
  tokensUsed      Int
  cost            Float?
  responseTime    Int      // Response time in milliseconds
  success         Boolean
  errorMessage    String?
  
  // Context
  userId          String?
  resourceId      String?  // Related resource (question, milestone, etc.)
  metadata        Json?
  
  // Timestamps
  createdAt DateTime @default(now())
  
  @@index([configurationId])
  @@index([requestType])
  @@index([createdAt])
  @@index([success])
  
  @@map("ai_usage_logs")
}
</file>

<file path="frontend/src/components/teacher/MilestoneEditor.tsx">
import React, { useState, useEffect, useRef } from 'react'
import { milestoneService, videoService } from '../../services/video'
import type { Video, Milestone } from '../../services/video'

interface MilestoneEditorProps {
  video: Video
  milestone?: Milestone | null
  onMilestoneAdded: (milestone: Milestone) => void
  onClose: () => void
}

export function MilestoneEditor({ video, milestone, onMilestoneAdded, onClose }: MilestoneEditorProps) {
  const videoRef = useRef<HTMLVideoElement>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [isVideoLoaded, setIsVideoLoaded] = useState(false)
  const [videoCurrentTime, setVideoCurrentTime] = useState(0)
  const [videoDuration, setVideoDuration] = useState(video.duration || 0)
  
  const [formData, setFormData] = useState({
    timestamp: milestone?.timestamp || 0,
    title: milestone?.title || '',
    description: milestone?.description || '',
    type: milestone?.type || 'QUIZ' as 'PAUSE' | 'QUIZ' | 'CHECKPOINT'
  })

  const isEditing = !!milestone

  useEffect(() => {
    if (milestone) {
      setFormData({
        timestamp: milestone.timestamp,
        title: milestone.title,
        description: milestone.description || '',
        type: milestone.type
      })
    }
  }, [milestone])

  useEffect(() => {
    const video = videoRef.current
    if (!video) return

    const handleLoadedMetadata = () => {
      setVideoDuration(video.duration)
      setIsVideoLoaded(true)
    }

    const handleTimeUpdate = () => {
      setVideoCurrentTime(video.currentTime)
    }

    video.addEventListener('loadedmetadata', handleLoadedMetadata)
    video.addEventListener('timeupdate', handleTimeUpdate)

    return () => {
      video.removeEventListener('loadedmetadata', handleLoadedMetadata)
      video.removeEventListener('timeupdate', handleTimeUpdate)
    }
  }, [])

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target
    setFormData(prev => ({
      ...prev,
      [name]: name === 'timestamp' ? parseInt(value) || 0 : value
    }))
  }

  const handleTimelineClick = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!videoDuration) return
    
    const rect = e.currentTarget.getBoundingClientRect()
    const clickX = e.clientX - rect.left
    const percentage = clickX / rect.width
    const timestamp = Math.floor(percentage * videoDuration)
    
    setFormData(prev => ({ ...prev, timestamp }))
    
    // Seek video to clicked position
    if (videoRef.current) {
      videoRef.current.currentTime = timestamp
    }
  }

  const handleUseCurrentTime = () => {
    if (videoRef.current) {
      const currentTime = Math.floor(videoRef.current.currentTime)
      setFormData(prev => ({ ...prev, timestamp: currentTime }))
    }
  }

  const handleSeekToMilestone = () => {
    if (videoRef.current) {
      videoRef.current.currentTime = formData.timestamp
    }
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!formData.title.trim()) {
      setError('Title is required')
      return
    }

    if (formData.timestamp < 0 || (videoDuration && formData.timestamp > videoDuration)) {
      setError('Timestamp must be within the video duration')
      return
    }

    setLoading(true)
    setError(null)

    try {
      let response
      
      if (isEditing && milestone) {
        response = await milestoneService.updateMilestone(milestone.id, {
          timestamp: formData.timestamp,
          title: formData.title,
          description: formData.description || undefined,
          type: formData.type
        })
      } else {
        response = await milestoneService.createMilestone({
          videoId: video.id,
          timestamp: formData.timestamp,
          title: formData.title,
          description: formData.description || undefined,
          type: formData.type
        })
      }

      onMilestoneAdded(response)
    } catch (err) {
      console.error(`Error ${isEditing ? 'updating' : 'creating'} milestone:`, err)
      const message = err instanceof Error ? err.message : `Failed to ${isEditing ? 'update' : 'create'} milestone`
      setError(message)
    } finally {
      setLoading(false)
    }
  }

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60)
    const secs = seconds % 60
    return `${mins}:${secs.toString().padStart(2, '0')}`
  }

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose()
    }
  }

  return (
    <div 
      className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
      onClick={handleBackdropClick}
    >
      <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto">
        <div className="p-6">
          {/* Header */}
          <div className="flex items-center justify-between mb-6">
            <div>
              <h2 className="text-xl font-bold text-gray-900">
                {isEditing ? 'Edit Milestone' : 'Add Milestone'}
              </h2>
              <p className="text-sm text-gray-600 mt-1">
                Video: {video.title} 
                {video.duration && ` (${formatTime(video.duration)})`}
              </p>
            </div>
            <button
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 transition-colors"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>

          {error && (
            <div className="bg-red-50 border border-red-200 rounded-md p-4 mb-6">
              <div className="flex">
                <svg className="w-5 h-5 text-red-400 mt-0.5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                </svg>
                <p className="text-red-700">{error}</p>
              </div>
            </div>
          )}

          {/* Video Preview */}
          <div className="mb-6">
            <div className="bg-black rounded-lg overflow-hidden">
              <video
                ref={videoRef}
                src={videoService.getStreamingUrl(video.id)}
                className="w-full h-48 object-contain"
                controls
                playsInline
              />
            </div>
            
            {/* Timeline */}
            {isVideoLoaded && (
              <div className="mt-4">
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Click on timeline to set milestone position
                </label>
                <div 
                  className="relative h-8 bg-gray-200 rounded-full cursor-pointer overflow-hidden"
                  onClick={handleTimelineClick}
                >
                  {/* Progress bar */}
                  <div 
                    className="absolute top-0 left-0 h-full bg-blue-200 rounded-full"
                    style={{ width: `${(videoCurrentTime / videoDuration) * 100}%` }}
                  />
                  
                  {/* Existing milestones */}
                  {video.milestones?.map((m) => {
                    if (m.id === milestone?.id) return null
                    return (
                      <div
                        key={m.id}
                        className="absolute top-0 w-1 h-full bg-red-500 opacity-75"
                        style={{ left: `${(m.timestamp / videoDuration) * 100}%` }}
                        title={`${m.title} (${formatTime(m.timestamp)})`}
                      />
                    )
                  })}
                  
                  {/* Current milestone marker */}
                  <div
                    className="absolute top-0 w-3 h-full bg-green-500 rounded-full transform -translate-x-1/2 border-2 border-white shadow-lg"
                    style={{ left: `${(formData.timestamp / videoDuration) * 100}%` }}
                    title={`Milestone: ${formatTime(formData.timestamp)}`}
                  />
                  
                  {/* Timeline markers */}
                  <div className="absolute bottom-0 left-0 right-0 flex justify-between text-xs text-gray-500 px-1">
                    <span>0:00</span>
                    <span>{formatTime(videoDuration)}</span>
                  </div>
                </div>
                
                <div className="flex items-center justify-between mt-2 text-sm text-gray-600">
                  <span>Current: {formatTime(videoCurrentTime)}</span>
                  <span>Milestone: {formatTime(formData.timestamp)}</span>
                </div>
              </div>
            )}
          </div>

          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Milestone Type */}
            <div>
              <label htmlFor="type" className="block text-sm font-medium text-gray-700 mb-2">
                Milestone Type *
              </label>
              <select
                id="type"
                name="type"
                value={formData.type}
                onChange={handleInputChange}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                required
              >
                <option value="QUIZ">Quiz - Pause video for questions</option>
                <option value="CHECKPOINT">Checkpoint - Mark progress point</option>
                <option value="PAUSE">Pause - Simple pause point</option>
              </select>
              <div className="text-xs text-gray-500 mt-1">
                {formData.type === 'QUIZ' && 'Video will pause and show questions to students'}
                {formData.type === 'CHECKPOINT' && 'Mark important learning milestones'}
                {formData.type === 'PAUSE' && 'Pause point for reflection or discussion'}
              </div>
            </div>

            {/* Timestamp */}
            <div>
              <label htmlFor="timestamp" className="block text-sm font-medium text-gray-700 mb-2">
                Timestamp (seconds) *
              </label>
              <div className="flex items-center space-x-3">
                <input
                  type="number"
                  id="timestamp"
                  name="timestamp"
                  value={formData.timestamp}
                  onChange={handleInputChange}
                  min="0"
                  max={videoDuration || undefined}
                  step="1"
                  className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  required
                />
                <div className="text-sm text-gray-500">
                  = {formatTime(formData.timestamp)}
                </div>
              </div>
              
              <div className="flex items-center space-x-2 mt-2">
                <button
                  type="button"
                  onClick={handleUseCurrentTime}
                  className="text-sm px-3 py-1 bg-blue-100 text-blue-700 rounded-md hover:bg-blue-200 transition-colors"
                >
                  Use Current Time ({formatTime(videoCurrentTime)})
                </button>
                <button
                  type="button"
                  onClick={handleSeekToMilestone}
                  className="text-sm px-3 py-1 bg-green-100 text-green-700 rounded-md hover:bg-green-200 transition-colors"
                >
                  Seek to Milestone
                </button>
              </div>
              
              <p className="text-xs text-gray-500 mt-1">
                When this milestone should appear in the video
                {videoDuration && ` (max: ${formatTime(videoDuration)})`}
              </p>
            </div>

            {/* Title */}
            <div>
              <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-2">
                Title *
              </label>
              <input
                type="text"
                id="title"
                name="title"
                value={formData.title}
                onChange={handleInputChange}
                placeholder="Enter milestone title"
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                required
              />
            </div>

            {/* Description */}
            <div>
              <label htmlFor="description" className="block text-sm font-medium text-gray-700 mb-2">
                Description
              </label>
              <textarea
                id="description"
                name="description"
                value={formData.description}
                onChange={handleInputChange}
                placeholder="Optional description or instructions for students"
                rows={3}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              />
            </div>

            {/* Actions */}
            <div className="flex justify-end space-x-3 pt-4 border-t">
              <button
                type="button"
                onClick={onClose}
                className="btn-secondary"
              >
                Cancel
              </button>
              <button
                type="submit"
                disabled={loading}
                className={`btn-primary ${loading ? 'opacity-50 cursor-not-allowed' : ''}`}
              >
                {loading 
                  ? (isEditing ? 'Updating...' : 'Creating...')
                  : (isEditing ? 'Update Milestone' : 'Create Milestone')
                }
              </button>
            </div>
          </form>

          {/* Info */}
          <div className="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-md">
            <h3 className="text-sm font-medium text-blue-800 mb-2">Next Steps</h3>
            <p className="text-sm text-blue-700">
              {formData.type === 'QUIZ' 
                ? 'After creating this milestone, you can add questions that students will answer when they reach this point in the video.'
                : formData.type === 'CHECKPOINT'
                ? 'Checkpoints help track student progress and can be used for analytics and completion tracking.'
                : 'Pause points allow for reflection time or can be used to sync with classroom discussions.'
              }
            </p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/teacher/VideoUploadForm.tsx">
import React, { useState, useRef, useCallback } from 'react'
import { videoService } from '../../services/video'
import type { Video } from '../../services/video'

interface VideoUploadFormProps {
  groupId: string
  onVideoUploaded: (video: Video) => void
  onClose: () => void
}

interface UploadState {
  file: File | null
  title: string
  description: string
  uploading: boolean
  progress: number
  error: string | null
  processing: boolean
}

export function VideoUploadForm({ groupId, onVideoUploaded, onClose }: VideoUploadFormProps) {
  const fileInputRef = useRef<HTMLInputElement>(null)
  const [dragActive, setDragActive] = useState(false)
  const [uploadState, setUploadState] = useState<UploadState>({
    file: null,
    title: '',
    description: '',
    uploading: false,
    progress: 0,
    error: null,
    processing: false
  })

  const handleFile = (file: File) => {
    // Validate file type
    if (!file.type.startsWith('video/')) {
      setUploadState(prev => ({ ...prev, error: 'Please select a valid video file' }))
      return
    }

    // Validate file size (100MB limit)
    const maxSize = 100 * 1024 * 1024 // 100MB
    if (file.size > maxSize) {
      setUploadState(prev => ({ ...prev, error: 'File size must be less than 100MB' }))
      return
    }

    setUploadState(prev => ({
      ...prev,
      file,
      title: prev.title || file.name.replace(/\.[^/.]+$/, ''), // Use filename as default title
      error: null
    }))
  }

  const handleDrag = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true)
    } else if (e.type === 'dragleave') {
      setDragActive(false)
    }
  }, [])

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()
    setDragActive(false)

    const files = e.dataTransfer.files
    if (files && files.length > 0) {
      handleFile(files[0])
    }
  }, [])

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files
    if (files && files.length > 0) {
      handleFile(files[0])
    }
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!uploadState.file || !uploadState.title.trim()) {
      setUploadState(prev => ({ ...prev, error: 'Please select a file and enter a title' }))
      return
    }

    setUploadState(prev => ({ ...prev, uploading: true, progress: 0, error: null }))

    try {
      const video = await videoService.uploadVideoFile(
        groupId,
        uploadState.file,
        {
          title: uploadState.title.trim(),
          description: uploadState.description.trim() || undefined
        },
        (progress) => {
          setUploadState(prev => ({ ...prev, progress }))
        }
      )

      setUploadState(prev => ({ ...prev, processing: true, progress: 100 }))
      onVideoUploaded(video)
    } catch (error) {
      console.error('Upload failed:', error)
      const message = error instanceof Error ? error.message : 'Failed to upload video'
      setUploadState(prev => ({
        ...prev,
        uploading: false,
        processing: false,
        progress: 0,
        error: message
      }))
    }
  }

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return '0 Bytes'
    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
  }

  // const formatDuration = (seconds: number) => {
  //   const mins = Math.floor(seconds / 60)
  //   const secs = Math.floor(seconds % 60)
  //   return `${mins}:${secs.toString().padStart(2, '0')}`
  // }

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget && !uploadState.uploading) {
      onClose()
    }
  }

  return (
    <div 
      className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
      onClick={handleBackdropClick}
    >
      <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto">
        <div className="p-6">
          {/* Header */}
          <div className="flex items-center justify-between mb-6">
            <h2 className="text-xl font-bold text-gray-900">Upload Video</h2>
            {!uploadState.uploading && (
              <button
                onClick={onClose}
                className="text-gray-400 hover:text-gray-600 transition-colors"
              >
                <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            )}
          </div>

          {uploadState.error && (
            <div className="bg-red-50 border border-red-200 rounded-md p-4 mb-6">
              <div className="flex">
                <svg className="w-5 h-5 text-red-400 mt-0.5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                </svg>
                <p className="text-red-700">{uploadState.error}</p>
              </div>
            </div>
          )}

          <form onSubmit={handleSubmit} className="space-y-6">
            {/* File Upload Area */}
            {!uploadState.file ? (
              <div
                className={`relative border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
                  dragActive
                    ? 'border-blue-400 bg-blue-50'
                    : 'border-gray-300 hover:border-gray-400'
                }`}
                onDragEnter={handleDrag}
                onDragLeave={handleDrag}
                onDragOver={handleDrag}
                onDrop={handleDrop}
              >
                <input
                  ref={fileInputRef}
                  type="file"
                  accept="video/*"
                  onChange={handleFileInput}
                  className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                />
                
                <div className="space-y-4">
                  <div className="flex justify-center">
                    <svg className="w-12 h-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M7 4a2 2 0 012-2h6a2 2 0 012 2v16l-5-5-5 5V4z" />
                    </svg>
                  </div>
                  <div>
                    <p className="text-lg font-medium text-gray-900">
                      Drop your video file here
                    </p>
                    <p className="text-sm text-gray-500 mt-1">
                      or click to browse files
                    </p>
                  </div>
                  <div className="text-xs text-gray-400 space-y-1">
                    <p>Supported formats: MP4, WebM, MOV, AVI</p>
                    <p>Maximum file size: 100MB</p>
                  </div>
                </div>
              </div>
            ) : (
              /* File Preview */
              <div className="border border-gray-200 rounded-lg p-4 bg-gray-50">
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-3">
                    <div className="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center">
                      <svg className="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                      </svg>
                    </div>
                    <div>
                      <p className="font-medium text-gray-900">{uploadState.file.name}</p>
                      <p className="text-sm text-gray-500">{formatFileSize(uploadState.file.size)}</p>
                    </div>
                  </div>
                  {!uploadState.uploading && (
                    <button
                      type="button"
                      onClick={() => setUploadState(prev => ({ ...prev, file: null }))}
                      className="text-gray-400 hover:text-red-500 transition-colors"
                    >
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  )}
                </div>
              </div>
            )}

            {/* Upload Progress */}
            {uploadState.uploading && (
              <div className="space-y-2">
                <div className="flex justify-between text-sm">
                  <span className="text-gray-600">
                    {uploadState.processing ? 'Processing video...' : `Uploading... ${uploadState.progress}%`}
                  </span>
                  <span className="text-gray-500">
                    {uploadState.processing ? 'Please wait' : `${uploadState.progress}%`}
                  </span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div 
                    className={`h-2 rounded-full transition-all duration-300 ${
                      uploadState.processing ? 'bg-yellow-500' : 'bg-blue-500'
                    }`}
                    style={{ width: `${uploadState.progress}%` }}
                  />
                </div>
              </div>
            )}

            {/* Video Metadata */}
            <div className="space-y-4">
              <div>
                <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-2">
                  Video Title *
                </label>
                <input
                  type="text"
                  id="title"
                  value={uploadState.title}
                  onChange={(e) => setUploadState(prev => ({ ...prev, title: e.target.value }))}
                  placeholder="Enter video title"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  required
                  disabled={uploadState.uploading}
                />
              </div>

              <div>
                <label htmlFor="description" className="block text-sm font-medium text-gray-700 mb-2">
                  Description
                </label>
                <textarea
                  id="description"
                  value={uploadState.description}
                  onChange={(e) => setUploadState(prev => ({ ...prev, description: e.target.value }))}
                  placeholder="Describe what this video covers"
                  rows={3}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  disabled={uploadState.uploading}
                />
              </div>
            </div>

            {/* Actions */}
            <div className="flex justify-end space-x-3 pt-4 border-t">
              <button
                type="button"
                onClick={onClose}
                disabled={uploadState.uploading}
                className={`btn-secondary ${uploadState.uploading ? 'opacity-50 cursor-not-allowed' : ''}`}
              >
                {uploadState.uploading ? 'Uploading...' : 'Cancel'}
              </button>
              <button
                type="submit"
                disabled={!uploadState.file || !uploadState.title.trim() || uploadState.uploading}
                className={`btn-primary ${
                  (!uploadState.file || !uploadState.title.trim() || uploadState.uploading)
                    ? 'opacity-50 cursor-not-allowed'
                    : ''
                }`}
              >
                {uploadState.uploading 
                  ? (uploadState.processing ? 'Processing...' : `Uploading ${uploadState.progress}%`)
                  : 'Upload Video'
                }
              </button>
            </div>
          </form>

          {/* Upload Tips */}
          {!uploadState.uploading && (
            <div className="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-md">
              <h3 className="text-sm font-medium text-blue-800 mb-2">Upload Tips</h3>
              <ul className="text-sm text-blue-700 space-y-1">
                <li>• Use MP4 format for best compatibility</li>
                <li>• Keep file size under 100MB for faster uploads</li>
                <li>• Choose descriptive titles for easy organization</li>
                <li>• After upload, you can add interactive milestones</li>
              </ul>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/pages/teacher/CreateLessonPage.tsx">
import React, { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { lessonService } from '../../services/lesson'
import { useAuth } from '../../hooks/useAuth'

export default function CreateLessonPage() {
  const navigate = useNavigate()
  const { user } = useAuth()
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    tags: [] as string[],
    difficulty: 'beginner' as 'beginner' | 'intermediate' | 'advanced',
    estimatedTime: undefined as number | undefined
  })
  const [tagInput, setTagInput] = useState('')

  // Check if user is teacher or admin
  if (!user || (user.role !== 'TEACHER' && user.role !== 'ADMIN')) {
    return (
      <div className="p-6">
        <div className="card text-center py-8">
          <h3 className="text-lg font-semibold text-gray-900 mb-2">Access Denied</h3>
          <p className="text-gray-600 mb-4">Only teachers and administrators can create lessons.</p>
          <button
            onClick={() => navigate('/dashboard')}
            className="btn-primary"
          >
            Back to Dashboard
          </button>
        </div>
      </div>
    )
  }

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value, type } = e.target
    if (type === 'checkbox') {
      const checked = (e.target as HTMLInputElement).checked
      setFormData(prev => ({
        ...prev,
        [name]: checked
      }))
    } else if (name === 'estimatedTime') {
      const numValue = value ? parseInt(value) : undefined
      setFormData(prev => ({
        ...prev,
        [name]: numValue
      }))
    } else {
      setFormData(prev => ({
        ...prev,
        [name]: value
      }))
    }
  }

  const handleAddTag = () => {
    const tag = tagInput.trim()
    if (tag && !formData.tags.includes(tag)) {
      setFormData(prev => ({
        ...prev,
        tags: [...prev.tags, tag]
      }))
      setTagInput('')
    }
  }

  const handleRemoveTag = (tagToRemove: string) => {
    setFormData(prev => ({
      ...prev,
      tags: prev.tags.filter(tag => tag !== tagToRemove)
    }))
  }

  const handleTagKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault()
      handleAddTag()
    }
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!formData.title.trim()) {
      setError('Title is required')
      return
    }

    setLoading(true)
    setError(null)

    try {
      const lesson = await lessonService.createLesson({
        title: formData.title,
        description: formData.description || undefined,
        tags: formData.tags,
        difficulty: formData.difficulty,
        estimatedTime: formData.estimatedTime
      })

      // Navigate to lesson management page
      navigate(`/teacher/lessons/${lesson.id}`)
    } catch (err: any) {
      console.error('Error creating lesson:', err)
      setError(err.message || 'Failed to create lesson')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="p-6">
      <div className="max-w-2xl mx-auto">
        {/* Header */}
        <div className="mb-6">
          <button
            onClick={() => navigate('/dashboard')}
            className="flex items-center text-blue-600 hover:text-blue-700 transition-colors mb-4"
          >
            <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
            </svg>
            Back to Dashboard
          </button>
          <h1 className="text-2xl font-bold text-gray-900">Create New Lesson</h1>
          <p className="text-gray-600 mt-2">
            Create a new interactive video lesson with milestone questions and activities.
          </p>
        </div>

        {error && (
          <div className="bg-red-50 border border-red-200 rounded-md p-4 mb-6">
            <div className="flex">
              <svg className="w-5 h-5 text-red-400 mt-0.5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
              </svg>
              <p className="text-red-700">{error}</p>
            </div>
          </div>
        )}

        {/* Form */}
        <form onSubmit={handleSubmit} className="card">
          <div className="space-y-6">
            {/* Title */}
            <div>
              <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-2">
                Lesson Title *
              </label>
              <input
                type="text"
                id="title"
                name="title"
                value={formData.title}
                onChange={handleInputChange}
                placeholder="Enter lesson title"
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                required
              />
            </div>

            {/* Description */}
            <div>
              <label htmlFor="description" className="block text-sm font-medium text-gray-700 mb-2">
                Description
              </label>
              <textarea
                id="description"
                name="description"
                value={formData.description}
                onChange={handleInputChange}
                placeholder="Describe what students will learn in this lesson"
                rows={4}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              />
            </div>

            {/* Difficulty */}
            <div>
              <label htmlFor="difficulty" className="block text-sm font-medium text-gray-700 mb-2">
                Difficulty Level
              </label>
              <select
                id="difficulty"
                name="difficulty"
                value={formData.difficulty}
                onChange={handleInputChange}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              >
                <option value="beginner">Beginner</option>
                <option value="intermediate">Intermediate</option>
                <option value="advanced">Advanced</option>
              </select>
            </div>

            {/* Estimated Time */}
            <div>
              <label htmlFor="estimatedTime" className="block text-sm font-medium text-gray-700 mb-2">
                Estimated Time (minutes)
              </label>
              <input
                type="number"
                id="estimatedTime"
                name="estimatedTime"
                value={formData.estimatedTime || ''}
                onChange={handleInputChange}
                placeholder="e.g. 30"
                min="1"
                max="300"
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              />
            </div>

            {/* Tags */}
            <div>
              <label htmlFor="tags" className="block text-sm font-medium text-gray-700 mb-2">
                Tags
              </label>
              <div className="flex items-center space-x-2 mb-3">
                <input
                  type="text"
                  value={tagInput}
                  onChange={(e) => setTagInput(e.target.value)}
                  onKeyPress={handleTagKeyPress}
                  placeholder="Add a tag"
                  className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
                <button
                  type="button"
                  onClick={handleAddTag}
                  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                >
                  Add
                </button>
              </div>
              {formData.tags.length > 0 && (
                <div className="flex flex-wrap gap-2">
                  {formData.tags.map((tag) => (
                    <span
                      key={tag}
                      className="inline-flex items-center px-3 py-1 bg-blue-100 text-blue-700 rounded-full text-sm"
                    >
                      {tag}
                      <button
                        type="button"
                        onClick={() => handleRemoveTag(tag)}
                        className="ml-2 text-blue-500 hover:text-blue-700"
                      >
                        ×
                      </button>
                    </span>
                  ))}
                </div>
              )}
            </div>

            {/* Info */}
            <div className="bg-blue-50 border border-blue-200 rounded-md p-4">
              <div className="flex items-start space-x-3">
                <svg className="w-5 h-5 text-blue-600 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
                </svg>
                <div>
                  <h3 className="text-sm font-medium text-blue-800 mb-1">Draft Mode</h3>
                  <p className="text-sm text-blue-700">
                    Your lesson will be saved as a draft. You can add videos, create milestones, and publish it when ready.
                  </p>
                </div>
              </div>
            </div>

            {/* Submit */}
            <div className="flex justify-end space-x-3 pt-4 border-t">
              <button
                type="button"
                onClick={() => navigate('/dashboard')}
                className="btn-secondary"
              >
                Cancel
              </button>
              <button
                type="submit"
                disabled={loading}
                className={`btn-primary ${loading ? 'opacity-50 cursor-not-allowed' : ''}`}
              >
                {loading ? 'Creating...' : 'Create Lesson'}
              </button>
            </div>
          </div>
        </form>

        {/* Next Steps Info */}
        <div className="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-md">
          <div className="flex">
            <svg className="w-5 h-5 text-blue-600 mt-0.5 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
            </svg>
            <div>
              <h3 className="text-sm font-medium text-blue-800">Next Steps</h3>
              <p className="text-sm text-blue-700 mt-1">
                After creating your lesson, you'll be able to:
              </p>
              <ul className="text-sm text-blue-700 mt-2 list-disc list-inside space-y-1">
                <li>Upload videos to your lesson</li>
                <li>Add interactive milestones and questions</li>
                <li>Preview the student experience</li>
                <li>Publish your lesson for students</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/pages/teacher/TeacherLessonsPage.tsx">
import React, { useState, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import { lessonService } from '../../services/lesson'
import { useAuth } from '../../hooks/useAuth'
import type { Lesson } from '../../services/lesson'

export default function TeacherLessonsPage() {
  const navigate = useNavigate()
  const { user } = useAuth()
  const [lessons, setLessons] = useState<Lesson[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [searchTerm, setSearchTerm] = useState('')
  const [statusFilter, setStatusFilter] = useState<'ALL' | 'DRAFT' | 'PUBLISHED' | 'ARCHIVED'>('ALL')

  // Check if user is teacher or admin
  if (!user || (user.role !== 'TEACHER' && user.role !== 'ADMIN')) {
    return (
      <div className="p-6">
        <div className="card text-center py-8">
          <h3 className="text-lg font-semibold text-gray-900 mb-2">Access Denied</h3>
          <p className="text-gray-600 mb-4">Only teachers and administrators can access this page.</p>
          <button
            onClick={() => navigate('/dashboard')}
            className="btn-primary"
          >
            Back to Dashboard
          </button>
        </div>
      </div>
    )
  }

  useEffect(() => {
    loadLessons()
  }, [statusFilter])

  const loadLessons = async () => {
    setLoading(true)
    setError(null)

    try {
      const params: any = {
        page: 1,
        limit: 50,
        createdById: user?.id // Show only lessons created by this teacher
      }
      
      // Apply status filter
      if (statusFilter !== 'ALL') {
        params.status = statusFilter
      }
      
      // Only include search if it's not empty
      if (searchTerm && searchTerm.trim()) {
        params.search = searchTerm.trim()
      }
      
      const response = await lessonService.getLessons(params)
      setLessons(response?.items || [])
    } catch (err: any) {
      console.error('Error loading lessons:', err)
      setError(err.message || 'Failed to load lessons')
      setLessons([]) // Ensure lessons is always an array
    } finally {
      setLoading(false)
    }
  }

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault()
    loadLessons()
  }

  const handleLessonClick = (lessonId: string) => {
    navigate(`/teacher/lessons/${lessonId}`)
  }

  const handlePublishLesson = async (lessonId: string, e: React.MouseEvent) => {
    e.stopPropagation() // Prevent navigating to lesson management
    try {
      await lessonService.publishLesson(lessonId)
      loadLessons() // Refresh the list
    } catch (err: any) {
      console.error('Error publishing lesson:', err)
      // Show error notification (you could add a toast here)
      alert(err.message || 'Failed to publish lesson')
    }
  }

  const handleDeleteLesson = async (lessonId: string, lessonTitle: string, e: React.MouseEvent) => {
    e.stopPropagation() // Prevent navigating to lesson management
    
    // Confirm deletion
    const confirmed = confirm(
      `Are you sure you want to delete "${lessonTitle}"?

This action cannot be undone and will permanently remove the lesson and all its content.

Note: Lessons with student progress cannot be deleted and must be archived instead.`
    )
    
    if (!confirmed) return

    try {
      await lessonService.deleteLesson(lessonId)
      loadLessons() // Refresh the list
    } catch (err: any) {
      console.error('Error deleting lesson:', err)
      
      // Check if it's because of student progress
      if (err.response?.data?.error?.includes('student progress')) {
        const archiveConfirmed = confirm(
          `This lesson has existing student progress and cannot be deleted.

Would you like to archive it instead?

Archived lessons are hidden from students but preserve all learning data.`
        )
        
        if (archiveConfirmed) {
          try {
            await lessonService.archiveLesson(lessonId)
            loadLessons() // Refresh the list
            alert('Lesson archived successfully')
          } catch (archiveErr: any) {
            console.error('Error archiving lesson:', archiveErr)
            alert(archiveErr.message || 'Failed to archive lesson')
          }
        }
      } else {
        // Show other errors
        alert(err.response?.data?.error || err.message || 'Failed to delete lesson')
      }
    }
  }

  const getStatusBadgeClass = (status: string) => {
    switch (status) {
      case 'PUBLISHED':
        return 'bg-green-100 text-green-700'
      case 'DRAFT':
        return 'bg-yellow-100 text-yellow-700'
      case 'ARCHIVED':
        return 'bg-gray-100 text-gray-700'
      default:
        return 'bg-gray-100 text-gray-700'
    }
  }

  if (loading) {
    return (
      <div className="p-6">
        <h1 className="text-2xl font-bold text-gray-900 mb-6">
          My Lessons
        </h1>
        <div className="flex items-center justify-center h-64">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading lessons...</p>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="p-6">
      <div className="flex items-center justify-between mb-6">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">
            My Lessons
          </h1>
          <p className="text-gray-600 mt-1">
            Create, edit, publish, and manage your lessons
          </p>
        </div>
        
        <button
          onClick={() => navigate('/teacher/create-lesson')}
          className="btn-primary flex items-center space-x-2"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" />
          </svg>
          <span>Create New Lesson</span>
        </button>
      </div>

      {/* Filters and Search */}
      <div className="flex flex-col sm:flex-row gap-4 mb-6">
        {/* Status Filter */}
        <div className="flex items-center space-x-2">
          <label htmlFor="status-filter" className="text-sm font-medium text-gray-700">
            Status:
          </label>
          <select
            id="status-filter"
            value={statusFilter}
            onChange={(e) => setStatusFilter(e.target.value as any)}
            className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          >
            <option value="ALL">All</option>
            <option value="DRAFT">Draft</option>
            <option value="PUBLISHED">Published</option>
            <option value="ARCHIVED">Archived</option>
          </select>
        </div>

        {/* Search */}
        <form onSubmit={handleSearch} className="flex items-center space-x-2 flex-1">
          <input
            type="text"
            placeholder="Search lessons..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          />
          <button
            type="submit"
            className="btn-primary"
          >
            Search
          </button>
        </form>
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-md p-4 mb-6">
          <div className="flex">
            <svg className="w-5 h-5 text-red-400 mt-0.5 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
            </svg>
            <p className="text-red-700">{error}</p>
          </div>
        </div>
      )}

      {lessons && lessons.length === 0 && !loading && !error ? (
        <div className="text-center py-12">
          <svg className="w-12 h-12 text-gray-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
          </svg>
          <h3 className="text-lg font-semibold text-gray-900 mb-2">No Lessons Found</h3>
          <p className="text-gray-600 mb-4">
            {searchTerm ? 'No lessons found matching your search.' : 'You haven\'t created any lessons yet.'}
          </p>
          {searchTerm ? (
            <button
              onClick={() => {
                setSearchTerm('')
                loadLessons()
              }}
              className="btn-secondary mr-3"
            >
              Clear Search
            </button>
          ) : null}
          <button
            onClick={() => navigate('/teacher/create-lesson')}
            className="btn-primary"
          >
            Create Your First Lesson
          </button>
        </div>
      ) : (
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {lessons && lessons.map((lesson) => (
            <div 
              key={lesson.id} 
              className="card hover:shadow-lg transition-shadow cursor-pointer"
              onClick={() => handleLessonClick(lesson.id)}
            >
              <div className="mb-4">
                <div className="flex items-start justify-between mb-2">
                  <h3 className="text-xl font-semibold text-gray-900">
                    {lesson.title}
                  </h3>
                  <span className={`px-2 py-1 rounded-full text-xs font-medium ${getStatusBadgeClass(lesson.status)}`}>
                    {lesson.status}
                  </span>
                </div>
                
                {lesson.description && (
                  <p className="text-gray-600 mb-3">
                    {lesson.description}
                  </p>
                )}
                
                {/* Tags */}
                {lesson.tags && lesson.tags.length > 0 && (
                  <div className="flex flex-wrap gap-2 mb-3">
                    {lesson.tags.map((tag, index) => (
                      <span
                        key={index}
                        className="px-2 py-1 bg-blue-100 text-blue-700 text-sm rounded-full"
                      >
                        {tag}
                      </span>
                    ))}
                  </div>
                )}

                {/* Lesson Info */}
                <div className="text-sm text-gray-500 mb-4 flex items-center gap-4">
                  {lesson.difficulty && (
                    <span className="capitalize">{lesson.difficulty}</span>
                  )}
                  {lesson.estimatedTime && (
                    <span>{lesson.estimatedTime} min</span>
                  )}
                  <span>
                    Created {new Date(lesson.createdAt).toLocaleDateString()}
                  </span>
                </div>
              </div>

              {/* Action Buttons */}
              <div className="flex items-center justify-between pt-4 border-t border-gray-100">
                <div className="flex items-center space-x-2 text-sm text-gray-600">
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                  </svg>
                  <span>Edit Lesson</span>
                </div>
                
                <div className="flex items-center space-x-2">
                  {lesson.status === 'DRAFT' && (
                    <button
                      onClick={(e) => handlePublishLesson(lesson.id, e)}
                      className="px-3 py-1 bg-green-600 text-white text-sm rounded-md hover:bg-green-700 transition-colors"
                    >
                      Publish
                    </button>
                  )}
                  
                  <button
                    onClick={(e) => handleDeleteLesson(lesson.id, lesson.title, e)}
                    className="px-3 py-1 bg-red-600 text-white text-sm rounded-md hover:bg-red-700 focus:ring-2 focus:ring-red-500 focus:ring-offset-1 transition-colors flex items-center space-x-1"
                    title="Delete lesson permanently"
                  >
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                    <span>Delete</span>
                  </button>
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}
</file>

<file path="frontend/src/services/auth.ts">
import { apiService } from './api'
import TokenManager from './tokenManager'
import type { AuthResponse, LoginCredentials, RegisterData, User } from '../types/auth'
import { debug } from '../utils/debug'

class AuthService {
  /**
   * Login user and store tokens
   */
  async login(credentials: LoginCredentials): Promise<AuthResponse> {
    try {
      const response = await apiService.post<AuthResponse>('/auth/login', credentials)
      
      if (response.success && response.data) {
        // Use TokenManager to store tokens
        const stored = TokenManager.setTokens(
          response.data.tokens.accessToken,
          response.data.tokens.refreshToken
        )
        
        if (!stored) {
          throw new Error('Failed to store authentication tokens')
        }
        
        // Set auth token in API service
        apiService.setAuthToken(response.data.tokens.accessToken)
      }
      
      return response
    } catch (error: any) {
      debug.error('Login error:', error)
      return {
        success: false,
        error: error.response?.data?.error || error.message || 'Login failed'
      }
    }
  }

  /**
   * Register new user and store tokens
   */
  async register(data: RegisterData): Promise<AuthResponse> {
    try {
      const response = await apiService.post<AuthResponse>('/auth/register', data)
      
      if (response.success && response.data) {
        // Use TokenManager to store tokens
        const stored = TokenManager.setTokens(
          response.data.tokens.accessToken,
          response.data.tokens.refreshToken
        )
        
        if (!stored) {
          throw new Error('Failed to store authentication tokens')
        }
        
        // Set auth token in API service
        apiService.setAuthToken(response.data.tokens.accessToken)
      }
      
      return response
    } catch (error: any) {
      debug.error('Registration error:', error)
      return {
        success: false,
        error: error.response?.data?.error || error.message || 'Registration failed'
      }
    }
  }

  /**
   * Get current authenticated user
   */
  async getCurrentUser(): Promise<User | null> {
    try {
      // Check if we have a valid token first
      if (!TokenManager.isTokenValid()) {
        debug.auth('No valid token, cannot get current user')
        return null
      }

      const response = await apiService.get<{ success: boolean; data: User }>('/auth/me')
      return response.success ? response.data : null
    } catch (error: any) {
      debug.error('Failed to get current user:', error)
      
      // If 401, token might be invalid
      if (error.response?.status === 401) {
        TokenManager.clearTokens()
      }
      
      return null
    }
  }

  /**
   * Refresh authentication token
   */
  async refreshToken(): Promise<boolean> {
    try {
      const refreshToken = TokenManager.getRefreshToken()
      if (!refreshToken) {
        debug.auth('No refresh token available')
        return false
      }

      // Use deduplication to prevent multiple refresh calls
      return await TokenManager.refreshTokenWithDedup(async () => {
        const response = await apiService.post<{
          success: boolean
          data: { tokens: { accessToken: string; refreshToken: string } }
        }>('/auth/refresh', { refreshToken })

        if (!response.success || !response.data) {
          throw new Error('Refresh failed')
        }

        // Update API service with new token
        apiService.setAuthToken(response.data.tokens.accessToken)
        
        return response.data.tokens
      })
    } catch (error: any) {
      debug.error('Token refresh failed:', error)
      
      // Clear tokens on refresh failure
      this.logout()
      return false
    }
  }

  /**
   * Logout user and clear tokens
   */
  logout(): void {
    // Clear tokens using TokenManager
    TokenManager.clearTokens()
    
    // Remove auth token from API service
    apiService.removeAuthToken()
    
    // Optional: Call logout endpoint to invalidate server-side session
    apiService.post('/auth/logout').catch(() => {
      // Ignore logout API errors
    })
  }

  /**
   * Check if user is authenticated
   */
  isAuthenticated(): boolean {
    return TokenManager.isTokenValid()
  }

  /**
   * Get stored tokens
   */
  getStoredTokens(): { accessToken: string; refreshToken: string } | null {
    const accessToken = TokenManager.getAccessToken()
    const refreshToken = TokenManager.getRefreshToken()
    
    if (accessToken && refreshToken) {
      return { accessToken, refreshToken }
    }
    
    return null
  }

  /**
   * Check if user has specific role
   */
  hasRole(role: string): boolean {
    return TokenManager.hasRole(role)
  }

  /**
   * Get time until token expiry
   */
  getTokenExpiryTime(): number {
    return TokenManager.getTimeUntilExpiry()
  }
}

export const authService = new AuthService()
export default authService
</file>

<file path="frontend/src/stores/VideoStateManager.ts">
import type { 
  Video, 
  Milestone, 
  Question, 
  VideoSession
} from '../services/video'

// Define QuestionAnswer type locally
interface QuestionAnswer {
  questionId: string
  answer: string
  isCorrect: boolean
  timestamp?: number
}
import {
  videoService,
  sessionService
} from '../services/video'

export interface VideoState {
  video: Video
  milestones: Milestone[]
  questions: Map<string, Question[]> // milestoneId -> questions
  metadata: {
    totalMilestones: number
    totalQuestions: number
    questionsPerMilestone: Map<string, number>
    lastUpdated: Date
    isLoading: boolean
    error: string | null
  }
}

export interface SessionState {
  session: VideoSession
  milestoneProgress: Set<string> // milestoneIds reached
  questionAnswers: Map<string, QuestionAnswer> // questionId -> answer
  currentMilestone: Milestone | null
  metadata: {
    correctAnswers: number
    totalAnswers: number
    completionPercentage: number
    lastUpdated: Date
  }
}

export type StateListener = (state: {
  videos: Map<string, VideoState>
  sessions: Map<string, SessionState>
}) => void

export type VideoStateListener = (videoId: string, state: VideoState) => void
export type SessionStateListener = (sessionId: string, state: SessionState) => void

class VideoStateManager {
  private static instance: VideoStateManager | null = null
  
  private videos: Map<string, VideoState> = new Map()
  private sessions: Map<string, SessionState> = new Map()
  private listeners: Set<StateListener> = new Set()
  private videoListeners: Map<string, Set<VideoStateListener>> = new Map()
  private sessionListeners: Map<string, Set<SessionStateListener>> = new Map()
  
  private constructor() {}
  
  static getInstance(): VideoStateManager {
    if (!VideoStateManager.instance) {
      VideoStateManager.instance = new VideoStateManager()
    }
    return VideoStateManager.instance
  }
  
  // Core subscription methods
  subscribe(listener: StateListener): () => void {
    this.listeners.add(listener)
    // Immediately call with current state
    listener({ videos: this.videos, sessions: this.sessions })
    
    return () => {
      this.listeners.delete(listener)
    }
  }
  
  subscribeToVideo(videoId: string, listener: VideoStateListener): () => void {
    if (!this.videoListeners.has(videoId)) {
      this.videoListeners.set(videoId, new Set())
    }
    this.videoListeners.get(videoId)!.add(listener)
    
    // Immediately call with current state if exists
    const state = this.videos.get(videoId)
    if (state) {
      listener(videoId, state)
    }
    
    return () => {
      this.videoListeners.get(videoId)?.delete(listener)
    }
  }
  
  subscribeToSession(sessionId: string, listener: SessionStateListener): () => void {
    if (!this.sessionListeners.has(sessionId)) {
      this.sessionListeners.set(sessionId, new Set())
    }
    this.sessionListeners.get(sessionId)!.add(listener)
    
    // Immediately call with current state if exists
    const state = this.sessions.get(sessionId)
    if (state) {
      listener(sessionId, state)
    }
    
    return () => {
      this.sessionListeners.get(sessionId)?.delete(listener)
    }
  }
  
  private notifyListeners() {
    this.listeners.forEach(listener => {
      listener({ videos: this.videos, sessions: this.sessions })
    })
  }
  
  private notifyVideoListeners(videoId: string) {
    const state = this.videos.get(videoId)
    if (state) {
      this.videoListeners.get(videoId)?.forEach(listener => {
        listener(videoId, state)
      })
    }
  }
  
  private notifySessionListeners(sessionId: string) {
    const state = this.sessions.get(sessionId)
    if (state) {
      this.sessionListeners.get(sessionId)?.forEach(listener => {
        listener(sessionId, state)
      })
    }
  }
  
  // Video management
  async loadVideo(videoId: string, forceRefresh = false): Promise<VideoState> {
    const existing = this.videos.get(videoId)
    if (existing && !forceRefresh && !existing.metadata.isLoading) {
      const age = Date.now() - existing.metadata.lastUpdated.getTime()
      if (age < 30000) { // 30 seconds cache
        return existing
      }
    }
    
    // Set loading state
    this.updateVideoState(videoId, {
      metadata: { 
        ...this.videos.get(videoId)?.metadata || {
          totalMilestones: 0,
          totalQuestions: 0,
          questionsPerMilestone: new Map(),
          lastUpdated: new Date()
        },
        isLoading: true, 
        error: null 
      }
    })
    
    try {
      const video = await videoService.getVideo(videoId)
      const milestones = video.milestones || []
      
      // Build questions map
      const questions = new Map<string, Question[]>()
      let totalQuestions = 0
      const questionsPerMilestone = new Map<string, number>()
      
      for (const milestone of milestones) {
        const milestoneQuestions = milestone.questions || []
        questions.set(milestone.id, milestoneQuestions)
        questionsPerMilestone.set(milestone.id, milestoneQuestions.length)
        totalQuestions += milestoneQuestions.length
      }
      
      const state: VideoState = {
        video,
        milestones,
        questions,
        metadata: {
          totalMilestones: milestones.length,
          totalQuestions,
          questionsPerMilestone,
          lastUpdated: new Date(),
          isLoading: false,
          error: null
        }
      }
      
      this.videos.set(videoId, state)
      this.notifyVideoListeners(videoId)
      this.notifyListeners()
      
      return state
    } catch (error: any) {
      this.updateVideoState(videoId, {
        metadata: { 
          ...this.videos.get(videoId)?.metadata || {
            totalMilestones: 0,
            totalQuestions: 0,
            questionsPerMilestone: new Map(),
            lastUpdated: new Date()
          },
          isLoading: false, 
          error: error.message || 'Failed to load video' 
        }
      })
      throw error
    }
  }
  
  private updateVideoState(videoId: string, updates: Partial<VideoState>) {
    const current = this.videos.get(videoId) || {
      video: { id: videoId } as Video,
      milestones: [],
      questions: new Map(),
      metadata: {
        totalMilestones: 0,
        totalQuestions: 0,
        questionsPerMilestone: new Map(),
        lastUpdated: new Date(),
        isLoading: false,
        error: null
      }
    }
    
    const updated = {
      ...current,
      ...updates,
      metadata: {
        ...current.metadata,
        ...(updates.metadata || {}),
        lastUpdated: new Date()
      }
    }
    
    this.videos.set(videoId, updated)
    this.notifyVideoListeners(videoId)
    this.notifyListeners()
  }
  
  // Milestone management
  async addMilestone(videoId: string, milestone: Milestone): Promise<void> {
    const state = this.videos.get(videoId)
    if (!state) {
      await this.loadVideo(videoId)
    }
    
    const current = this.videos.get(videoId)!
    const milestones = [...current.milestones, milestone]
    
    // Update questions map
    const questions = new Map(current.questions)
    questions.set(milestone.id, milestone.questions || [])
    
    // Recalculate metadata
    const questionsPerMilestone = new Map(current.metadata.questionsPerMilestone)
    questionsPerMilestone.set(milestone.id, (milestone.questions || []).length)
    
    const totalQuestions = Array.from(questions.values())
      .reduce((sum, q) => sum + q.length, 0)
    
    this.updateVideoState(videoId, {
      milestones,
      questions,
      metadata: {
        ...current.metadata,
        totalMilestones: milestones.length,
        totalQuestions,
        questionsPerMilestone,
        lastUpdated: new Date()
      }
    })
  }
  
  async updateMilestone(videoId: string, milestoneId: string, updates: Partial<Milestone>): Promise<void> {
    const state = this.videos.get(videoId)
    if (!state) return
    
    const milestones = state.milestones.map(m => 
      m.id === milestoneId ? { ...m, ...updates } : m
    )
    
    this.updateVideoState(videoId, { milestones })
  }
  
  // Question management
  async addQuestion(videoId: string, milestoneId: string, question: Question): Promise<void> {
    const state = this.videos.get(videoId)
    if (!state) {
      await this.loadVideo(videoId)
    }
    
    const current = this.videos.get(videoId)!
    const questions = new Map(current.questions)
    const milestoneQuestions = questions.get(milestoneId) || []
    questions.set(milestoneId, [...milestoneQuestions, question])
    
    // Update milestone with new question
    const milestones = current.milestones.map(m => {
      if (m.id === milestoneId) {
        return {
          ...m,
          questions: [...(m.questions || []), question],
          _count: { ...m._count, questions: (m._count?.questions || 0) + 1 }
        }
      }
      return m
    })
    
    // Recalculate metadata
    const questionsPerMilestone = new Map(current.metadata.questionsPerMilestone)
    questionsPerMilestone.set(milestoneId, (questionsPerMilestone.get(milestoneId) || 0) + 1)
    
    const totalQuestions = current.metadata.totalQuestions + 1
    
    this.updateVideoState(videoId, {
      milestones,
      questions,
      metadata: {
        ...current.metadata,
        totalQuestions,
        questionsPerMilestone,
        lastUpdated: new Date()
      }
    })
  }
  
  async addQuestions(videoId: string, milestoneId: string, newQuestions: Question[]): Promise<void> {
    const state = this.videos.get(videoId)
    if (!state) {
      await this.loadVideo(videoId)
    }
    
    const current = this.videos.get(videoId)!
    const questions = new Map(current.questions)
    const milestoneQuestions = questions.get(milestoneId) || []
    questions.set(milestoneId, [...milestoneQuestions, ...newQuestions])
    
    // Update milestone with new questions
    const milestones = current.milestones.map(m => {
      if (m.id === milestoneId) {
        return {
          ...m,
          questions: [...(m.questions || []), ...newQuestions],
          _count: { ...m._count, questions: (m._count?.questions || 0) + newQuestions.length }
        }
      }
      return m
    })
    
    // Recalculate metadata
    const questionsPerMilestone = new Map(current.metadata.questionsPerMilestone)
    questionsPerMilestone.set(
      milestoneId, 
      (questionsPerMilestone.get(milestoneId) || 0) + newQuestions.length
    )
    
    const totalQuestions = current.metadata.totalQuestions + newQuestions.length
    
    this.updateVideoState(videoId, {
      milestones,
      questions,
      metadata: {
        ...current.metadata,
        totalQuestions,
        questionsPerMilestone,
        lastUpdated: new Date()
      }
    })
  }
  
  async removeQuestion(videoId: string, milestoneId: string, questionId: string): Promise<void> {
    const state = this.videos.get(videoId)
    if (!state) return
    
    const questions = new Map(state.questions)
    const milestoneQuestions = (questions.get(milestoneId) || [])
      .filter(q => q.id !== questionId)
    questions.set(milestoneId, milestoneQuestions)
    
    // Update milestone
    const milestones = state.milestones.map(m => {
      if (m.id === milestoneId) {
        return {
          ...m,
          questions: milestoneQuestions,
          _count: { ...m._count, questions: milestoneQuestions.length }
        }
      }
      return m
    })
    
    // Recalculate metadata
    const questionsPerMilestone = new Map(state.metadata.questionsPerMilestone)
    questionsPerMilestone.set(milestoneId, milestoneQuestions.length)
    
    const totalQuestions = Array.from(questions.values())
      .reduce((sum, q) => sum + q.length, 0)
    
    this.updateVideoState(videoId, {
      milestones,
      questions,
      metadata: {
        ...state.metadata,
        totalQuestions,
        questionsPerMilestone,
        lastUpdated: new Date()
      }
    })
  }
  
  // Session management
  async startOrResumeSession(videoId: string): Promise<SessionState> {
    try {
      const session = await sessionService.startSession(videoId)
      
      const milestoneProgress = new Set<string>(
        (session.milestoneProgress || []).map((mp: any) => mp.milestoneId)
      )
      
      const questionAnswers = new Map<string, QuestionAnswer>()
      let correctAnswers = 0
      
      for (const attempt of (session.questionAttempts || [])) {
        const answer: QuestionAnswer = {
          questionId: attempt.questionId,
          answer: attempt.studentAnswer,
          isCorrect: attempt.isCorrect || false
        }
        questionAnswers.set(attempt.questionId, answer)
        if (attempt.isCorrect) correctAnswers++
      }
      
      const videoState = await this.loadVideo(videoId)
      const completionPercentage = videoState.video.duration 
        ? Math.round((session.currentPosition / videoState.video.duration) * 100)
        : 0
      
      const state: SessionState = {
        session,
        milestoneProgress,
        questionAnswers,
        currentMilestone: null,
        metadata: {
          correctAnswers,
          totalAnswers: questionAnswers.size,
          completionPercentage,
          lastUpdated: new Date()
        }
      }
      
      this.sessions.set(session.id, state)
      this.notifySessionListeners(session.id)
      this.notifyListeners()
      
      return state
    } catch (error: any) {
      throw error
    }
  }
  
  async updateSessionProgress(sessionId: string, currentTime: number, totalWatchTime: number): Promise<void> {
    const state = this.sessions.get(sessionId)
    if (!state) return
    
    const updatedSession = await sessionService.updateProgress(sessionId, {
      currentTime,
      totalWatchTime
    })
    
    const videoState = this.videos.get(updatedSession.videoId)
    const completionPercentage = videoState?.video.duration 
      ? Math.round((currentTime / videoState.video.duration) * 100)
      : 0
    
    this.sessions.set(sessionId, {
      ...state,
      session: updatedSession,
      metadata: {
        ...state.metadata,
        completionPercentage,
        lastUpdated: new Date()
      }
    })
    
    this.notifySessionListeners(sessionId)
    this.notifyListeners()
  }
  
  async markMilestoneReached(sessionId: string, milestoneId: string, timestamp: number): Promise<void> {
    const state = this.sessions.get(sessionId)
    if (!state) return
    
    await sessionService.markMilestoneReached(sessionId, {
      milestoneId,
      timestamp
    })
    
    state.milestoneProgress.add(milestoneId)
    
    // Find the milestone
    const videoState = this.videos.get(state.session.videoId)
    const milestone = videoState?.milestones.find(m => m.id === milestoneId)
    
    this.sessions.set(sessionId, {
      ...state,
      currentMilestone: milestone || null,
      metadata: {
        ...state.metadata,
        lastUpdated: new Date()
      }
    })
    
    this.notifySessionListeners(sessionId)
    this.notifyListeners()
  }
  
  async submitAnswer(
    sessionId: string, 
    questionId: string, 
    answer: string, 
    milestoneId: string
  ): Promise<{ isCorrect: boolean; explanation?: string }> {
    const state = this.sessions.get(sessionId)
    if (!state) throw new Error('Session not found')
    
    const result = await sessionService.submitAnswer(sessionId, {
      questionId,
      answer,
      milestoneId
    })
    
    // Create QuestionAnswer from the result
    const questionAnswer: QuestionAnswer = {
      questionId,
      answer,
      isCorrect: result.isCorrect
    }
    
    state.questionAnswers.set(questionId, questionAnswer)
    
    const correctAnswers = Array.from(state.questionAnswers.values())
      .filter(a => a.isCorrect).length
    
    this.sessions.set(sessionId, {
      ...state,
      metadata: {
        ...state.metadata,
        correctAnswers,
        totalAnswers: state.questionAnswers.size,
        lastUpdated: new Date()
      }
    })
    
    this.notifySessionListeners(sessionId)
    this.notifyListeners()
    
    return {
      isCorrect: result.isCorrect,
      explanation: result.explanation
    }
  }
  
  // Utility methods
  getVideoState(videoId: string): VideoState | undefined {
    return this.videos.get(videoId)
  }
  
  getSessionState(sessionId: string): SessionState | undefined {
    return this.sessions.get(sessionId)
  }
  
  clearCache(videoId?: string): void {
    if (videoId) {
      this.videos.delete(videoId)
      this.notifyVideoListeners(videoId)
    } else {
      this.videos.clear()
      this.sessions.clear()
    }
    this.notifyListeners()
  }
  
  // Batch operations for AI-generated questions
  async processAIGeneratedQuestions(
    videoId: string,
    questionsPerMilestone: Map<string, Question[]>
  ): Promise<void> {
    for (const [milestoneId, questions] of questionsPerMilestone) {
      await this.addQuestions(videoId, milestoneId, questions)
    }
  }
}

export const videoStateManager = VideoStateManager.getInstance()
</file>

<file path="src/routes/authRoutes.ts">
import { Router, Request, Response } from 'express';
import authService from '../services/auth/authService';
import { body } from 'express-validator';
import { validateRequest } from '../middleware/validation/validateRequest';
import { logger } from '../utils/logger';
import { authenticate, AuthenticatedRequest } from '../middleware/auth/authMiddleware';
import { AppError } from '../types';

const router = Router();

// Validation schemas
const loginValidation = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Valid email is required'),
  body('password')
    .notEmpty()
    .withMessage('Password is required')
];

const registerValidation = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Valid email is required'),
  body('firstName')
    .trim()
    .isLength({ min: 1, max: 50 })
    .withMessage('First name must be 1-50 characters'),
  body('lastName')
    .trim()
    .isLength({ min: 1, max: 50 })
    .withMessage('Last name must be 1-50 characters'),
  body('password')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
    .withMessage('Password must contain at least one lowercase letter, one uppercase letter, and one number'),
  body('username')
    .optional()
    .trim()
    .isLength({ min: 3, max: 30 })
    .matches(/^[a-zA-Z0-9_-]+$/)
    .withMessage('Username must be 3-30 characters and contain only letters, numbers, underscores, and hyphens'),
  body('role')
    .optional()
    .isIn(['STUDENT', 'TEACHER'])
    .withMessage('Role must be STUDENT or TEACHER')
];

const refreshTokenValidation = [
  body('refreshToken')
    .notEmpty()
    .withMessage('Refresh token is required')
];

// Routes

// POST /api/auth/login - User login
router.post('/login',
  loginValidation,
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const { email, password } = req.body;
      
      const result = await authService.login({ email, password });

      logger.info(`User logged in: ${email}`, {
        userId: result.user?.id,
        ip: req.ip,
        userAgent: req.get('User-Agent')
      });

      return res.json({
        success: true,
        data: {
          user: result.user,
          tokens: {
            accessToken: result.accessToken,
            refreshToken: result.refreshToken
          }
        },
        message: 'Login successful'
      });
    } catch (error) {
      logger.error('Login error:', error);
      
      if (error instanceof AppError) {
        return res.status(error.statusCode).json({
          success: false,
          error: error.message
        });
      }
      
      return res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
    }
  }
);

// POST /api/auth/register - User registration
router.post('/register',
  registerValidation,
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const registrationData = req.body;
      
      const result = await authService.register(registrationData);

      logger.info(`User registered: ${registrationData.email}`, {
        userId: result.user?.id,
        role: result.user?.role,
        ip: req.ip
      });

      return res.status(201).json({
        success: true,
        data: {
          user: result.user,
          tokens: {
            accessToken: result.accessToken,
            refreshToken: result.refreshToken
          }
        },
        message: 'Registration successful'
      });
    } catch (error) {
      logger.error('Registration error:', error);
      
      if (error instanceof AppError) {
        return res.status(error.statusCode).json({
          success: false,
          error: error.message
        });
      }
      
      return res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
    }
  }
);

// POST /api/auth/refresh - Refresh access token
router.post('/refresh',
  refreshTokenValidation,
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const { refreshToken } = req.body;
      
      const result = await authService.refreshToken(refreshToken);

      return res.json({
        success: true,
        data: {
          tokens: {
            accessToken: result.accessToken,
            refreshToken: result.refreshToken
          }
        },
        message: 'Token refreshed successfully'
      });
    } catch (error) {
      logger.error('Token refresh error:', error);
      
      if (error instanceof AppError) {
        return res.status(error.statusCode).json({
          success: false,
          error: error.message
        });
      }
      
      return res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
    }
  }
);

// POST /api/auth/logout - User logout
router.post('/logout',
  authenticate,
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const userId = req.user!.id;
      
      // In a more sophisticated implementation, you would invalidate the refresh token
      // For now, we just log the logout event
      logger.info(`User logged out: ${req.user!.email}`, {
        userId,
        ip: req.ip
      });

      return res.json({
        success: true,
        message: 'Logout successful'
      });
    } catch (error) {
      logger.error('Logout error:', error);
      return res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
    }
  }
);

// GET /api/auth/me - Get current user profile
router.get('/me',
  authenticate,
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const user = req.user!;
      
      return res.json({
        success: true,
        data: {
          id: user.id,
          email: user.email,
          username: user.username,
          firstName: user.firstName,
          lastName: user.lastName,
          avatar: user.avatar,
          role: user.role,
          status: user.status,
          tenantId: user.tenantId,
          lastLoginAt: user.lastLoginAt,
          emailVerified: user.emailVerified,
          createdAt: user.createdAt
        }
      });
    } catch (error) {
      logger.error('Get profile error:', error);
      return res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
    }
  }
);

export default router;
</file>

<file path="src/routes/lessonRoutes.ts">
import { Router } from 'express';
import { lessonController } from '../controllers/lessonController';
import { authenticate, authorize } from '../middleware/auth/authMiddleware';
import { body, param, query } from 'express-validator';
import { validateRequest } from '../middleware/validation/validateRequest';

const router = Router();

// Validation schemas
const createLessonValidation = [
  body('title')
    .trim()
    .isLength({ min: 1, max: 200 })
    .withMessage('Title must be 1-200 characters'),
  body('description')
    .optional()
    .trim()
    .isLength({ max: 2000 })
    .withMessage('Description must be less than 2000 characters'),
  body('thumbnail')
    .optional()
    .isURL()
    .withMessage('Thumbnail must be a valid URL'),
  body('objectives')
    .optional()
    .isArray()
    .withMessage('Objectives must be an array'),
  body('objectives.*')
    .optional()
    .isString()
    .trim()
    .isLength({ min: 1, max: 500 })
    .withMessage('Each objective must be 1-500 characters'),
  body('estimatedTime')
    .optional()
    .isInt({ min: 1, max: 10080 })
    .withMessage('Estimated time must be between 1 and 10080 minutes (1 week)'),
  body('difficulty')
    .optional()
    .isIn(['beginner', 'intermediate', 'advanced'])
    .withMessage('Difficulty must be beginner, intermediate, or advanced'),
  body('tags')
    .optional()
    .isArray()
    .withMessage('Tags must be an array'),
  body('tags.*')
    .optional()
    .isString()
    .trim()
    .isLength({ min: 1, max: 50 })
    .withMessage('Each tag must be 1-50 characters'),
  body('order')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Order must be a non-negative integer')
];

const updateLessonValidation = [
  body('title')
    .optional()
    .trim()
    .isLength({ min: 1, max: 200 })
    .withMessage('Title must be 1-200 characters'),
  body('description')
    .optional()
    .trim()
    .isLength({ max: 2000 })
    .withMessage('Description must be less than 2000 characters'),
  body('thumbnail')
    .optional()
    .isURL()
    .withMessage('Thumbnail must be a valid URL'),
  body('objectives')
    .optional()
    .isArray()
    .withMessage('Objectives must be an array'),
  body('objectives.*')
    .optional()
    .isString()
    .trim()
    .isLength({ min: 1, max: 500 })
    .withMessage('Each objective must be 1-500 characters'),
  body('estimatedTime')
    .optional()
    .isInt({ min: 1, max: 10080 })
    .withMessage('Estimated time must be between 1 and 10080 minutes'),
  body('difficulty')
    .optional()
    .isIn(['beginner', 'intermediate', 'advanced'])
    .withMessage('Difficulty must be beginner, intermediate, or advanced'),
  body('tags')
    .optional()
    .isArray()
    .withMessage('Tags must be an array'),
  body('tags.*')
    .optional()
    .isString()
    .trim()
    .isLength({ min: 1, max: 50 })
    .withMessage('Each tag must be 1-50 characters'),
  body('order')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Order must be a non-negative integer'),
  body('status')
    .optional()
    .isIn(['DRAFT', 'PUBLISHED', 'ARCHIVED'])
    .withMessage('Status must be DRAFT, PUBLISHED, or ARCHIVED')
];

const lessonIdValidation = [
  param('id')
    .isString()
    .isLength({ min: 1 })
    .withMessage('Lesson ID is required')
];

const queryValidation = [
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Page must be a positive integer'),
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('Limit must be between 1 and 100'),
  query('status')
    .optional()
    .isIn(['DRAFT', 'PUBLISHED', 'ARCHIVED'])
    .withMessage('Status must be DRAFT, PUBLISHED, or ARCHIVED'),
  query('difficulty')
    .optional()
    .isIn(['beginner', 'intermediate', 'advanced'])
    .withMessage('Difficulty must be beginner, intermediate, or advanced'),
  query('search')
    .optional()
    .trim()
    .isLength({ min: 1, max: 100 })
    .withMessage('Search query must be 1-100 characters'),
  query('createdById')
    .optional()
    .isString()
    .withMessage('Created by ID must be a string')
];

// Routes

// GET /api/lessons - Get all lessons
router.get('/',
  authenticate,
  queryValidation,
  validateRequest,
  lessonController.getAllLessons
);

// GET /api/lessons/:id - Get lesson by ID
router.get('/:id',
  authenticate,
  lessonIdValidation,
  validateRequest,
  lessonController.getLessonById
);

// POST /api/lessons - Create new lesson (Teacher/Admin only)
router.post('/',
  authenticate,
  authorize(['TEACHER', 'ADMIN']),
  createLessonValidation,
  validateRequest,
  lessonController.createLesson
);

// PUT /api/lessons/:id - Update lesson (Teacher/Admin only)
router.put('/:id',
  authenticate,
  authorize(['TEACHER', 'ADMIN']),
  lessonIdValidation,
  updateLessonValidation,
  validateRequest,
  lessonController.updateLesson
);

// POST /api/lessons/:id/publish - Publish lesson (Teacher/Admin only)
router.post('/:id/publish',
  authenticate,
  authorize(['TEACHER', 'ADMIN']),
  lessonIdValidation,
  validateRequest,
  lessonController.publishLesson
);

// POST /api/lessons/:id/archive - Archive lesson (Teacher/Admin only)
router.post('/:id/archive',
  authenticate,
  authorize(['TEACHER', 'ADMIN']),
  lessonIdValidation,
  validateRequest,
  lessonController.archiveLesson
);

// DELETE /api/lessons/:id - Delete lesson (Teacher/Admin only)
router.delete('/:id',
  authenticate,
  authorize(['TEACHER', 'ADMIN']),
  lessonIdValidation,
  validateRequest,
  lessonController.deleteLesson
);

export default router;
</file>

<file path="src/routes/questionRoutes.ts">
import { Router, Response } from 'express'
import { body } from 'express-validator'
import { validationResult } from 'express-validator'
import { validateCUIDParam, validateCUIDBody } from '../utils/validators'
import { authenticate } from '../middleware/auth/authMiddleware'
import { QuestionService } from '../services/QuestionService'
import { AuthenticatedRequest } from '../middleware/auth/authMiddleware'

const router = Router()

// Apply authentication middleware to all routes
router.use(authenticate)

// POST /api/questions - Create new question for milestone (teachers only)
router.post('/',
  validateCUIDBody('milestoneId', 'Valid milestone ID is required'),
  body('type').isIn(['MULTIPLE_CHOICE', 'TRUE_FALSE', 'SHORT_ANSWER', 'FILL_IN_BLANK', 'MATCHING', 'ORDERING']).withMessage('Invalid question type'),
  body('text').notEmpty().trim().withMessage('Question text is required'),
  body('explanation').optional().trim(),
  body('hints').optional().isArray().withMessage('Hints must be an array'),
  body('difficulty').optional().isIn(['easy', 'medium', 'hard']).withMessage('Invalid difficulty level'),
  body('points').optional().isInt({ min: 1 }).withMessage('Points must be a positive integer'),
  body('passThreshold').optional().isFloat({ min: 0, max: 1 }).withMessage('Pass threshold must be between 0 and 1'),
  body('questionData').notEmpty().withMessage('Question data is required'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const questionData = {
        milestoneId: req.body.milestoneId,
        type: req.body.type,
        text: req.body.text,
        explanation: req.body.explanation,
        hints: req.body.hints,
        difficulty: req.body.difficulty,
        points: req.body.points,
        passThreshold: req.body.passThreshold,
        questionData: req.body.questionData
      }

      const question = await QuestionService.createQuestion(questionData, req.user!)

      return res.status(201).json({
        success: true,
        data: question,
        message: 'Question created successfully'
      })

    } catch (error: any) {
      console.error('Error creating question:', error)
      
      if (error.message === 'Milestone not found') {
        return res.status(404).json({
          success: false,
          error: 'Milestone not found'
        })
      }
      
      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      if (error.message.includes('Question data') || error.message.includes('must have')) {
        return res.status(400).json({
          success: false,
          error: error.message
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to create question'
      })
    }
  }
)

// GET /api/questions/milestone/:milestoneId - Get all questions for a milestone
router.get('/milestone/:milestoneId',
  validateCUIDParam('milestoneId', 'Invalid milestone ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const questions = await QuestionService.getQuestionsByMilestone(req.params.milestoneId, req.user!.id)

      return res.json({
        success: true,
        data: questions
      })

    } catch (error: any) {
      console.error('Error fetching questions:', error)
      
      if (error.message === 'Milestone not found or access denied') {
        return res.status(404).json({
          success: false,
          error: 'Milestone not found or access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to fetch questions'
      })
    }
  }
)

// GET /api/questions/:id - Get specific question
router.get('/:id',
  validateCUIDParam('id', 'Invalid question ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const question = await QuestionService.getQuestionById(req.params.id, req.user!.id)

      if (!question) {
        return res.status(404).json({
          success: false,
          error: 'Question not found or access denied'
        })
      }

      return res.json({
        success: true,
        data: question
      })

    } catch (error) {
      console.error('Error fetching question:', error)
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch question'
      })
    }
  }
)

// PUT /api/questions/:id - Update question (creator or admin only)
router.put('/:id',
  validateCUIDParam('id', 'Invalid question ID'),
  body('text').optional().notEmpty().trim().withMessage('Question text cannot be empty'),
  body('explanation').optional().trim(),
  body('hints').optional().isArray().withMessage('Hints must be an array'),
  body('difficulty').optional().isIn(['easy', 'medium', 'hard']).withMessage('Invalid difficulty level'),
  body('points').optional().isInt({ min: 1 }).withMessage('Points must be a positive integer'),
  body('passThreshold').optional().isFloat({ min: 0, max: 1 }).withMessage('Pass threshold must be between 0 and 1'),
  body('status').optional().isIn(['DRAFT', 'APPROVED', 'ARCHIVED']).withMessage('Invalid status'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const updateData = {
        text: req.body.text,
        explanation: req.body.explanation,
        hints: req.body.hints,
        difficulty: req.body.difficulty,
        points: req.body.points,
        passThreshold: req.body.passThreshold,
        questionData: req.body.questionData,
        status: req.body.status
      }

      const question = await QuestionService.updateQuestion(
        req.params.id,
        updateData,
        req.user!
      )

      return res.json({
        success: true,
        data: question,
        message: 'Question updated successfully'
      })

    } catch (error: any) {
      console.error('Error updating question:', error)
      
      if (error.message === 'Question not found') {
        return res.status(404).json({
          success: false,
          error: 'Question not found'
        })
      }
      
      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      if (error.message.includes('Question data') || error.message.includes('must have')) {
        return res.status(400).json({
          success: false,
          error: error.message
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to update question'
      })
    }
  }
)

// DELETE /api/questions/:id - Delete question (creator or admin only)
router.delete('/:id',
  validateCUIDParam('id', 'Invalid question ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      await QuestionService.deleteQuestion(req.params.id, req.user!)

      return res.json({
        success: true,
        message: 'Question deleted successfully'
      })

    } catch (error: any) {
      console.error('Error deleting question:', error)
      
      if (error.message === 'Question not found') {
        return res.status(404).json({
          success: false,
          error: 'Question not found'
        })
      }
      
      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to delete question'
      })
    }
  }
)

// POST /api/questions/:id/approve - Approve question (teachers only)
router.post('/:id/approve',
  validateCUIDParam('id', 'Invalid question ID'),
  body('reviewNotes').optional().trim(),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const question = await QuestionService.approveQuestion(
        req.params.id,
        req.user!,
        req.body.reviewNotes
      )

      return res.json({
        success: true,
        data: question,
        message: 'Question approved successfully'
      })

    } catch (error: any) {
      console.error('Error approving question:', error)
      
      if (error.message === 'Question not found') {
        return res.status(404).json({
          success: false,
          error: 'Question not found'
        })
      }
      
      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to approve question'
      })
    }
  }
)

// GET /api/questions/templates - Get question type templates (for UI reference)
router.get('/templates',
  async (_req: AuthenticatedRequest, res) => {
    try {
      const templates = QuestionService.getQuestionTemplates()

      return res.json({
        success: true,
        data: templates,
        message: 'Question templates retrieved successfully'
      })

    } catch (error) {
      console.error('Error fetching question templates:', error)
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch question templates'
      })
    }
  }
)

export default router
</file>

<file path="src/routes/userRoutes.ts">
import { Router } from 'express';
import { userController } from '../controllers/userController';
import { authenticate, authorize } from '../middleware/auth/authMiddleware';
import { body, param, query } from 'express-validator';
import { validateRequest } from '../middleware/validation/validateRequest';

const router = Router();

// Validation schemas
const createUserValidation = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Valid email is required'),
  body('firstName')
    .trim()
    .isLength({ min: 1, max: 50 })
    .withMessage('First name must be 1-50 characters'),
  body('lastName')
    .trim()
    .isLength({ min: 1, max: 50 })
    .withMessage('Last name must be 1-50 characters'),
  body('password')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
    .withMessage('Password must contain at least one lowercase letter, one uppercase letter, and one number'),
  body('username')
    .optional()
    .trim()
    .isLength({ min: 3, max: 30 })
    .matches(/^[a-zA-Z0-9_-]+$/)
    .withMessage('Username must be 3-30 characters and contain only letters, numbers, underscores, and hyphens'),
  body('role')
    .optional()
    .isIn(['STUDENT', 'TEACHER', 'ADMIN'])
    .withMessage('Role must be STUDENT, TEACHER, or ADMIN'),
  body('tenantId')
    .optional()
    .isString()
    .withMessage('Tenant ID must be a string')
];

const updateUserValidation = [
  body('email')
    .optional()
    .isEmail()
    .normalizeEmail()
    .withMessage('Valid email is required'),
  body('firstName')
    .optional()
    .trim()
    .isLength({ min: 1, max: 50 })
    .withMessage('First name must be 1-50 characters'),
  body('lastName')
    .optional()
    .trim()
    .isLength({ min: 1, max: 50 })
    .withMessage('Last name must be 1-50 characters'),
  body('username')
    .optional()
    .trim()
    .isLength({ min: 3, max: 30 })
    .matches(/^[a-zA-Z0-9_-]+$/)
    .withMessage('Username must be 3-30 characters and contain only letters, numbers, underscores, and hyphens'),
  body('avatar')
    .optional()
    .isURL()
    .withMessage('Avatar must be a valid URL'),
  body('role')
    .optional()
    .isIn(['STUDENT', 'TEACHER', 'ADMIN'])
    .withMessage('Role must be STUDENT, TEACHER, or ADMIN'),
  body('status')
    .optional()
    .isIn(['ACTIVE', 'INACTIVE', 'SUSPENDED', 'PENDING_VERIFICATION'])
    .withMessage('Status must be ACTIVE, INACTIVE, SUSPENDED, or PENDING_VERIFICATION')
];

const changePasswordValidation = [
  body('currentPassword')
    .notEmpty()
    .withMessage('Current password is required'),
  body('newPassword')
    .isLength({ min: 8 })
    .withMessage('New password must be at least 8 characters')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
    .withMessage('New password must contain at least one lowercase letter, one uppercase letter, and one number')
];

const preferencesValidation = [
  body('autoplay')
    .optional()
    .isBoolean()
    .withMessage('Autoplay must be a boolean'),
  body('playbackSpeed')
    .optional()
    .isFloat({ min: 0.25, max: 3.0 })
    .withMessage('Playback speed must be between 0.25 and 3.0'),
  body('subtitles')
    .optional()
    .isBoolean()
    .withMessage('Subtitles must be a boolean'),
  body('theme')
    .optional()
    .isIn(['light', 'dark', 'auto'])
    .withMessage('Theme must be light, dark, or auto'),
  body('language')
    .optional()
    .isLength({ min: 2, max: 10 })
    .withMessage('Language must be 2-10 characters'),
  body('emailNotifications')
    .optional()
    .isBoolean()
    .withMessage('Email notifications must be a boolean'),
  body('progressNotifications')
    .optional()
    .isBoolean()
    .withMessage('Progress notifications must be a boolean'),
  body('allowAnalytics')
    .optional()
    .isBoolean()
    .withMessage('Allow analytics must be a boolean')
];

const userIdValidation = [
  param('id')
    .isString()
    .isLength({ min: 1 })
    .withMessage('User ID is required')
];

const paginationValidation = [
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Page must be a positive integer'),
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('Limit must be between 1 and 100'),
  query('role')
    .optional()
    .isIn(['STUDENT', 'TEACHER', 'ADMIN'])
    .withMessage('Role must be STUDENT, TEACHER, or ADMIN'),
  query('status')
    .optional()
    .isIn(['ACTIVE', 'INACTIVE', 'SUSPENDED', 'PENDING_VERIFICATION'])
    .withMessage('Status must be ACTIVE, INACTIVE, SUSPENDED, or PENDING_VERIFICATION')
];

// Routes

// GET /api/users - Get all users (Admin only)
router.get('/', 
  authenticate,
  authorize(['ADMIN']),
  paginationValidation,
  validateRequest,
  userController.getAllUsers
);

// GET /api/users/:id - Get user by ID
router.get('/:id',
  authenticate,
  userIdValidation,
  validateRequest,
  userController.getUserById
);

// POST /api/users - Create new user (Admin only)
router.post('/',
  authenticate,
  authorize(['ADMIN']),
  createUserValidation,
  validateRequest,
  userController.createUser
);

// PUT /api/users/:id - Update user
router.put('/:id',
  authenticate,
  userIdValidation,
  updateUserValidation,
  validateRequest,
  userController.updateUser
);

// POST /api/users/:id/change-password - Change password
router.post('/:id/change-password',
  authenticate,
  userIdValidation,
  changePasswordValidation,
  validateRequest,
  userController.changePassword
);

// PUT /api/users/:id/preferences - Update user preferences
router.put('/:id/preferences',
  authenticate,
  userIdValidation,
  preferencesValidation,
  validateRequest,
  userController.updatePreferences
);

// DELETE /api/users/:id - Delete user (Admin only)
router.delete('/:id',
  authenticate,
  authorize(['ADMIN']),
  userIdValidation,
  validateRequest,
  userController.deleteUser
);

export default router;
</file>

<file path="src/services/auth/jwtService.ts">
import jwt from 'jsonwebtoken';
import { environment } from '../../config/environment';
import { JWTPayload, AuthenticatedUser, AppError } from '../../types';
import { logger } from '../../utils/logger';

class JWTService {
  /**
   * Generate access token
   */
  generateAccessToken(user: AuthenticatedUser): string {
    const payload: JWTPayload = {
      userId: user.id,
      email: user.email,
      role: user.role,
      ...(user.tenantId && { tenantId: user.tenantId })
    };

    return jwt.sign(payload, environment.jwt.secret as string, {
      expiresIn: environment.jwt.expiresIn,
      issuer: 'education-platform',
      audience: 'education-platform-users',
    });
  }

  /**
   * Generate refresh token
   */
  generateRefreshToken(user: AuthenticatedUser): string {
    const payload: JWTPayload = {
      userId: user.id,
      email: user.email,
      role: user.role,
      ...(user.tenantId && { tenantId: user.tenantId })
    };

    return jwt.sign(payload, environment.jwt.refreshSecret as string, {
      expiresIn: environment.jwt.refreshExpiresIn,
      issuer: 'education-platform',
      audience: 'education-platform-refresh',
    });
  }

  /**
   * Generate token pair (access + refresh)
   */
  generateTokenPair(user: AuthenticatedUser): { accessToken: string; refreshToken: string } {
    return {
      accessToken: this.generateAccessToken(user),
      refreshToken: this.generateRefreshToken(user),
    };
  }

  /**
   * Verify access token
   */
  verifyAccessToken(token: string): JWTPayload {
    try {
      const payload = jwt.verify(token, environment.jwt.secret as string, {
        issuer: 'education-platform',
        audience: 'education-platform-users',
      }) as JWTPayload;

      return payload;
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new AppError('Token expired', 401);
      } else if (error instanceof jwt.JsonWebTokenError) {
        throw new AppError('Invalid token', 401);
      } else {
        logger.error('JWT verification error:', error);
        throw new AppError('Token verification failed', 401);
      }
    }
  }

  /**
   * Verify refresh token
   */
  verifyRefreshToken(token: string): JWTPayload {
    try {
      const payload = jwt.verify(token, environment.jwt.refreshSecret as string, {
        issuer: 'education-platform',
        audience: 'education-platform-refresh',
      }) as JWTPayload;

      return payload;
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new AppError('Refresh token expired', 401);
      } else if (error instanceof jwt.JsonWebTokenError) {
        throw new AppError('Invalid refresh token', 401);
      } else {
        logger.error('Refresh token verification error:', error);
        throw new AppError('Refresh token verification failed', 401);
      }
    }
  }

  /**
   * Extract token from Authorization header
   */
  extractTokenFromHeader(authHeader?: string): string | null {
    if (!authHeader) return null;

    const parts = authHeader.split(' ');
    if (parts.length !== 2 || parts[0] !== 'Bearer') {
      return null;
    }

    return parts[1];
  }

  /**
   * Decode token without verification (for debugging)
   */
  decodeToken(token: string): JWTPayload | null {
    try {
      return jwt.decode(token) as JWTPayload;
    } catch (error) {
      logger.error('Token decode error:', error);
      return null;
    }
  }

  /**
   * Get token expiration time
   */
  getTokenExpiration(token: string): Date | null {
    const decoded = this.decodeToken(token);
    if (!decoded?.exp) return null;

    return new Date(decoded.exp * 1000);
  }

  /**
   * Check if token is expired
   */
  isTokenExpired(token: string): boolean {
    const expiration = this.getTokenExpiration(token);
    if (!expiration) return true;

    return expiration < new Date();
  }
}

export const jwtService = new JWTService();
export default jwtService;
</file>

<file path="src/services/AIQuestionService.ts">
import OpenAI from 'openai'
import Anthropic from '@anthropic-ai/sdk'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

interface GenerateQuestionsRequest {
  videoTitle: string
  videoDescription?: string
  content: string
  questionCount?: number
  questionTypes?: ('MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'SHORT_ANSWER')[]
  difficulty?: 'EASY' | 'MEDIUM' | 'HARD'
  provider?: 'OPENAI' | 'CLAUDE'
}

interface GeneratedQuestion {
  type: 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'SHORT_ANSWER'
  question: string
  options?: string[]
  correctAnswer: string
  explanation?: string
  suggestedTimestamp?: number
}

interface AIResponse {
  questions: GeneratedQuestion[]
  milestoneTitle: string
  milestoneDescription?: string
}

export class AIQuestionService {
  private static openai: OpenAI | null = null
  private static anthropic: Anthropic | null = null

  static initialize() {
    // Initialize OpenAI if API key is available
    if (process.env.OPENAI_API_KEY) {
      this.openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY
      })
    }

    // Initialize Claude if API key is available
    if (process.env.ANTHROPIC_API_KEY) {
      this.anthropic = new Anthropic({
        apiKey: process.env.ANTHROPIC_API_KEY
      })
    }
  }

  static async generateQuestions(request: GenerateQuestionsRequest): Promise<AIResponse> {
    const provider = request.provider || this.getPreferredProvider()
    
    switch (provider) {
      case 'OPENAI':
        return this.generateWithOpenAI(request)
      case 'CLAUDE':
        return this.generateWithClaude(request)
      default:
        throw new Error('No AI provider available. Please configure OPENAI_API_KEY or ANTHROPIC_API_KEY.')
    }
  }

  private static getPreferredProvider(): 'OPENAI' | 'CLAUDE' {
    if (this.openai) return 'OPENAI'
    if (this.anthropic) return 'CLAUDE'
    throw new Error('No AI provider configured')
  }

  private static buildPrompt(request: GenerateQuestionsRequest): string {
    const questionTypes = request.questionTypes || ['MULTIPLE_CHOICE', 'TRUE_FALSE', 'SHORT_ANSWER']
    const questionCount = request.questionCount || 3
    const difficulty = request.difficulty || 'MEDIUM'

    return `
You are an expert educational content creator. Based on the video content provided, generate ${questionCount} high-quality interactive questions for students.

Video Information:
- Title: ${request.videoTitle}
- Description: ${request.videoDescription || 'Not provided'}
- Content/Transcript: ${request.content}

Requirements:
1. Generate exactly ${questionCount} questions
2. Question types to include: ${questionTypes.join(', ')}
3. Difficulty level: ${difficulty}
4. Questions should test comprehension, not just recall
5. Each question should be clear and unambiguous
6. For multiple choice, provide 4 options with only one correct answer
7. Include brief explanations for correct answers
8. Suggest appropriate timestamps (in seconds) where these questions might appear in the video

Response format (JSON only):
{
  "milestoneTitle": "Interactive Quiz: [Topic Name]",
  "milestoneDescription": "Brief description of what this milestone covers",
  "questions": [
    {
      "type": "MULTIPLE_CHOICE",
      "question": "Question text here?",
      "options": ["Option A", "Option B", "Option C", "Option D"],
      "correctAnswer": "Option B",
      "explanation": "Brief explanation of why this is correct",
      "suggestedTimestamp": 120
    },
    {
      "type": "TRUE_FALSE",
      "question": "True or false statement?",
      "correctAnswer": "True",
      "explanation": "Explanation here",
      "suggestedTimestamp": 240
    },
    {
      "type": "SHORT_ANSWER",
      "question": "What is the main concept?",
      "correctAnswer": "The main concept",
      "explanation": "Why this answer is correct",
      "suggestedTimestamp": 360
    }
  ]
}

Important: Return only valid JSON. No additional text or markdown formatting.
`
  }

  private static async generateWithOpenAI(request: GenerateQuestionsRequest): Promise<AIResponse> {
    if (!this.openai) {
      throw new Error('OpenAI not initialized')
    }

    try {
      const completion = await this.openai.chat.completions.create({
        model: process.env.OPENAI_MODEL || 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'You are an expert educational content creator. Always respond with valid JSON only.'
          },
          {
            role: 'user',
            content: this.buildPrompt(request)
          }
        ],
        temperature: 0.7,
        max_tokens: 2000
      })

      const content = completion.choices[0]?.message?.content
      if (!content) {
        throw new Error('No response from OpenAI')
      }

      return this.parseAIResponse(content)
    } catch (error) {
      console.error('OpenAI API error:', error)
      throw new Error('Failed to generate questions with OpenAI')
    }
  }

  private static async generateWithClaude(request: GenerateQuestionsRequest): Promise<AIResponse> {
    if (!this.anthropic) {
      throw new Error('Claude not initialized')
    }

    try {
      const message = await this.anthropic.messages.create({
        model: process.env.ANTHROPIC_MODEL || 'claude-3-sonnet-20240229',
        max_tokens: 2000,
        temperature: 0.7,
        messages: [
          {
            role: 'user',
            content: this.buildPrompt(request)
          }
        ]
      })

      const content = message.content[0]?.type === 'text' ? message.content[0].text : ''
      if (!content) {
        throw new Error('No response from Claude')
      }

      return this.parseAIResponse(content)
    } catch (error) {
      console.error('Claude API error:', error)
      throw new Error('Failed to generate questions with Claude')
    }
  }

  private static parseAIResponse(content: string): AIResponse {
    try {
      // Clean up the response to ensure it's valid JSON
      let cleanContent = content.trim()
      
      // Remove markdown code blocks if present
      if (cleanContent.startsWith('```json')) {
        cleanContent = cleanContent.replace(/^```json\s*/, '').replace(/\s*```$/, '')
      } else if (cleanContent.startsWith('```')) {
        cleanContent = cleanContent.replace(/^```\s*/, '').replace(/\s*```$/, '')
      }

      const parsed = JSON.parse(cleanContent)
      
      // Validate the structure
      if (!parsed.questions || !Array.isArray(parsed.questions)) {
        throw new Error('Invalid response structure: questions array missing')
      }

      // Validate each question
      for (const question of parsed.questions) {
        if (!question.type || !question.question || !question.correctAnswer) {
          throw new Error('Invalid question structure')
        }
        
        if (question.type === 'MULTIPLE_CHOICE' && (!question.options || question.options.length < 2)) {
          throw new Error('Multiple choice questions must have at least 2 options')
        }
      }

      return {
        milestoneTitle: parsed.milestoneTitle || 'Interactive Quiz',
        milestoneDescription: parsed.milestoneDescription,
        questions: parsed.questions
      }
    } catch (error) {
      console.error('Failed to parse AI response:', error)
      console.error('Raw content:', content)
      throw new Error('Invalid response format from AI provider')
    }
  }

  // Generate questions for existing milestone
  static async generateQuestionsForMilestone(
    milestoneId: string,
    request: Omit<GenerateQuestionsRequest, 'content'> & { content?: string },
    userId: string
  ): Promise<void> {
    // Get milestone details
    const milestone = await prisma.milestone.findUnique({
      where: { id: milestoneId },
      include: {
        video: {
          include: {
            videoGroup: true
          }
        }
      }
    })

    if (!milestone) {
      throw new Error('Milestone not found')
    }

    // If no content provided, use video title/description
    const content = request.content || `
      Video: ${milestone.video.title}
      Description: ${milestone.video.description || ''}
      Lesson: ${milestone.video.videoGroup.title}
      Lesson Description: ${milestone.video.videoGroup.description || ''}
      
      Please generate questions appropriate for the milestone "${milestone.title}" at ${milestone.timestamp} seconds.
    `

    const generatedContent = await this.generateQuestions({
      ...request,
      videoTitle: milestone.video.title,
      videoDescription: milestone.video.description || undefined,
      content
    })

    // Create questions in the database
    for (const questionData of generatedContent.questions) {
      const question = await prisma.question.create({
        data: {
          milestoneId,
          type: questionData.type,
          text: questionData.question,
          questionData: {
            correctAnswer: questionData.correctAnswer,
            options: questionData.options || []
          },
          explanation: questionData.explanation || null,
          createdById: userId
        }
      })

      // Create options for multiple choice questions
      if (questionData.type === 'MULTIPLE_CHOICE' && questionData.options) {
        const optionData = questionData.options.map((optionText, index) => ({
          questionId: question.id,
          text: optionText,
          isCorrect: optionText === questionData.correctAnswer,
          order: index + 1
        }))

        await prisma.questionOption.createMany({
          data: optionData
        })
      }
    }
  }

  // Generate milestone and questions from content
  static async generateMilestoneWithQuestions(
    videoId: string,
    request: GenerateQuestionsRequest,
    userId: string
  ): Promise<{ milestoneId: string; questionCount: number }> {
    const generatedContent = await this.generateQuestions(request)

    // Create milestone
    const suggestedTimestamp = generatedContent.questions[0]?.suggestedTimestamp || 60
    
    const milestone = await prisma.milestone.create({
      data: {
        videoId,
        timestamp: suggestedTimestamp,
        title: generatedContent.milestoneTitle,
        description: generatedContent.milestoneDescription || null,
        type: 'QUIZ',
        order: 0 // Default order, should be updated based on existing milestones
      }
    })

    // Create questions
    let questionCount = 0
    for (const questionData of generatedContent.questions) {
      const question = await prisma.question.create({
        data: {
          milestoneId: milestone.id,
          type: questionData.type,
          text: questionData.question,
          questionData: {
            correctAnswer: questionData.correctAnswer,
            options: questionData.options || []
          },
          explanation: questionData.explanation || null,
          createdById: userId
        }
      })

      // Create options for multiple choice questions
      if (questionData.type === 'MULTIPLE_CHOICE' && questionData.options) {
        const optionData = questionData.options.map((optionText, index) => ({
          questionId: question.id,
          text: optionText,
          isCorrect: optionText === questionData.correctAnswer,
          order: index + 1
        }))

        await prisma.questionOption.createMany({
          data: optionData
        })
      }

      questionCount++
    }

    return {
      milestoneId: milestone.id,
      questionCount
    }
  }

  static getAvailableProviders(): string[] {
    const providers: string[] = []
    if (this.openai) providers.push('OPENAI')
    if (this.anthropic) providers.push('CLAUDE')
    return providers
  }
}

// Initialize the service
AIQuestionService.initialize()
</file>

<file path="src/services/AnalyticsService.ts">
import { PrismaClient } from '@prisma/client'
import { User } from '../types/auth'

const prisma = new PrismaClient()

interface VideoStats {
  totalViews: number
  uniqueViewers: number
  averageWatchTime: number
  completionRate: number
  totalWatchTime: number
  engagementRate: number
  milestoneStats: {
    totalMilestones: number
    averageQuestionAccuracy: number
    mostDifficultQuestion: string | null
    easiestQuestion: string | null
  }
}

interface ProgressDataPoint {
  timestamp: string
  viewsStarted: number
  viewsCompleted: number
  averageProgress: number
}

interface StudentProgress {
  studentId: string
  studentName: string
  lessonsStarted: number
  lessonsCompleted: number
  totalWatchTime: number
  averageScore: number
  lastActivity: string
  progressByVideo: {
    videoId: string
    videoTitle: string
    progress: number
    completedAt: string | null
    score: number | null
  }[]
}

interface LessonOverview {
  lessonId: string
  lessonTitle: string
  totalVideos: number
  totalStudents: number
  averageCompletion: number
  averageScore: number
  engagementMetrics: {
    dailyViews: number[]
    peakHours: number[]
    dropoffPoints: number[]
  }
  topPerformingVideos: {
    videoId: string
    title: string
    completionRate: number
    averageScore: number
  }[]
}

interface TeacherDashboard {
  totalLessons: number
  totalStudents: number
  totalWatchHours: number
  averageEngagement: number
  recentActivity: {
    type: 'lesson_created' | 'student_completed' | 'question_answered'
    description: string
    timestamp: string
  }[]
  topLessons: {
    lessonId: string
    title: string
    completionRate: number
    studentCount: number
  }[]
}

interface StudentDashboard {
  lessonsEnrolled: number
  lessonsCompleted: number
  totalWatchTime: number
  averageScore: number
  streak: number
  recentProgress: {
    lessonTitle: string
    videoTitle: string
    progress: number
    timestamp: string
  }[]
  achievements: {
    title: string
    description: string
    earnedAt: string
  }[]
}

export class AnalyticsService {
  static async getVideoStats(videoId: string, user: User): Promise<VideoStats> {
    // Check if user has access to video
    const video = await prisma.video.findFirst({
      where: {
        id: videoId,
        OR: [
          { videoGroup: { lesson: { createdById: user.id } } },
          user.role === 'ADMIN' ? {} : {
            videoGroup: {
              OR: [
                { lesson: { status: 'PUBLISHED' } },
                {
                  videos: {
                    some: {
                      studentSessions: {
                        some: { studentId: user.id }
                      }
                    }
                  }
                }
              ]
            }
          }
        ]
      },
      include: {
        videoGroup: true,
        milestones: {
          include: {
            questions: {
              include: {
                _count: {
                  select: { questionAttempts: true }
                }
              }
            }
          }
        }
      }
    })

    if (!video) {
      throw new Error('Video not found')
    }

    // Get session statistics
    const sessions = await prisma.studentSession.findMany({
      where: { videoId },
      include: {
        questionAttempts: true
      }
    })

    const totalViews = sessions.length
    const uniqueViewers = new Set(sessions.map(s => s.studentId)).size
    const completedSessions = sessions.filter(s => s.status === 'COMPLETED')
    const completionRate = totalViews > 0 ? (completedSessions.length / totalViews) * 100 : 0

    // Calculate average watch time
    const totalWatchTimeSeconds = sessions.reduce((sum, session) => sum + (session.sessionData as any)?.totalWatchTime || 0, 0)
    const averageWatchTime = totalViews > 0 ? totalWatchTimeSeconds / totalViews : 0

    // Calculate question statistics
    const allAnswers = sessions.flatMap(s => s.questionAttempts)
    const correctAnswers = allAnswers.filter(a => a.isCorrect).length
    const averageQuestionAccuracy = allAnswers.length > 0 ? (correctAnswers / allAnswers.length) * 100 : 0

    // Find most/least difficult questions
    const questionStats = video.milestones.flatMap(m => m.questions).map(question => {
      const questionAttempts = allAnswers.filter(a => a.questionId === question.id)
      const correctCount = questionAttempts.filter(a => a.isCorrect).length
      const accuracy = questionAttempts.length > 0 ? (correctCount / questionAttempts.length) * 100 : 0
      
      return {
        questionId: question.id,
        question: question.question,
        accuracy
      }
    })

    const sortedByAccuracy = questionStats.sort((a, b) => a.accuracy - b.accuracy)
    const mostDifficultQuestion = sortedByAccuracy[0]?.question || null
    const easiestQuestion = sortedByAccuracy[sortedByAccuracy.length - 1]?.question || null

    // Calculate engagement rate (sessions with at least one interaction)
    const engagedSessions = sessions.filter(s => s.questionAttempts.length > 0 || (s.sessionData as any)?.totalWatchTime || 0 > 30)
    const engagementRate = totalViews > 0 ? (engagedSessions.length / totalViews) * 100 : 0

    return {
      totalViews,
      uniqueViewers,
      averageWatchTime,
      completionRate,
      totalWatchTime: totalWatchTimeSeconds,
      engagementRate,
      milestoneStats: {
        totalMilestones: video.milestones.length,
        averageQuestionAccuracy,
        mostDifficultQuestion,
        easiestQuestion
      }
    }
  }

  static async getVideoProgressData(
    videoId: string, 
    timeRange: string, 
    user: User
  ): Promise<ProgressDataPoint[]> {
    // Check access
    await this.getVideoStats(videoId, user) // This will throw if no access

    const now = new Date()
    let startDate: Date

    switch (timeRange) {
      case 'day':
        startDate = new Date(now.getTime() - 24 * 60 * 60 * 1000)
        break
      case 'week':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
        break
      case 'month':
        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)
        break
      default:
        startDate = new Date(0) // Beginning of time
    }

    const sessions = await prisma.studentSession.findMany({
      where: {
        videoId,
        createdAt: { gte: startDate }
      },
      orderBy: { createdAt: 'asc' }
    })

    // Group sessions by time periods
    const timeGroups = new Map<string, { started: number; completed: number; totalProgress: number; count: number }>()

    sessions.forEach(session => {
      const timeKey = session.createdAt.toISOString().split('T')[0] // Group by day
      const existing = timeGroups.get(timeKey) || { started: 0, completed: 0, totalProgress: 0, count: 0 }
      
      existing.started += 1
      if (session.status === 'COMPLETED') existing.completed += 1
      existing.totalProgress += (session.currentPosition / (session.currentPosition + 1)) * 100 // Avoid division by zero
      existing.count += 1
      
      timeGroups.set(timeKey, existing)
    })

    return Array.from(timeGroups.entries()).map(([timestamp, data]) => ({
      timestamp,
      viewsStarted: data.started,
      viewsCompleted: data.completed,
      averageProgress: data.count > 0 ? data.totalProgress / data.count : 0
    }))
  }

  static async getStudentProgress(
    studentId: string,
    videoGroupId: string | undefined,
    user: User
  ): Promise<StudentProgress> {
    // Check if user can access student data
    if (user.role !== 'ADMIN' && user.id !== studentId) {
      // Teacher can only see students in their lessons
      if (user.role !== 'TEACHER') {
        throw new Error('Access denied')
      }
    }

    const student = await prisma.user.findUnique({
      where: { id: studentId },
      select: {
        id: true,
        firstName: true,
        lastName: true
      }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    // Get student's video sessions
    const whereClause: any = {
      userId: studentId
    }

    if (videoGroupId) {
      whereClause.video = {
        videoGroupId
      }
    } else if (user.role === 'TEACHER') {
      // Teachers can only see sessions for their videos
      whereClause.video = {
        videoGroup: {
          createdBy: user.id
        }
      }
    }

    const sessions = await prisma.studentSession.findMany({
      where: whereClause,
      include: {
        video: {
          include: {
            videoGroup: true
          }
        },
        questionAttempts: true
      },
      orderBy: { lastSeenAt: 'desc' }
    })

    const lessonsStarted = new Set(sessions.map(s => s.video.videoGroupId)).size
    const lessonsCompleted = new Set(
      sessions.filter(s => s.status === 'COMPLETED').map(s => s.video.videoGroupId)
    ).size

    const totalWatchTime = sessions.reduce((sum, s) => sum + (s.sessionData as any)?.totalWatchTime || 0, 0)

    // Calculate average score
    const allAnswers = sessions.flatMap(s => s.questionAttempts)
    const correctAnswers = allAnswers.filter(a => a.isCorrect).length
    const averageScore = allAnswers.length > 0 ? (correctAnswers / allAnswers.length) * 100 : 0

    const lastActivity = sessions.length > 0 
      ? sessions[0].lastSeenAt.toISOString()
      : new Date(0).toISOString()

    const progressByVideo = sessions.map(session => {
      const answers = session.questionAttempts
      const correctCount = answers.filter(a => a.isCorrect).length
      const score = answers.length > 0 ? (correctCount / answers.length) * 100 : null

      return {
        videoId: session.video.id,
        videoTitle: session.video.title,
        progress: session.video.duration 
          ? (session.currentPosition / session.video.duration) * 100 
          : 0,
        completedAt: session.status === 'COMPLETED' ? session.completedAt?.toISOString() || null : null,
        score
      }
    })

    return {
      studentId,
      studentName: `${student.firstName} ${student.lastName}`,
      lessonsStarted,
      lessonsCompleted,
      totalWatchTime,
      averageScore,
      lastActivity,
      progressByVideo
    }
  }

  static async getLessonOverview(lessonId: string, user: User): Promise<LessonOverview> {
    const lesson = await prisma.videoGroup.findFirst({
      where: {
        id: lessonId,
        OR: [
          { createdBy: user.id },
          user.role === 'ADMIN' ? {} : { isPublic: true }
        ]
      },
      include: {
        videos: {
          include: {
            studentSessions: {
              include: {
                questionAttempts: true
              }
            },
            _count: {
              select: { studentSessions: true }
            }
          }
        }
      }
    })

    if (!lesson) {
      throw new Error('Lesson not found')
    }

    const totalVideos = lesson.videos.length
    const allSessions = lesson.videos.flatMap(v => v.studentSessions)
    const uniqueStudents = new Set(allSessions.map(s => s.studentId)).size

    // Calculate completion metrics
    const completedSessions = allSessions.filter(s => s.status === 'COMPLETED')
    const averageCompletion = allSessions.length > 0 
      ? (completedSessions.length / allSessions.length) * 100 
      : 0

    // Calculate average score
    const allAnswers = allSessions.flatMap(s => s.questionAttempts)
    const correctAnswers = allAnswers.filter(a => a.isCorrect).length
    const averageScore = allAnswers.length > 0 ? (correctAnswers / allAnswers.length) * 100 : 0

    // Calculate engagement metrics (simplified)
    const dailyViews = Array(7).fill(0) // Last 7 days
    const peakHours = Array(24).fill(0) // 24 hours
    const dropoffPoints = Array(10).fill(0) // 10 segments of video

    // Top performing videos
    const topPerformingVideos = lesson.videos
      .map(video => {
        const studentSessions = video.studentSessions
        const completed = studentSessions.filter(s => s.status === 'COMPLETED').length
        const completionRate = studentSessions.length > 0 ? (completed / studentSessions.length) * 100 : 0
        
        const videoAnswers = studentSessions.flatMap(s => s.questionAttempts)
        const videoCorrect = videoAnswers.filter(a => a.isCorrect).length
        const videoScore = videoAnswers.length > 0 ? (videoCorrect / videoAnswers.length) * 100 : 0

        return {
          videoId: video.id,
          title: video.title,
          completionRate,
          averageScore: videoScore
        }
      })
      .sort((a, b) => b.completionRate - a.completionRate)
      .slice(0, 5)

    return {
      lessonId,
      lessonTitle: lesson.title,
      totalVideos,
      totalStudents: uniqueStudents,
      averageCompletion,
      averageScore,
      engagementMetrics: {
        dailyViews,
        peakHours,
        dropoffPoints
      },
      topPerformingVideos
    }
  }

  static async getTeacherDashboard(user: User): Promise<TeacherDashboard> {
    if (user.role !== 'TEACHER' && user.role !== 'ADMIN') {
      throw new Error('Access denied')
    }

    const lessons = await prisma.videoGroup.findMany({
      where: {
        OR: [
          { createdBy: user.id },
          user.role === 'ADMIN' ? {} : { id: 'never-match' } // Admins see all, teachers see only theirs
        ]
      },
      include: {
        videos: {
          include: {
            studentSessions: true
          }
        }
      }
    })

    const totalLessons = lessons.length
    const allSessions = lessons.flatMap(l => l.videos.flatMap(v => v.studentSessions))
    const totalStudents = new Set(allSessions.map(s => s.studentId)).size
    const totalWatchHours = allSessions.reduce((sum, s) => sum + (s.sessionData as any)?.totalWatchTime || 0, 0) / 3600

    // Calculate engagement
    const engagedSessions = allSessions.filter(s => (s.sessionData as any)?.totalWatchTime || 0 > 30)
    const averageEngagement = allSessions.length > 0 
      ? (engagedSessions.length / allSessions.length) * 100 
      : 0

    // Recent activity (simplified)
    const recentActivity = [
      {
        type: 'lesson_created' as const,
        description: 'New lesson created',
        timestamp: new Date().toISOString()
      }
    ]

    // Top lessons
    const topLessons = lessons
      .map(lesson => {
        const lessonSessions = lesson.videos.flatMap(v => v.studentSessions)
        const completed = lessonSessions.filter(s => s.status === 'COMPLETED').length
        const completionRate = lessonSessions.length > 0 ? (completed / lessonSessions.length) * 100 : 0
        const studentCount = new Set(lessonSessions.map(s => s.studentId)).size

        return {
          lessonId: lesson.id,
          title: lesson.title,
          completionRate,
          studentCount
        }
      })
      .sort((a, b) => b.completionRate - a.completionRate)
      .slice(0, 5)

    return {
      totalLessons,
      totalStudents,
      totalWatchHours,
      averageEngagement,
      recentActivity,
      topLessons
    }
  }

  static async getStudentDashboard(user: User): Promise<StudentDashboard> {
    const sessions = await prisma.studentSession.findMany({
      where: { studentId: user.id },
      include: {
        video: {
          include: {
            videoGroup: true
          }
        },
        questionAttempts: true
      },
      orderBy: { lastSeenAt: 'desc' }
    })

    const lessonsEnrolled = new Set(sessions.map(s => s.video.videoGroupId)).size
    const lessonsCompleted = new Set(
      sessions.filter(s => s.status === 'COMPLETED').map(s => s.video.videoGroupId)
    ).size

    const totalWatchTime = sessions.reduce((sum, s) => sum + (s.sessionData as any)?.totalWatchTime || 0, 0)

    // Calculate average score
    const allAnswers = sessions.flatMap(s => s.questionAttempts)
    const correctAnswers = allAnswers.filter(a => a.isCorrect).length
    const averageScore = allAnswers.length > 0 ? (correctAnswers / allAnswers.length) * 100 : 0

    // Calculate streak (simplified - days with activity)
    const activeDays = new Set(
      sessions.map(s => s.lastSeenAt.toISOString().split('T')[0])
    ).size
    const streak = Math.min(activeDays, 30) // Cap at 30 days

    // Recent progress
    const recentProgress = sessions.slice(0, 5).map(session => ({
      lessonTitle: session.video.videoGroup.title,
      videoTitle: session.video.title,
      progress: session.video.duration 
        ? (session.currentPosition / session.video.duration) * 100 
        : 0,
      timestamp: session.lastSeenAt.toISOString()
    }))

    // Achievements (simplified)
    const achievements = []
    if (lessonsCompleted > 0) {
      achievements.push({
        title: 'First Lesson Complete',
        description: 'Completed your first lesson',
        earnedAt: new Date().toISOString()
      })
    }
    if (averageScore > 80) {
      achievements.push({
        title: 'High Scorer',
        description: 'Achieved over 80% average score',
        earnedAt: new Date().toISOString()
      })
    }

    return {
      lessonsEnrolled,
      lessonsCompleted,
      totalWatchTime,
      averageScore,
      streak,
      recentProgress,
      achievements
    }
  }

  static async getEngagementHeatmap(videoId: string, user: User) {
    // Check access first
    await this.getVideoStats(videoId, user)

    const sessions = await prisma.studentSession.findMany({
      where: { videoId },
      // No milestone progress relation needed for heatmap
    })

    // Create engagement heatmap data (simplified)
    const heatmapData = Array(100).fill(0).map((_, index) => {
      const timePoint = (index / 99) * 100 // Percentage through video
      const engagement = sessions.filter(session => {
        const sessionProgress = session.video?.duration 
          ? (session.currentPosition / session.video.duration) * 100 
          : 0
        return sessionProgress >= timePoint
      }).length

      return {
        timePoint,
        engagement: sessions.length > 0 ? (engagement / sessions.length) * 100 : 0
      }
    })

    return heatmapData
  }

  static async getQuestionPerformance(milestoneId: string, user: User) {
    const milestone = await prisma.milestone.findFirst({
      where: {
        id: milestoneId,
        video: {
          OR: [
            { uploadedBy: user.id },
            { videoGroup: { createdBy: user.id } },
            user.role === 'ADMIN' ? {} : {
              videoGroup: {
                OR: [
                  { isPublic: true },
                  {
                    videos: {
                      some: {
                        studentSessions: {
                          some: { studentId: user.id }
                        }
                      }
                    }
                  }
                ]
              }
            }
          ]
        }
      },
      include: {
        questions: {
          include: {
            questionAttempts: true
          }
        }
      }
    })

    if (!milestone) {
      throw new Error('Milestone not found')
    }

    const performance = milestone.questions.map(question => {
      const answers = question.questionAttempts
      const correctCount = answers.filter(a => a.isCorrect).length
      const accuracy = answers.length > 0 ? (correctCount / answers.length) * 100 : 0

      return {
        questionId: question.id,
        question: question.question,
        type: question.type,
        totalAnswers: answers.length,
        correctAnswers: correctCount,
        accuracy,
        averageTime: 0 // Could calculate from timestamps
      }
    })

    return {
      milestoneId,
      milestoneTitle: milestone.title,
      questions: performance
    }
  }
}
</file>

<file path="src/index.ts">
import express from 'express';
import helmet from 'helmet';
import morgan from 'morgan';
import compression from 'compression';
import { createServer } from 'http';
import { Server } from 'socket.io';
import dotenv from 'dotenv';

// Import configurations
import { environment } from './config/environment';
import { prisma } from './config/database';
import { logger } from './utils/logger';

// Import middleware
import { errorHandler } from './middleware/error/errorHandler';
import { notFoundHandler } from './middleware/error/notFoundHandler';
import { requestLogger } from './middleware/logger/requestLogger';
import { corsMiddleware } from './middleware/security/corsMiddleware';
import { securityMiddleware } from './middleware/security/securityMiddleware';
import { rateLimitMiddleware } from './middleware/security/rateLimitMiddleware';

// Import routes
import routes from './routes';

// Load environment variables
dotenv.config();

// Create Express app
const app = express();
const server = createServer(app);

// Create Socket.IO server
const io = new Server(server, {
  cors: {
    origin: environment.frontend.url,
    methods: ['GET', 'POST'],
    credentials: true
  }
});

// Trust proxy if behind reverse proxy
if (environment.server.nodeEnv === 'production') {
  app.set('trust proxy', 1);
}

// Apply security middleware
app.use(helmet({
  crossOriginResourcePolicy: false, // Disable to allow cross-origin video streaming
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:", "blob:"],
      scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
      connectSrc: ["'self'", "https:", "wss:", "ws:", "http://localhost:*"],
      mediaSrc: ["'self'", "blob:", "https:", "http://localhost:*"],
      objectSrc: ["'none'"],
      frameSrc: ["'none'"],
      baseUri: ["'self'"],
      formAction: ["'self'"],
      frameAncestors: ["'self'"],
      scriptSrcAttr: ["'none'"]
    }
  }
}));
app.use(corsMiddleware);
app.use(securityMiddleware);

// Apply rate limiting
app.use(rateLimitMiddleware);

// Apply general middleware
app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Apply logging middleware
if (environment.server.nodeEnv !== 'test') {
  app.use(morgan('combined', { 
    stream: { 
      write: (message: string) => logger.info(message.trim()) 
    } 
  }));
}
app.use(requestLogger);

// Health check endpoint
app.get('/health', (_req, res) => {
  res.status(200).json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    environment: environment.server.nodeEnv,
    version: process.env.npm_package_version || '1.0.0'
  });
});

// API routes
const API_PREFIX = '/api/v1';
app.use(API_PREFIX, routes);

// Error handling middleware (must be last)
app.use(notFoundHandler);
app.use(errorHandler);

// Graceful shutdown handler
const gracefulShutdown = async (signal: string) => {
  logger.info(`Received ${signal}, shutting down gracefully`);
  
  server.close(() => {
    logger.info('HTTP server closed');
    
    // Close database connections
    prisma.$disconnect();
    
    // Close Socket.IO server
    io.close(() => {
      logger.info('Socket.IO server closed');
      process.exit(0);
    });
  });
  
  // Force close after 10 seconds
  setTimeout(() => {
    logger.error('Could not close connections in time, forcefully shutting down');
    process.exit(1);
  }, 10000);
};

// Listen for termination signals
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Start server
const startServer = async () => {
  try {
    logger.info('Starting server...');

    // Start server
    const port = environment.server.port;
    server.listen(port, () => {
      logger.info(`Server running on port ${port} in ${environment.server.nodeEnv} mode`);
      logger.info(`Health check available at http://localhost:${port}/health`);
      logger.info(`API endpoints available at http://localhost:${port}${API_PREFIX}`);
      logger.info(`🚀 Backend running locally with hot reload enabled!`);
    });

  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
};

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
  // Don't exit in development to keep server running
  if (environment.server.nodeEnv === 'production') {
    process.exit(1);
  }
});

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception thrown:', error);
  process.exit(1);
});

// Start the server
if (require.main === module) {
  startServer();
}

export { app, io };
</file>

<file path="CLAUDE.md">
# Interactive Learning Platform - Multi-Agent Development System

This project uses a sophisticated multi-agent coding architecture for educational technology development. Claude Code can operate in different specialized agent modes for focused development tasks.

## Multi-Agent Architecture

The system consists of 7 specialized agents that work in coordination:

1. **Agent Lead** (`.claude/agents/agent-lead.txt`) - Orchestration layer that manages all other agents
2. **Backend Agent** (`.claude/agents/backend-agent.txt`) - Node.js/TypeScript API development  
3. **Frontend Agent** (`.claude/agents/frontend-agent.txt`) - React/TypeScript UI development
4. **Database Agent** (`.claude/agents/database-agent.txt`) - PostgreSQL schema and optimization
5. **Testing Agent** (`.claude/agents/testing-agent.txt`) - Comprehensive testing strategies
6. **DevOps Agent** (`.claude/agents/devops-agent.txt`) - Deployment, Docker, and cloud infrastructure
7. **Docs Writer Agent** (`.claude/agents/docs-writer-agent.txt`) - Documentation and guides

## Agent Invocation Protocol

When working with multiple agents, use this format:
```
@[AGENT_NAME] - TASK: [specific task]
CONTEXT: [relevant background]
DEPENDENCIES: [what this task depends on]
DELIVERABLES: [expected outputs]
PRIORITY: [high/medium/low]
```

## Platform Overview

Interactive Learning Platform built with:
- **Backend**: Node.js/TypeScript with Express.js
- **Frontend**: React/TypeScript with interactive video components
- **Database**: PostgreSQL with educational data modeling
- **Storage**: Google Cloud Storage for video content
- **AI Integration**: Multi-provider (OpenAI, Claude) question generation
- **Authentication**: JWT with role-based access (student/teacher/admin)

## Key Features

- Interactive video player with milestone-based learning
- AI-generated questions with teacher approval workflows  
- Multi-role dashboards and progress tracking
- Cross-device session persistence
- Educational compliance (GDPR, accessibility)
- Real-time analytics and reporting

## Development Commands

```bash
# Install dependencies
npm install

# Development server
npm run dev

# Build for production  
npm run build

# Run tests
npm test

# Database migrations
npm run db:migrate

# Code quality checks
npm run lint
npm run typecheck
```

## Frontend Development with Visual Debugging

### Puppeteer-Based Screenshot Workflow

The platform includes an integrated Puppeteer workflow for visual debugging and frontend development. This allows Claude Code to capture screenshots iteratively, identify visual issues, and debug frontend problems effectively.

#### Screenshot Commands

```bash
# Capture full page screenshot
npx tsx scripts/frontend/screenshot.ts capture http://localhost:3001

# Capture specific element
npx tsx scripts/frontend/screenshot.ts element '.video-player' http://localhost:3001

# Capture multiple viewports (desktop, tablet, mobile)
npx tsx scripts/frontend/screenshot.ts multi

# Interactive debug mode with metrics
npx tsx scripts/frontend/screenshot.ts debug http://localhost:3001

# Test form interactions
npx tsx scripts/frontend/screenshot.ts form http://localhost:3001/login
```

#### Frontend Debug Helper

```bash
# Quick frontend debugging
./scripts/frontend/debug-frontend.sh capture     # Screenshot current state
./scripts/frontend/debug-frontend.sh element '.error-message'  # Capture specific element
./scripts/frontend/debug-frontend.sh responsive  # Test all viewports
./scripts/frontend/debug-frontend.sh debug      # Full debug analysis
```

#### Visual Debugging Workflow

When debugging frontend issues:

1. **Initial State Capture**: Take a screenshot to see current visual state
2. **Element Inspection**: Capture specific elements showing issues
3. **Responsive Testing**: Verify layout across different screen sizes
4. **Iterative Debugging**: Make changes, capture new screenshots, compare
5. **Form Testing**: Fill forms programmatically and capture states

#### Key Benefits

- **Visual Verification**: See exactly what users see without manual inspection
- **Cross-Device Testing**: Automatically test mobile, tablet, and desktop views
- **Error Detection**: Capture error states and console logs
- **Performance Metrics**: Get page load times and rendering metrics
- **Automated Form Testing**: Test form submissions and validation states

#### Integration with Development

The screenshot tool automatically:
- Creates a `screenshots/` directory for all captures
- Names files with timestamps for easy tracking
- Outputs file paths for Claude Code to read and analyze
- Captures console logs and network errors
- Supports custom viewports and wait conditions

**Note**: Frontend runs on port 3001 by default (not 5173)

## Troubleshooting & Common Issues

**📋 For recurring development issues, see:** [`docs/COMMON_ERRORS.md`](./docs/COMMON_ERRORS.md)

This document catalogs common errors and their solutions, including:
- BigInt serialization issues in API responses
- Prisma query optimization problems
- Authentication and CORS issues
- Database migration challenges
- Memory leaks and performance issues

Always check this guide when encountering errors to save debugging time.

## Agent Specializations

### Backend Agent Focus
- Educational APIs and authentication systems
- Video milestone tracking and streaming optimization
- AI integration layer with configurable providers
- Multi-tenant architecture with role-based permissions

### Frontend Agent Focus  
- Interactive video player with educational overlays
- Role-based dashboards (student/teacher/admin)
- Mobile-responsive educational interfaces
- Real-time progress tracking and analytics displays

### Database Agent Focus
- Educational data modeling (users, lessons, progress)
- Video metadata and milestone optimization
- Multi-tenant data isolation patterns
- Learning analytics and reporting schemas

### Testing Agent Focus
- Video interaction and milestone validation
- Educational workflow testing (complete learning paths)
- Multi-role authorization and access control testing
- Performance testing for concurrent video streaming

### DevOps Agent Focus
- Docker containerization for educational platform services
- Local development environment automation with Docker Compose
- Google Cloud Platform deployment and infrastructure as code
- CI/CD pipelines with automated testing and security scanning
- Monitoring and observability for educational platform health
- Database migration automation and disaster recovery procedures

### Docs Writer Agent Focus
- User guides for teachers, students, and administrators
- Developer documentation for TypeScript/React/Node.js stack
- Educational compliance and accessibility guides
- API documentation and deployment procedures

## Development Plan & Orchestration

### **Phase 1: Foundation (Database + Backend)**
Priority: HIGH | Duration: 2-3 sprints

**Database Agent Tasks:**
- Design PostgreSQL schema for multi-role educational platform (users, lessons, videos, milestones, questions, progress)
- Implement multi-tenant data isolation with role-based access patterns
- Create migration scripts with zero-downtime deployment strategy
- Optimize indexes for video milestone lookups and progress queries

**Backend Agent Tasks:**
- Implement JWT authentication with role-based authorization middleware
- Build core APIs for user management (student/teacher/admin roles)
- Integrate Google Cloud Storage for video upload and metadata management
- Create video milestone tracking and session persistence APIs

**Dependencies:** Database schema → Backend APIs → Frontend contracts

### **Phase 2: Interactive Learning (Frontend + AI Integration)**
Priority: HIGH | Duration: 3-4 sprints

**Frontend Agent Tasks:**
- Build interactive video player with milestone pause/resume functionality
- Create role-based dashboards (student progress, teacher analytics, admin management)
- Implement question overlay components with multiple question types
- Develop responsive interfaces for cross-device learning continuity

**Backend Agent Tasks:**
- Implement multi-AI provider abstraction layer (OpenAI, Claude)
- Create question generation workflow with teacher approval process
- Build real-time progress tracking and analytics endpoints
- Optimize video streaming performance for concurrent users

**Dependencies:** Core APIs → Video player → AI integration → Question workflows

### **Phase 3: Quality Assurance, Deployment & Documentation**
Priority: MEDIUM | Duration: 2-3 sprints

**Testing Agent Tasks:**
- Create comprehensive test suites for educational workflows (video → questions → progress)
- Implement multi-role authorization and access control testing
- Build performance tests for concurrent video streaming and user sessions
- Validate AI integration and question generation quality

**DevOps Agent Tasks:**
- Create Docker containerization for Node.js backend, React frontend, PostgreSQL database
- Build local development environment with Docker Compose and hot-reload
- Design Google Cloud Platform infrastructure for production deployment
- Implement CI/CD pipelines with automated testing and deployment workflows
- Set up monitoring, logging, and alerting for educational platform observability

**Docs Writer Agent Tasks:**
- Create user guides for teachers (content creation, video annotation, question approval)
- Write student tutorials for interactive learning and progress tracking
- Document admin interfaces for user management and system configuration
- Produce developer guides for TypeScript/React/Node.js/PostgreSQL stack
- Document deployment procedures and infrastructure setup

**Dependencies:** Feature completion → Testing validation → Containerization → Deployment → Documentation

### **Critical Integration Points**

1. **Video + AI Workflow**: Frontend player → Backend milestone detection → AI question generation → Teacher approval
2. **Multi-Tenant Architecture**: Database isolation → Backend authorization → Frontend role-based UI
3. **Real-Time Analytics**: Database tracking → Backend APIs → Frontend dashboards
4. **Cross-Device Sessions**: Database persistence → Backend session management → Frontend state sync

### **Quality Gates & Risk Mitigation**

**Before Phase 2:**
- Database schema validated with sample data
- Authentication system tested with all roles
- Google Cloud Storage integration confirmed

**Before Phase 3:**
- Interactive video player functional with milestone detection
- AI question generation workflow operational
- Multi-role dashboards displaying real-time data

**Before Production:**
- All educational workflows tested end-to-end
- Performance benchmarks met for concurrent users
- Security audit completed for educational data protection

## Multi-Agent Coordination Protocol

The Agent Lead coordinates all specialized agents through:
- **Requirement Analysis**: Break down user requests into atomic, agent-specific tasks
- **Dependency Mapping**: Identify task relationships and execution order across agents
- **Parallel Coordination**: Execute independent tasks simultaneously for maximum efficiency
- **Integration Management**: Coordinate handoffs between agents (Database → Backend → Frontend)
- **Quality Validation**: Ensure deliverables work together before proceeding to next phase
- **Progress Tracking**: Monitor task completion across all agents with clear milestone indicators

### **Agent Invocation Examples**

**Complex Feature Development:**
```
@database-agent - TASK: Add lesson prerequisite system to schema
@backend-agent - TASK: Implement prerequisite validation APIs
@frontend-agent - TASK: Create prerequisite selection UI for teachers
@testing-agent - TASK: Validate prerequisite enforcement workflows
```

**Performance Optimization:**
```
@database-agent - TASK: Optimize video metadata queries with indexes
@backend-agent - TASK: Implement video streaming cache layer
@frontend-agent - TASK: Add progressive video loading
@testing-agent - TASK: Load test concurrent video streaming
@devops-agent - TASK: Configure CDN and auto-scaling for video delivery
```

**Deployment Workflow:**
```
@devops-agent - TASK: Create Docker containers for all services
@database-agent - TASK: Provide database migration scripts
@backend-agent - TASK: Configure environment variables and health checks
@frontend-agent - TASK: Build optimized production assets
@testing-agent - TASK: Validate deployment in staging environment
```

Use the Agent Lead to orchestrate complex features requiring multiple agents, ensuring proper sequencing, integration validation, and quality gates throughout development.
</file>

<file path="package.json">
{
  "name": "interactive-learning-platform",
  "version": "1.0.0",
  "description": "Interactive video-based learning system with AI-generated questions",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "dev": "prisma generate --schema=database/prisma/schema.prisma && tsx watch src/index.ts",
    "start": "node dist/index.js",
    "db:generate": "prisma generate --schema=database/prisma/schema.prisma",
    "db:migrate": "prisma migrate dev --schema=database/prisma/schema.prisma",
    "db:deploy": "prisma migrate deploy --schema=database/prisma/schema.prisma",
    "db:studio": "prisma studio --schema=database/prisma/schema.prisma",
    "db:seed": "tsx database/seeds/001_initial_data.ts",
    "db:reset": "prisma migrate reset --force --schema=database/prisma/schema.prisma",
    "db:push": "prisma db push --schema=database/prisma/schema.prisma",
    "type-check": "tsc --noEmit",
    "lint": "eslint . --ext .ts,.tsx",
    "lint:fix": "eslint . --ext .ts,.tsx --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:api": "bash scripts/testing/test-api.sh"
  },
  "prisma": {
    "seed": "tsx database/seeds/001_initial_data.ts",
    "schema": "database/prisma/schema.prisma"
  },
  "keywords": [
    "education",
    "video-learning",
    "interactive",
    "ai-questions",
    "postgresql",
    "prisma",
    "typescript"
  ],
  "author": "Interactive Learning Platform Team",
  "license": "MIT",
  "dependencies": {
    "@anthropic-ai/sdk": "^0.13.1",
    "@google-cloud/storage": "^7.7.0",
    "@prisma/client": "^5.7.0",
    "@types/uuid": "^10.0.0",
    "axios": "^1.6.2",
    "bcrypt": "^5.1.1",
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^7.1.5",
    "express-validator": "^7.0.1",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "node-cron": "^3.0.3",
    "openai": "^4.24.1",
    "redis": "^4.6.12",
    "socket.io": "^4.7.4",
    "uuid": "^11.1.0",
    "winston": "^3.11.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/compression": "^1.7.5",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jest": "^29.5.8",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/morgan": "^1.9.9",
    "@types/multer": "^1.4.11",
    "@types/node": "^20.10.0",
    "@types/node-cron": "^3.0.11",
    "@types/supertest": "^2.0.16",
    "@typescript-eslint/eslint-plugin": "^6.13.0",
    "@typescript-eslint/parser": "^6.13.0",
    "eslint": "^8.54.0",
    "jest": "^29.7.0",
    "nodemon": "^3.0.2",
    "prisma": "^5.7.0",
    "puppeteer": "^24.16.0",
    "supertest": "^6.3.3",
    "tsx": "^4.6.0",
    "typescript": "^5.3.0"
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}
</file>

<file path="frontend/src/components/teacher/AIQuestionGenerator.tsx">
import React, { useState, useEffect } from 'react'
import { aiService } from '../../services/ai'
import { debug } from '../../utils/debug'
import type { GenerateQuestionsRequest, GeneratedQuestion } from '../../services/ai'
import type { Video, Milestone, Question } from '../../services/video'
import { useVideoStateManager } from '../../contexts/VideoStateContext'

interface AIQuestionGeneratorProps {
  video: Video
  milestone?: Milestone
  onQuestionsGenerated: () => void
  onClose: () => void
}

export function AIQuestionGenerator({ 
  video, 
  milestone, 
  onQuestionsGenerated, 
  onClose 
}: AIQuestionGeneratorProps) {
  const manager = useVideoStateManager()
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [availableProviders, setAvailableProviders] = useState<string[]>([])
  const [hasAISupport, setHasAISupport] = useState(false)
  const [generatedQuestions, setGeneratedQuestions] = useState<GeneratedQuestion[]>([])
  const [showPreview, setShowPreview] = useState(false)
  
  const [formData, setFormData] = useState<GenerateQuestionsRequest>({
    videoTitle: video.title,
    videoDescription: video.description || undefined,
    content: '',
    questionCount: 3,
    questionTypes: ['MULTIPLE_CHOICE', 'TRUE_FALSE', 'SHORT_ANSWER'],
    difficulty: 'MEDIUM',
    provider: undefined
  })

  useEffect(() => {
    loadProviders()
  }, [])

  const loadProviders = async () => {
    try {
      const response = await aiService.getProviders()
      setAvailableProviders(response.providers)
      setHasAISupport(response.hasAISupport)
      
      // Set default provider
      if (response.providers.length > 0) {
        setFormData(prev => ({
          ...prev,
          provider: response.providers[0] as 'OPENAI' | 'CLAUDE'
        }))
      }
    } catch (error) {
      debug.error('Failed to load AI providers:', error)
      setError('Failed to load AI configuration')
    }
  }

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target
    setFormData(prev => ({
      ...prev,
      [name]: name === 'questionCount' ? parseInt(value) || 1 : value
    }))
  }

  const handleQuestionTypesChange = (type: 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'SHORT_ANSWER') => {
    setFormData(prev => ({
      ...prev,
      questionTypes: prev.questionTypes?.includes(type)
        ? prev.questionTypes.filter(t => t !== type)
        : [...(prev.questionTypes || []), type]
    }))
  }

  const handleGenerate = async () => {
    if (!formData.content.trim()) {
      setError('Content is required to generate questions')
      return
    }

    if (!formData.questionTypes || formData.questionTypes.length === 0) {
      setError('At least one question type must be selected')
      return
    }

    setLoading(true)
    setError(null)

    try {
      const result = await aiService.generateQuestions(formData)
      setGeneratedQuestions(result.questions)
      setShowPreview(true)
    } catch (err) {
      debug.error('Error generating questions:', err)
      const message = err instanceof Error ? err.message : 'Failed to generate questions'
      setError(message)
    } finally {
      setLoading(false)
    }
  }

  const handleApplyQuestions = async () => {
    if (!milestone) return

    setLoading(true)
    setError(null)

    try {
      const result = await aiService.generateQuestionsForMilestone(milestone.id, {
        content: formData.content,
        questionCount: formData.questionCount,
        questionTypes: formData.questionTypes,
        difficulty: formData.difficulty,
        provider: formData.provider
      })

      // If we have the generated questions, add them through VideoStateManager
      if (result && 'questions' in result && Array.isArray(result.questions)) {
        const questions = result.questions as Question[]
        await manager.addQuestions(video.id, milestone.id, questions)
      }

      onQuestionsGenerated()
    } catch (err) {
      debug.error('Error applying questions:', err)
      const message = err instanceof Error ? err.message : 'Failed to apply questions'
      setError(message)
    } finally {
      setLoading(false)
    }
  }

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose()
    }
  }

  if (!hasAISupport) {
    return (
      <div 
        className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
        onClick={handleBackdropClick}
      >
        <div className="bg-white rounded-lg max-w-md w-full">
          <div className="p-6 text-center">
            <div className="w-12 h-12 mx-auto mb-4 text-gray-400">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
              </svg>
            </div>
            <h3 className="text-lg font-semibold text-gray-900 mb-2">AI Not Available</h3>
            <p className="text-gray-600 mb-6">
              AI question generation is not available. Please contact your administrator to configure AI providers.
            </p>
            <button onClick={onClose} className="btn-primary">
              Close
            </button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div 
      className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
      onClick={handleBackdropClick}
    >
      <div className="bg-white rounded-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto">
        <div className="p-6">
          {/* Header */}
          <div className="flex items-center justify-between mb-6">
            <div>
              <h2 className="text-xl font-bold text-gray-900">AI Question Generator</h2>
              <p className="text-sm text-gray-600 mt-1">
                Generate interactive questions using AI for: {video.title}
                {milestone && ` - ${milestone.title}`}
              </p>
            </div>
            <button
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 transition-colors"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>

          {error && (
            <div className="bg-red-50 border border-red-200 rounded-md p-4 mb-6">
              <div className="flex">
                <svg className="w-5 h-5 text-red-400 mt-0.5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                </svg>
                <p className="text-red-700">{error}</p>
              </div>
            </div>
          )}

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* Configuration */}
            <div className="space-y-6">
              <div>
                <h3 className="text-lg font-semibold text-gray-900 mb-4">Configuration</h3>
                
                {/* AI Provider */}
                <div className="mb-4">
                  <label htmlFor="provider" className="block text-sm font-medium text-gray-700 mb-2">
                    AI Provider
                  </label>
                  <select
                    id="provider"
                    name="provider"
                    value={formData.provider || ''}
                    onChange={handleInputChange}
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  >
                    {availableProviders.map(provider => (
                      <option key={provider} value={provider}>
                        {provider === 'OPENAI' ? 'OpenAI GPT' : 'Anthropic Claude'}
                      </option>
                    ))}
                  </select>
                </div>

                {/* Question Count */}
                <div className="mb-4">
                  <label htmlFor="questionCount" className="block text-sm font-medium text-gray-700 mb-2">
                    Number of Questions
                  </label>
                  <input
                    type="number"
                    id="questionCount"
                    name="questionCount"
                    value={formData.questionCount}
                    onChange={handleInputChange}
                    min="1"
                    max="10"
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  />
                </div>

                {/* Difficulty */}
                <div className="mb-4">
                  <label htmlFor="difficulty" className="block text-sm font-medium text-gray-700 mb-2">
                    Difficulty Level
                  </label>
                  <select
                    id="difficulty"
                    name="difficulty"
                    value={formData.difficulty}
                    onChange={handleInputChange}
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  >
                    <option value="EASY">Easy</option>
                    <option value="MEDIUM">Medium</option>
                    <option value="HARD">Hard</option>
                  </select>
                </div>

                {/* Question Types */}
                <div className="mb-4">
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Question Types
                  </label>
                  <div className="space-y-2">
                    {[
                      { key: 'MULTIPLE_CHOICE', label: 'Multiple Choice' },
                      { key: 'TRUE_FALSE', label: 'True/False' },
                      { key: 'SHORT_ANSWER', label: 'Short Answer' }
                    ].map(({ key, label }) => (
                      <label key={key} className="flex items-center">
                        <input
                          type="checkbox"
                          checked={formData.questionTypes?.includes(key as QuestionFormData['questionTypes'][number]) || false}
                          onChange={() => handleQuestionTypesChange(key as QuestionFormData['questionTypes'][number])}
                          className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                        />
                        <span className="ml-2 text-sm text-gray-700">{label}</span>
                      </label>
                    ))}
                  </div>
                </div>

                {/* Content */}
                <div>
                  <label htmlFor="content" className="block text-sm font-medium text-gray-700 mb-2">
                    Video Content/Transcript *
                  </label>
                  <textarea
                    id="content"
                    name="content"
                    value={formData.content}
                    onChange={handleInputChange}
                    placeholder="Paste the video transcript, key points, or content that questions should be based on..."
                    rows={8}
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  />
                  <p className="text-xs text-gray-500 mt-1">
                    The AI will use this content to generate relevant questions
                  </p>
                </div>
              </div>

              <div className="flex justify-end space-x-3">
                <button
                  type="button"
                  onClick={onClose}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  onClick={handleGenerate}
                  disabled={loading || !formData.content.trim()}
                  className={`btn-primary ${loading ? 'opacity-50 cursor-not-allowed' : ''}`}
                >
                  {loading ? 'Generating...' : 'Generate Questions'}
                </button>
              </div>
            </div>

            {/* Preview */}
            <div>
              {showPreview && generatedQuestions.length > 0 && (
                <div>
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="text-lg font-semibold text-gray-900">
                      Generated Questions ({generatedQuestions.length})
                    </h3>
                    {milestone && (
                      <button
                        onClick={handleApplyQuestions}
                        disabled={loading}
                        className={`btn-primary ${loading ? 'opacity-50 cursor-not-allowed' : ''}`}
                      >
                        {loading ? 'Adding...' : 'Add to Milestone'}
                      </button>
                    )}
                  </div>

                  <div className="space-y-4 max-h-96 overflow-y-auto">
                    {generatedQuestions.map((question, index) => (
                      <div key={index} className="border border-gray-200 rounded-lg p-4">
                        <div className="flex items-center justify-between mb-2">
                          <span className="text-sm font-medium text-gray-900">Q{index + 1}</span>
                          <span className={`px-2 py-1 rounded-full text-xs font-medium ${
                            question.type === 'MULTIPLE_CHOICE' 
                              ? 'bg-blue-100 text-blue-700'
                              : question.type === 'TRUE_FALSE'
                              ? 'bg-green-100 text-green-700'
                              : 'bg-purple-100 text-purple-700'
                          }`}>
                            {question.type.replace('_', ' ')}
                          </span>
                        </div>
                        
                        <h4 className="font-medium text-gray-900 mb-2">
                          {question.question}
                        </h4>
                        
                        {question.type === 'MULTIPLE_CHOICE' && question.options && (
                          <div className="space-y-1 mb-2">
                            {question.options.map((option, optIndex) => (
                              <div key={optIndex} className="flex items-center text-sm">
                                <div className={`w-2 h-2 rounded-full mr-2 ${
                                  option === question.correctAnswer ? 'bg-green-500' : 'bg-gray-300'
                                }`}></div>
                                <span className={option === question.correctAnswer ? 'font-medium text-green-700' : 'text-gray-600'}>
                                  {option}
                                </span>
                              </div>
                            ))}
                          </div>
                        )}
                        
                        {question.type !== 'MULTIPLE_CHOICE' && (
                          <div className="text-sm text-green-700 font-medium mb-2">
                            Correct: {question.correctAnswer}
                          </div>
                        )}
                        
                        {question.explanation && (
                          <p className="text-sm text-gray-600 italic">
                            Explanation: {question.explanation}
                          </p>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {!showPreview && (
                <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center">
                  <div className="w-12 h-12 mx-auto mb-4 text-gray-400">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                    </svg>
                  </div>
                  <p className="text-gray-500">
                    Generated questions will appear here
                  </p>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/contexts/AuthContext.tsx">
import React, { createContext, useContext, useEffect, useReducer, useCallback, useRef } from 'react'
import type { User, LoginCredentials, RegisterData } from '../types/auth'
import { authService } from '../services/auth'
import TokenManager from '../services/tokenManager'
import { debug } from '../utils/debug'

// Auth State
interface AuthState {
  user: User | null
  isAuthenticated: boolean
  isLoading: boolean
  isInitialized: boolean
  error: string | null
}

// Auth Actions
type AuthAction =
  | { type: 'LOGIN_START' }
  | { type: 'LOGIN_SUCCESS'; payload: User }
  | { type: 'LOGIN_ERROR'; payload: string }
  | { type: 'LOGOUT' }
  | { type: 'RESTORE_SESSION'; payload: User }
  | { type: 'SESSION_EXPIRED' }
  | { type: 'SET_ERROR'; payload: string }
  | { type: 'CLEAR_ERROR' }
  | { type: 'INITIALIZED' }
  | { type: 'REFRESH_START' }
  | { type: 'REFRESH_SUCCESS'; payload: User }
  | { type: 'REFRESH_ERROR' }

// Initial State
const initialState: AuthState = {
  user: null,
  isAuthenticated: false,
  isLoading: false,
  isInitialized: false,
  error: null
}

// Reducer
function authReducer(state: AuthState, action: AuthAction): AuthState {
  switch (action.type) {
    case 'LOGIN_START':
    case 'REFRESH_START':
      return { ...state, isLoading: true, error: null }
    
    case 'LOGIN_SUCCESS':
    case 'REFRESH_SUCCESS':
      return {
        ...state,
        user: action.payload,
        isAuthenticated: true,
        isLoading: false,
        error: null
      }
    
    case 'LOGIN_ERROR':
      return {
        ...state,
        user: null,
        isAuthenticated: false,
        isLoading: false,
        error: action.payload
      }
    
    case 'LOGOUT':
    case 'SESSION_EXPIRED':
      return {
        ...state,
        user: null,
        isAuthenticated: false,
        isLoading: false,
        error: action.type === 'SESSION_EXPIRED' ? 'Your session has expired' : null
      }
    
    case 'RESTORE_SESSION':
      return {
        ...state,
        user: action.payload,
        isAuthenticated: true,
        isInitialized: true
      }
    
    case 'SET_ERROR':
      return { ...state, error: action.payload }
    
    case 'CLEAR_ERROR':
      return { ...state, error: null }
    
    case 'INITIALIZED':
      return { ...state, isInitialized: true }
    
    case 'REFRESH_ERROR':
      return { ...state, isLoading: false }
    
    default:
      return state
  }
}

// Context Type
interface AuthContextType {
  state: AuthState
  actions: {
    login: (credentials: LoginCredentials) => Promise<void>
    register: (data: RegisterData) => Promise<void>
    logout: () => void
    refreshAuth: () => Promise<void>
    clearError: () => void
  }
}

// Create Context
const AuthContext = createContext<AuthContextType | undefined>(undefined)

// Auth Provider Component
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(authReducer, initialState)
  const refreshInProgress = useRef(false)

  // Initialize auth on mount
  useEffect(() => {
    const initializeAuth = async () => {
      debug.auth('Initializing')
      
      // Initialize token manager
      TokenManager.initialize()
      
      // Try to restore session if token is valid
      if (TokenManager.isTokenValid()) {
        try {
          const user = await authService.getCurrentUser()
          if (user) {
            debug.auth('Session restored', { email: user.email })
            dispatch({ type: 'RESTORE_SESSION', payload: user })
          } else {
            debug.auth('Failed to restore session - clearing tokens')
            TokenManager.clearTokens()
          }
        } catch (error) {
          debug.error('Failed to restore session:', error)
          TokenManager.clearTokens()
        }
      } else {
        debug.auth('No valid token found')
      }
      
      dispatch({ type: 'INITIALIZED' })
    }

    initializeAuth()
  }, [])

  // Handle token refresh events
  useEffect(() => {
    const handleTokenRefresh = async () => {
      if (refreshInProgress.current) return
      
      refreshInProgress.current = true
      dispatch({ type: 'REFRESH_START' })
      
      try {
        const success = await authService.refreshToken()
        if (success) {
          const user = await authService.getCurrentUser()
          if (user) {
            dispatch({ type: 'REFRESH_SUCCESS', payload: user })
          } else {
            dispatch({ type: 'SESSION_EXPIRED' })
          }
        } else {
          dispatch({ type: 'SESSION_EXPIRED' })
        }
      } catch (error) {
        debug.error('Token refresh failed:', error)
        dispatch({ type: 'SESSION_EXPIRED' })
      } finally {
        refreshInProgress.current = false
      }
    }

    const handleAuthExpired = () => {
      dispatch({ type: 'SESSION_EXPIRED' })
      TokenManager.clearTokens()
    }

    const handleTokensUpdated = async () => {
      // Another tab updated tokens, refresh our state
      if (TokenManager.isTokenValid()) {
        try {
          const user = await authService.getCurrentUser()
          if (user) {
            dispatch({ type: 'RESTORE_SESSION', payload: user })
          }
        } catch (error) {
          debug.error('Failed to sync auth state:', error)
        }
      }
    }

    const handleTokensCleared = () => {
      // Another tab logged out
      dispatch({ type: 'LOGOUT' })
    }

    // Listen for auth events
    window.addEventListener('auth:token-refresh-needed', handleTokenRefresh)
    window.addEventListener('auth:expired', handleAuthExpired)
    window.addEventListener('auth:tokens-updated', handleTokensUpdated)
    window.addEventListener('auth:tokens-cleared', handleTokensCleared)

    return () => {
      window.removeEventListener('auth:token-refresh-needed', handleTokenRefresh)
      window.removeEventListener('auth:expired', handleAuthExpired)
      window.removeEventListener('auth:tokens-updated', handleTokensUpdated)
      window.removeEventListener('auth:tokens-cleared', handleTokensCleared)
    }
  }, [])

  // Handle storage changes (cross-tab sync)
  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === 'accessToken') {
        if (e.newValue === null) {
          // Token removed in another tab
          dispatch({ type: 'LOGOUT' })
        } else if (e.oldValue === null && e.newValue !== null) {
          // Token added in another tab (login)
          window.location.reload() // Simple reload to sync state
        }
      }
    }

    window.addEventListener('storage', handleStorageChange)
    return () => window.removeEventListener('storage', handleStorageChange)
  }, [])

  // Actions
  const login = useCallback(async (credentials: LoginCredentials) => {
    dispatch({ type: 'LOGIN_START' })
    
    try {
      const response = await authService.login(credentials)
      
      if (response.success && response.data) {
        dispatch({ type: 'LOGIN_SUCCESS', payload: response.data.user })
      } else {
        dispatch({ type: 'LOGIN_ERROR', payload: response.error || 'Login failed' })
        throw new Error(response.error || 'Login failed')
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Login failed'
      dispatch({ type: 'LOGIN_ERROR', payload: message })
      throw error
    }
  }, [])

  const register = useCallback(async (data: RegisterData) => {
    dispatch({ type: 'LOGIN_START' })
    
    try {
      const response = await authService.register(data)
      
      if (response.success && response.data) {
        dispatch({ type: 'LOGIN_SUCCESS', payload: response.data.user })
      } else {
        dispatch({ type: 'LOGIN_ERROR', payload: response.error || 'Registration failed' })
        throw new Error(response.error || 'Registration failed')
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Registration failed'
      dispatch({ type: 'LOGIN_ERROR', payload: message })
      throw error
    }
  }, [])

  const logout = useCallback(() => {
    authService.logout()
    dispatch({ type: 'LOGOUT' })
  }, [])

  const refreshAuth = useCallback(async () => {
    if (refreshInProgress.current) return
    
    refreshInProgress.current = true
    dispatch({ type: 'REFRESH_START' })
    
    try {
      const success = await authService.refreshToken()
      if (success) {
        const user = await authService.getCurrentUser()
        if (user) {
          dispatch({ type: 'REFRESH_SUCCESS', payload: user })
        } else {
          dispatch({ type: 'SESSION_EXPIRED' })
        }
      } else {
        dispatch({ type: 'SESSION_EXPIRED' })
      }
    } catch (error) {
      debug.error('Manual refresh failed:', error)
      dispatch({ type: 'REFRESH_ERROR' })
    } finally {
      refreshInProgress.current = false
    }
  }, [])

  const clearError = useCallback(() => {
    dispatch({ type: 'CLEAR_ERROR' })
  }, [])

  const contextValue: AuthContextType = {
    state,
    actions: {
      login,
      register,
      logout,
      refreshAuth,
      clearError
    }
  }

  return <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>
}

// Hook to use auth context
// eslint-disable-next-line react-refresh/only-export-components
export function useAuth(): AuthContextType {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}

// Hook for checking specific roles
// eslint-disable-next-line react-refresh/only-export-components
export function useRole(requiredRole: string): boolean {
  const { state: { user } } = useAuth()
  return user?.role === requiredRole
}

// Hook for auth status
export function useAuthStatus() {
  const { state } = useAuth()
  return {
    isAuthenticated: state.isAuthenticated,
    isLoading: state.isLoading,
    isInitialized: state.isInitialized,
    user: state.user,
    error: state.error
  }
}
</file>

<file path="frontend/src/App.tsx">
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom'
import { AuthProvider } from './contexts/AuthContext'
import { VideoStateProvider } from './contexts/VideoStateContext'
import { ProtectedRoute, PublicRoute } from './components/auth/ProtectedRoute'
import { AuthErrorBoundary } from './components/auth/AuthErrorBoundary'
import Layout from './components/layout/Layout'
import LoginPage from './pages/auth/LoginPage'
import RegisterPage from './pages/auth/RegisterPage'
import DashboardPage from './pages/dashboard/DashboardPage'
import LessonsPage from './pages/lessons/LessonsPage'
import LessonDetailPage from './pages/lessons/LessonDetailPage'
import VideoPlayerPage from './pages/video/VideoPlayerPage'
import CreateLessonPage from './pages/teacher/CreateLessonPage'
import TeacherLessonsPage from './pages/teacher/TeacherLessonsPage'
import LessonManagementPage from './pages/teacher/LessonManagementPage'

// Create a client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
})

// Remove old ProtectedRoute and PublicRoute components - they're now imported

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        <AuthErrorBoundary>
          <VideoStateProvider>
            <Router>
              <div className="min-h-screen bg-gray-50">
                <Routes>
              {/* Public Routes */}
              <Route 
                path="/login" 
                element={
                  <PublicRoute>
                    <LoginPage />
                  </PublicRoute>
                } 
              />
              <Route 
                path="/register" 
                element={
                  <PublicRoute>
                    <RegisterPage />
                  </PublicRoute>
                } 
              />
              
              {/* Protected Routes */}
              <Route
                path="/*"
                element={
                  <ProtectedRoute>
                    <Layout>
                      <Routes>
                        <Route path="/dashboard" element={<DashboardPage />} />
                        <Route path="/lessons" element={<LessonsPage />} />
                        <Route path="/lessons/:id" element={<LessonDetailPage />} />
                        <Route path="/video/:videoId" element={<VideoPlayerPage />} />
                        <Route path="/teacher/create-lesson" element={<CreateLessonPage />} />
                        <Route path="/teacher/lessons" element={<TeacherLessonsPage />} />
                        <Route path="/teacher/lessons/:lessonId" element={<LessonManagementPage />} />
                        <Route path="/" element={<Navigate to="/dashboard" replace />} />
                      </Routes>
                    </Layout>
                  </ProtectedRoute>
                }
              />
            </Routes>
          </div>
        </Router>
      </VideoStateProvider>
      </AuthErrorBoundary>
      </AuthProvider>
    </QueryClientProvider>
  )
}

export default App
</file>

<file path="frontend/package.json">
{
  "name": "interactive-learning-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b tsconfig.app.json && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "type-check": "tsc --noEmit",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:run": "vitest run",
    "test:watch": "vitest --watch",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@heroicons/react": "^2.0.18",
    "@tanstack/react-query": "^5.13.4",
    "autoprefixer": "^10.4.16",
    "axios": "^1.6.2",
    "clsx": "^2.0.0",
    "date-fns": "^2.30.0",
    "postcss": "^8.4.31",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-hook-form": "^7.48.2",
    "react-player": "^2.13.0",
    "react-router-dom": "^6.20.1",
    "tailwindcss": "^3.3.5",
    "zustand": "^4.4.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.30.1",
    "@testing-library/jest-dom": "^6.6.4",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@vitejs/plugin-react": "^4.6.0",
    "@vitest/ui": "^3.2.4",
    "eslint": "^9.30.1",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "jsdom": "^26.1.0",
    "msw": "^2.10.4",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.35.1",
    "vite": "^7.0.4",
    "vitest": "^3.2.4"
  }
}
</file>

<file path="src/controllers/lessonController.ts">
import { Response } from 'express';
import { PrismaClient, LessonStatus } from '@prisma/client';
import { AuthenticatedRequest } from '../middleware/auth/authMiddleware';
import { logger } from '../utils/logger';

const prisma = new PrismaClient();

export const lessonController = {
  // Get all lessons with filtering
  async getAllLessons(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const { 
        page = 1, 
        limit = 10, 
        status,
        difficulty,
        createdById,
        search
      } = req.query;
      
      const offset = (Number(page) - 1) * Number(limit);
      const currentUser = req.user!;

      const where: any = {};

      // Multi-tenant filtering
      if (currentUser.tenantId) {
        where.tenantId = currentUser.tenantId;
      }

      // Additional filters first
      if (status) where.status = status as LessonStatus;
      if (difficulty) where.difficulty = difficulty as string;

      // Role-based filtering
      if (currentUser.role === 'TEACHER') {
        // If createdById filter is requested and it's the teacher's own ID, allow it
        if (createdById && createdById === currentUser.id) {
          where.createdById = currentUser.id;
        } else {
          // Teachers can only see their own lessons and published lessons
          where.OR = [
            { createdById: currentUser.id },
            { status: 'PUBLISHED' }
          ];
        }
      } else if (currentUser.role === 'STUDENT') {
        // Students can only see published lessons
        where.status = 'PUBLISHED';
      } else if (currentUser.role === 'ADMIN') {
        // Admins can filter by any createdById
        if (createdById) {
          where.createdById = createdById as string;
        }
      }

      // Search functionality (needs to be combined with existing OR conditions)
      if (search) {
        const searchConditions = [
          { title: { contains: search as string, mode: 'insensitive' } },
          { description: { contains: search as string, mode: 'insensitive' } },
          { tags: { has: search as string } }
        ];

        if (where.OR) {
          // Combine existing OR conditions with search using AND
          where.AND = [
            { OR: where.OR },
            { OR: searchConditions }
          ];
          delete where.OR;
        } else {
          where.OR = searchConditions;
        }
      }

      const lessons = await prisma.lesson.findMany({
        where,
        skip: offset,
        take: Number(limit),
        select: {
          id: true,
          title: true,
          description: true,
          thumbnail: true,
          status: true,
          order: true,
          objectives: true,
          estimatedTime: true,
          difficulty: true,
          tags: true,
          createdAt: true,
          publishedAt: true,
          createdBy: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              avatar: true
            }
          },
          _count: {
            select: {
              videoGroups: true,
              studentProgress: true
            }
          }
        },
        orderBy: [
          { order: 'asc' },
          { createdAt: 'desc' }
        ]
      });

      const total = await prisma.lesson.count({ where });

      res.json({
        success: true,
        data: {
          items: lessons,
          total,
          page: Number(page),
          limit: Number(limit),
          totalPages: Math.ceil(total / Number(limit))
        }
      });
    } catch (error) {
      logger.error('Error fetching lessons:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch lessons'
      });
      return;
    }
  },

  // Get lesson by ID with full details - UNIFIED PATTERN FOR ALL ROLES
  async getLessonById(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const currentUser = req.user!;

      const where: any = { id };
      
      // Multi-tenant filtering
      if (currentUser.tenantId) {
        where.tenantId = currentUser.tenantId;
      }

      // Role-based filtering for students
      if (currentUser.role === 'STUDENT') {
        where.status = 'PUBLISHED'; // Students only see published lessons
      }

      const lesson = await prisma.lesson.findFirst({
        where,
        include: {
          createdBy: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              avatar: true,
              email: true
            }
          },
          // ALWAYS include videoGroups for ALL roles - unified pattern
          videoGroups: {
            orderBy: { order: 'asc' },
            include: {
              videos: {
                orderBy: { order: 'asc' },
                // Role-based video filtering
                where: currentUser.role === 'STUDENT' 
                  ? { status: 'READY' } // Students only see ready videos
                  : {}, // Teachers and admins see all videos
                select: {
                  id: true,
                  title: true,
                  description: true,
                  order: true,
                  status: true,
                  duration: true,
                  thumbnailPath: true,
                  // Only include sensitive fields for teachers/admins
                  filePath: currentUser.role === 'TEACHER' || currentUser.role === 'ADMIN' ? true : false,
                  size: true,
                  mimeType: true,
                  processingStatus: currentUser.role === 'TEACHER' || currentUser.role === 'ADMIN' ? true : false,
                  uploadedAt: true,
                  _count: {
                    select: {
                      milestones: true
                    }
                  }
                }
              },
              _count: {
                select: {
                  videos: true
                }
              }
            }
          },
          // Include progress for students
          studentProgress: currentUser.role === 'STUDENT' ? {
            where: { studentId: currentUser.id },
            select: {
              id: true,
              isCompleted: true,
              completionPercent: true,
              totalTimeSpent: true,
              averageScore: true,
              startedAt: true,
              completedAt: true
            }
          } : false,
          _count: {
            select: {
              videoGroups: true,
              studentProgress: true
            }
          }
        }
      });

      if (!lesson) {
        res.status(404).json({
          success: false,
          error: 'Lesson not found'
        });
        return;
      }

      // Additional access control for teachers
      if (currentUser.role === 'TEACHER' && 
          lesson.createdById !== currentUser.id && 
          lesson.status !== 'PUBLISHED') {
        res.status(403).json({
          success: false,
          error: 'Access denied: Cannot view unpublished lessons from other teachers'
        });
        return;
      }

      // Convert BigInt values to strings to avoid serialization issues
      const processedLesson = JSON.parse(JSON.stringify(lesson, (key, value) =>
        typeof value === 'bigint' ? value.toString() : value
      ));

      res.json({
        success: true,
        data: processedLesson
      });
    } catch (error) {
      logger.error('Error fetching lesson:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch lesson'
      });
      return;
    }
  },

  // Create new lesson (Teacher/Admin only)
  async createLesson(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const {
        title,
        description,
        thumbnail,
        objectives = [],
        estimatedTime,
        difficulty,
        tags = [],
        order
      } = req.body;
      
      const currentUser = req.user!;

      const lesson = await prisma.lesson.create({
        data: {
          title,
          description,
          thumbnail,
          objectives,
          estimatedTime,
          difficulty,
          tags,
          order,
          createdById: currentUser.id,
          tenantId: currentUser.tenantId,
          status: LessonStatus.DRAFT
        },
        include: {
          createdBy: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              avatar: true
            }
          }
        }
      });

      logger.info(`Lesson created: ${lesson.title} by ${currentUser.email}`);

      res.status(201).json({
        success: true,
        data: lesson,
        message: 'Lesson created successfully'
      });
    } catch (error) {
      logger.error('Error creating lesson:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create lesson'
      });
      return;
    }
  },

  // Update lesson
  async updateLesson(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const updateData = req.body;
      const currentUser = req.user!;

      const where: any = { id };
      
      // Multi-tenant filtering
      if (currentUser.tenantId) {
        where.tenantId = currentUser.tenantId;
      }

      // Check ownership for teachers
      if (currentUser.role === 'TEACHER') {
        where.createdById = currentUser.id;
      }

      const lesson = await prisma.lesson.update({
        where,
        data: updateData,
        include: {
          createdBy: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              avatar: true
            }
          }
        }
      });

      logger.info(`Lesson updated: ${lesson.title} by ${currentUser.email}`);

      res.json({
        success: true,
        data: lesson,
        message: 'Lesson updated successfully'
      });
    } catch (error: any) {
      if (error.code === 'P2025') {
        res.status(404).json({
          success: false,
          error: 'Lesson not found or access denied'
        });
        return;
      }

      logger.error('Error updating lesson:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update lesson'
      });
      return;
    }
  },

  // Publish lesson
  async publishLesson(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const currentUser = req.user!;

      const where: any = { id };
      
      // Multi-tenant filtering
      if (currentUser.tenantId) {
        where.tenantId = currentUser.tenantId;
      }

      // Check ownership for teachers
      if (currentUser.role === 'TEACHER') {
        where.createdById = currentUser.id;
      }

      // Validate lesson has content before publishing
      const lessonWithContent = await prisma.lesson.findFirst({
        where,
        include: {
          videoGroups: {
            include: {
              videos: {
                where: { status: 'READY' }
              }
            }
          }
        }
      });

      if (!lessonWithContent) {
        res.status(404).json({
          success: false,
          error: 'Lesson not found or access denied'
        });
        return;
      }

      const hasReadyVideos = lessonWithContent.videoGroups.some(
        group => group.videos.length > 0
      );

      if (!hasReadyVideos) {
        res.status(400).json({
          success: false,
          error: 'Cannot publish lesson without ready videos'
        });
        return;
      }

      const lesson = await prisma.lesson.update({
        where: { id },
        data: {
          status: LessonStatus.PUBLISHED,
          publishedAt: new Date()
        },
        include: {
          createdBy: {
            select: {
              id: true,
              firstName: true,
              lastName: true
            }
          }
        }
      });

      logger.info(`Lesson published: ${lesson.title} by ${currentUser.email}`);

      res.json({
        success: true,
        data: lesson,
        message: 'Lesson published successfully'
      });
    } catch (error) {
      logger.error('Error publishing lesson:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to publish lesson'
      });
      return;
    }
  },

  // Delete lesson
  async deleteLesson(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const currentUser = req.user!;

      const where: any = { id };
      
      // Multi-tenant filtering
      if (currentUser.tenantId) {
        where.tenantId = currentUser.tenantId;
      }

      // Check ownership for teachers
      if (currentUser.role === 'TEACHER') {
        where.createdById = currentUser.id;
      }

      // Check if lesson has student progress
      const lessonWithProgress = await prisma.lesson.findFirst({
        where,
        include: {
          _count: {
            select: {
              studentProgress: true
            }
          }
        }
      });

      if (!lessonWithProgress) {
        res.status(404).json({
          success: false,
          error: 'Lesson not found or access denied'
        });
        return;
      }

      if (lessonWithProgress._count.studentProgress > 0) {
        res.status(400).json({
          success: false,
          error: 'Cannot delete lesson with existing student progress. Archive it instead.'
        });
        return;
      }

      await prisma.lesson.delete({ where: { id } });

      logger.info(`Lesson deleted: ${lessonWithProgress.title} by ${currentUser.email}`);

      res.json({
        success: true,
        message: 'Lesson deleted successfully'
      });
    } catch (error) {
      logger.error('Error deleting lesson:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete lesson'
      });
      return;
    }
  },

  // Archive lesson
  async archiveLesson(req: AuthenticatedRequest, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const currentUser = req.user!;

      const where: any = { id };
      
      // Multi-tenant filtering
      if (currentUser.tenantId) {
        where.tenantId = currentUser.tenantId;
      }

      // Check ownership for teachers
      if (currentUser.role === 'TEACHER') {
        where.createdById = currentUser.id;
      }

      const lesson = await prisma.lesson.update({
        where,
        data: {
          status: LessonStatus.ARCHIVED
        },
        include: {
          createdBy: {
            select: {
              id: true,
              firstName: true,
              lastName: true
            }
          }
        }
      });

      logger.info(`Lesson archived: ${lesson.title} by ${currentUser.email}`);

      res.json({
        success: true,
        data: lesson,
        message: 'Lesson archived successfully'
      });
    } catch (error: any) {
      if (error.code === 'P2025') {
        res.status(404).json({
          success: false,
          error: 'Lesson not found or access denied'
        });
        return;
      }

      logger.error('Error archiving lesson:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to archive lesson'
      });
      return;
    }
  }
};
</file>

<file path="src/routes/aiRoutes.ts">
import { Router, Response } from 'express'
import { body } from 'express-validator'
import { validationResult } from 'express-validator'
import { validateCUIDParam } from '../utils/validators'
import { authenticate } from '../middleware/auth/authMiddleware'
// import { roleMiddleware } from '../middleware/role' // TODO: Create this middleware
import { AIQuestionService } from '../services/AIQuestionService'
import { AuthenticatedRequest } from '../middleware/auth/authMiddleware'

const router = Router()

// Apply authentication middleware to all routes
router.use(authenticate)

// GET /api/ai/providers - Get available AI providers
router.get('/providers', 
  // roleMiddleware(['TEACHER', 'ADMIN']), // TODO: Create this middleware
  (_req: AuthenticatedRequest, res) => {
    try {
      const providers = AIQuestionService.getAvailableProviders()
      return res.json({
        success: true,
        data: {
          providers,
          hasAISupport: providers.length > 0
        }
      })
    } catch (error) {
      console.error('Error getting AI providers:', error)
      return res.status(500).json({
        success: false,
        error: 'Failed to get AI providers'
      })
    }
  }
)

// POST /api/ai/generate-questions - Generate questions from content
router.post('/generate-questions',
  // roleMiddleware(['TEACHER', 'ADMIN']), // TODO: Create this middleware
  body('videoTitle').notEmpty().trim().withMessage('Video title is required'),
  body('content').notEmpty().trim().withMessage('Content is required'),
  body('questionCount').optional().isInt({ min: 1, max: 10 }).withMessage('Question count must be between 1 and 10'),
  body('questionTypes').optional().isArray().withMessage('Question types must be an array'),
  body('difficulty').optional().isIn(['EASY', 'MEDIUM', 'HARD']).withMessage('Invalid difficulty level'),
  body('provider').optional().isIn(['OPENAI', 'CLAUDE']).withMessage('Invalid AI provider'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const result = await AIQuestionService.generateQuestions({
        videoTitle: req.body.videoTitle,
        videoDescription: req.body.videoDescription,
        content: req.body.content,
        questionCount: req.body.questionCount || 3,
        questionTypes: req.body.questionTypes || ['MULTIPLE_CHOICE', 'TRUE_FALSE', 'SHORT_ANSWER'],
        difficulty: req.body.difficulty || 'MEDIUM',
        provider: req.body.provider
      })

      return res.json({
        success: true,
        data: result,
        message: 'Questions generated successfully'
      })

    } catch (error: any) {
      console.error('Error generating questions:', error)
      
      // Handle specific error types
      if (error.message.includes('No AI provider')) {
        return res.status(503).json({
          success: false,
          error: 'AI service unavailable',
          message: 'No AI providers are currently configured'
        })
      }

      if (error.message.includes('API key') || error.message.includes('authentication')) {
        return res.status(503).json({
          success: false,
          error: 'AI service configuration error',
          message: 'AI provider authentication failed'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to generate questions',
        message: error.message || 'An unexpected error occurred'
      })
    }
  }
)

// POST /api/ai/generate-for-milestone/:milestoneId - Generate questions for existing milestone
router.post('/generate-for-milestone/:milestoneId',
  // roleMiddleware(['TEACHER', 'ADMIN']), // TODO: Create this middleware
  validateCUIDParam('milestoneId', 'Invalid milestone ID'),
  body('content').optional().trim(),
  body('questionCount').optional().isInt({ min: 1, max: 10 }).withMessage('Question count must be between 1 and 10'),
  body('questionTypes').optional().isArray().withMessage('Question types must be an array'),
  body('difficulty').optional().isIn(['EASY', 'MEDIUM', 'HARD']).withMessage('Invalid difficulty level'),
  body('provider').optional().isIn(['OPENAI', 'CLAUDE']).withMessage('Invalid AI provider'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      await AIQuestionService.generateQuestionsForMilestone(req.params.milestoneId, {
        videoTitle: '', // Will be retrieved from milestone
        content: req.body.content,
        questionCount: req.body.questionCount || 3,
        questionTypes: req.body.questionTypes || ['MULTIPLE_CHOICE', 'TRUE_FALSE', 'SHORT_ANSWER'],
        difficulty: req.body.difficulty || 'MEDIUM',
        provider: req.body.provider
      }, req.user!.id)

      return res.json({
        success: true,
        message: 'Questions generated and added to milestone successfully'
      })

    } catch (error: any) {
      console.error('Error generating questions for milestone:', error)
      
      if (error.message === 'Milestone not found') {
        return res.status(404).json({
          success: false,
          error: 'Milestone not found'
        })
      }

      if (error.message.includes('No AI provider')) {
        return res.status(503).json({
          success: false,
          error: 'AI service unavailable'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to generate questions for milestone',
        message: error.message || 'An unexpected error occurred'
      })
    }
  }
)

// POST /api/ai/generate-milestone-with-questions/:videoId - Generate milestone and questions from content
router.post('/generate-milestone-with-questions/:videoId',
  // roleMiddleware(['TEACHER', 'ADMIN']), // TODO: Create this middleware
  validateCUIDParam('videoId', 'Invalid video ID'),
  body('videoTitle').notEmpty().trim().withMessage('Video title is required'),
  body('content').notEmpty().trim().withMessage('Content is required'),
  body('questionCount').optional().isInt({ min: 1, max: 10 }).withMessage('Question count must be between 1 and 10'),
  body('questionTypes').optional().isArray().withMessage('Question types must be an array'),
  body('difficulty').optional().isIn(['EASY', 'MEDIUM', 'HARD']).withMessage('Invalid difficulty level'),
  body('provider').optional().isIn(['OPENAI', 'CLAUDE']).withMessage('Invalid AI provider'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const result = await AIQuestionService.generateMilestoneWithQuestions(req.params.videoId, {
        videoTitle: req.body.videoTitle,
        videoDescription: req.body.videoDescription,
        content: req.body.content,
        questionCount: req.body.questionCount || 3,
        questionTypes: req.body.questionTypes || ['MULTIPLE_CHOICE', 'TRUE_FALSE', 'SHORT_ANSWER'],
        difficulty: req.body.difficulty || 'MEDIUM',
        provider: req.body.provider
      }, req.user!.id)

      return res.json({
        success: true,
        data: result,
        message: 'Milestone and questions generated successfully'
      })

    } catch (error: any) {
      console.error('Error generating milestone with questions:', error)
      
      if (error.message.includes('No AI provider')) {
        return res.status(503).json({
          success: false,
          error: 'AI service unavailable'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to generate milestone with questions',
        message: error.message || 'An unexpected error occurred'
      })
    }
  }
)

export default router
</file>

<file path="src/routes/analyticsRoutes.ts">
import { Router, Response } from 'express'
import { query } from 'express-validator'
import { validationResult } from 'express-validator'
import { validateCUIDParam, validateCUIDQuery } from '../utils/validators'
import { authenticate } from '../middleware/auth/authMiddleware'
// import { roleMiddleware } from '../middleware/role' // TODO: Create this middleware
import { AnalyticsService } from '../services/AnalyticsService'
import { AuthenticatedRequest } from '../middleware/auth/authMiddleware'

const router = Router()

// Apply authentication middleware to all routes
router.use(authenticate)

// GET /api/analytics/video/:videoId/stats - Get video analytics stats
router.get('/video/:videoId/stats',
  validateCUIDParam('videoId', 'Invalid video ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const stats = await AnalyticsService.getVideoStats(req.params.videoId, req.user!)

      return res.json({
        success: true,
        data: stats
      })

    } catch (error: any) {
      console.error('Error fetching video stats:', error)
      
      if (error.message === 'Video not found') {
        return res.status(404).json({
          success: false,
          error: 'Video not found'
        })
      }

      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to fetch video statistics'
      })
    }
  }
)

// GET /api/analytics/video/:videoId/progress - Get video progress data
router.get('/video/:videoId/progress',
  validateCUIDParam('videoId', 'Invalid video ID'),
  query('timeRange').optional().isIn(['day', 'week', 'month', 'all']).withMessage('Invalid time range'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const timeRange = req.query.timeRange as string || 'week'
      const progressData = await AnalyticsService.getVideoProgressData(
        req.params.videoId, 
        timeRange,
        req.user!
      )

      return res.json({
        success: true,
        data: progressData
      })

    } catch (error: any) {
      console.error('Error fetching video progress:', error)
      
      if (error.message === 'Video not found' || error.message === 'Access denied') {
        return res.status(error.message === 'Video not found' ? 404 : 403).json({
          success: false,
          error: error.message
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to fetch video progress data'
      })
    }
  }
)

// GET /api/analytics/student/:studentId/progress - Get student progress (teachers/admins only)
router.get('/student/:studentId/progress',
  // roleMiddleware(['TEACHER', 'ADMIN']), // TODO: Create this middleware
  validateCUIDParam('studentId', 'Invalid student ID'),
  validateCUIDQuery('videoGroupId', 'Invalid video group ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const videoGroupId = req.query.videoGroupId as string
      const progressData = await AnalyticsService.getStudentProgress(
        req.params.studentId,
        videoGroupId,
        req.user!
      )

      return res.json({
        success: true,
        data: progressData
      })

    } catch (error: any) {
      console.error('Error fetching student progress:', error)
      
      if (error.message === 'Student not found' || error.message === 'Access denied') {
        return res.status(error.message === 'Student not found' ? 404 : 403).json({
          success: false,
          error: error.message
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to fetch student progress'
      })
    }
  }
)

// GET /api/analytics/lesson/:lessonId/overview - Get lesson analytics overview (teachers/admins only)
router.get('/lesson/:lessonId/overview',
  // roleMiddleware(['TEACHER', 'ADMIN']), // TODO: Create this middleware
  validateCUIDParam('lessonId', 'Invalid lesson ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const overview = await AnalyticsService.getLessonOverview(req.params.lessonId, req.user!)

      return res.json({
        success: true,
        data: overview
      })

    } catch (error: any) {
      console.error('Error fetching lesson overview:', error)
      
      if (error.message === 'Lesson not found' || error.message === 'Access denied') {
        return res.status(error.message === 'Lesson not found' ? 404 : 403).json({
          success: false,
          error: error.message
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to fetch lesson overview'
      })
    }
  }
)

// GET /api/analytics/dashboard/teacher - Get teacher dashboard analytics
router.get('/dashboard/teacher',
  // roleMiddleware(['TEACHER', 'ADMIN']), // TODO: Create this middleware
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const dashboardData = await AnalyticsService.getTeacherDashboard(req.user!)

      return res.json({
        success: true,
        data: dashboardData
      })

    } catch (error) {
      console.error('Error fetching teacher dashboard:', error)
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch teacher dashboard data'
      })
    }
  }
)

// GET /api/analytics/dashboard/student - Get student dashboard analytics
router.get('/dashboard/student',
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const dashboardData = await AnalyticsService.getStudentDashboard(req.user!)

      return res.json({
        success: true,
        data: dashboardData
      })

    } catch (error) {
      console.error('Error fetching student dashboard:', error)
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch student dashboard data'
      })
    }
  }
)

// GET /api/analytics/engagement/heatmap/:videoId - Get engagement heatmap for video
router.get('/engagement/heatmap/:videoId',
  validateCUIDParam('videoId', 'Invalid video ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const heatmapData = await AnalyticsService.getEngagementHeatmap(req.params.videoId, req.user!)

      return res.json({
        success: true,
        data: heatmapData
      })

    } catch (error: any) {
      console.error('Error fetching engagement heatmap:', error)
      
      if (error.message === 'Video not found' || error.message === 'Access denied') {
        return res.status(error.message === 'Video not found' ? 404 : 403).json({
          success: false,
          error: error.message
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to fetch engagement heatmap'
      })
    }
  }
)

// GET /api/analytics/questions/:milestoneId/performance - Get question performance analytics
router.get('/questions/:milestoneId/performance',
  validateCUIDParam('milestoneId', 'Invalid milestone ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const performance = await AnalyticsService.getQuestionPerformance(req.params.milestoneId, req.user!)

      return res.json({
        success: true,
        data: performance
      })

    } catch (error: any) {
      console.error('Error fetching question performance:', error)
      
      if (error.message === 'Milestone not found' || error.message === 'Access denied') {
        return res.status(error.message === 'Milestone not found' ? 404 : 403).json({
          success: false,
          error: error.message
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to fetch question performance'
      })
    }
  }
)

export default router
</file>

<file path="src/routes/index.ts">
import { Router } from 'express';
import userRoutes from './userRoutes';
import lessonRoutes from './lessonRoutes';
import authRoutes from './authRoutes';
import videoRoutes from './videoRoutes';
import milestoneRoutes from './milestoneRoutes';
import questionRoutes from './questionRoutes';
import sessionRoutes from './sessionRoutes';
import aiRoutes from './aiRoutes';
import analyticsRoutes from './analyticsRoutes';

const router = Router();

// Health check endpoint
router.get('/health', (_req, res) => {
  res.json({
    success: true,
    message: 'Interactive Learning Platform API is running',
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

// API routes
router.use('/auth', authRoutes);
router.use('/users', userRoutes);
router.use('/lessons', lessonRoutes);
router.use('/videos', videoRoutes);
router.use('/milestones', milestoneRoutes);
router.use('/questions', questionRoutes);
router.use('/sessions', sessionRoutes);
router.use('/ai', aiRoutes);
router.use('/analytics', analyticsRoutes);

export default router;
</file>

<file path="src/services/MilestoneService.ts">
import { PrismaClient } from '@prisma/client'
import { User } from '../types/auth'

const prisma = new PrismaClient()

interface CreateMilestoneData {
  videoId: string
  timestamp: number
  title: string
  description: string | null
  isRequired?: boolean
  retryLimit?: number
}

interface UpdateMilestoneData {
  timestamp?: number
  title?: string
  description?: string
  isRequired?: boolean
  retryLimit?: number
}

interface CreateQuestionData {
  milestoneId: string
  type: 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'SHORT_ANSWER' | 'FILL_IN_BLANK'
  text: string
  explanation: string | null
  hints?: string[]
  difficulty?: string
  questionData: any // Flexible JSON data for different question types
  points?: number
  passThreshold?: number
}

export class MilestoneService {
  static async createMilestone(data: CreateMilestoneData, user: User) {
    // Check if video exists and user has permission
    const video = await prisma.video.findUnique({
      where: { id: data.videoId },
      include: {
        videoGroup: {
          include: {
            lesson: true
          }
        }
      }
    })

    if (!video) {
      throw new Error('Video not found')
    }

    // Check permissions - only lesson creator or admin can create milestones
    if (
      video.videoGroup.lesson.createdById !== user.id && 
      user.role !== 'ADMIN'
    ) {
      throw new Error('Access denied')
    }

    // Check if milestone already exists at this timestamp
    const existingMilestone = await prisma.milestone.findFirst({
      where: {
        videoId: data.videoId,
        timestamp: data.timestamp
      }
    })

    if (existingMilestone) {
      throw new Error(`Milestone already exists at timestamp ${data.timestamp}`)
    }

    // Get the next order number for this video
    const maxOrder = await prisma.milestone.aggregate({
      where: { videoId: data.videoId },
      _max: { order: true }
    })

    const nextOrder = (maxOrder._max.order || 0) + 1

    const milestone = await prisma.milestone.create({
      data: {
        videoId: data.videoId,
        timestamp: data.timestamp,
        title: data.title,
        description: data.description,
        order: nextOrder,
        isRequired: data.isRequired ?? true,
        retryLimit: data.retryLimit ?? 3
      },
      include: {
        questions: true,
        _count: {
          select: { questions: true }
        }
      }
    })

    return milestone
  }

  static async getMilestonesByVideo(videoId: string, userId: string) {
    // Check if user has access to video
    const video = await prisma.video.findFirst({
      where: {
        id: videoId,
        videoGroup: {
          lesson: {
            OR: [
              { createdById: userId },
              {
                studentProgress: {
                  some: {
                    studentId: userId
                  }
                }
              }
            ]
          }
        }
      }
    })

    if (!video) {
      throw new Error('Video not found')
    }

    const milestones = await prisma.milestone.findMany({
      where: { videoId },
      include: {
        questions: true,
        _count: {
          select: { questions: true }
        }
      },
      orderBy: { timestamp: 'asc' }
    })

    return milestones
  }

  static async updateMilestone(milestoneId: string, data: UpdateMilestoneData, user: User) {
    // Check if milestone exists and user has permission
    const existingMilestone = await prisma.milestone.findUnique({
      where: { id: milestoneId },
      include: {
        video: {
          include: {
            videoGroup: {
              include: {
                lesson: true
              }
            }
          }
        }
      }
    })

    if (!existingMilestone) {
      throw new Error('Milestone not found')
    }

    // Check permissions - only lesson creator or admin can update milestones
    if (
      existingMilestone.video.videoGroup.lesson.createdById !== user.id && 
      user.role !== 'ADMIN'
    ) {
      throw new Error('Access denied')
    }

    // If updating timestamp, check for conflicts
    if (data.timestamp !== undefined && data.timestamp !== existingMilestone.timestamp) {
      const conflictingMilestone = await prisma.milestone.findFirst({
        where: {
          videoId: existingMilestone.videoId,
          timestamp: data.timestamp,
          id: { not: milestoneId }
        }
      })

      if (conflictingMilestone) {
        throw new Error(`Milestone already exists at timestamp ${data.timestamp}`)
      }
    }

    // Filter out undefined values
    const updateData: any = {}
    if (data.timestamp !== undefined) updateData.timestamp = data.timestamp
    if (data.title !== undefined) updateData.title = data.title
    if (data.description !== undefined) updateData.description = data.description
    if (data.isRequired !== undefined) updateData.isRequired = data.isRequired
    if (data.retryLimit !== undefined) updateData.retryLimit = data.retryLimit

    const milestone = await prisma.milestone.update({
      where: { id: milestoneId },
      data: updateData,
      include: {
        questions: true,
        _count: {
          select: { questions: true }
        }
      }
    })

    return milestone
  }

  static async deleteMilestone(milestoneId: string, user: User) {
    // Check if milestone exists and user has permission
    const existingMilestone = await prisma.milestone.findUnique({
      where: { id: milestoneId },
      include: {
        video: {
          include: {
            videoGroup: {
              include: {
                lesson: true
              }
            }
          }
        }
      }
    })

    if (!existingMilestone) {
      throw new Error('Milestone not found')
    }

    // Check permissions - only lesson creator or admin can delete milestones
    if (
      existingMilestone.video.videoGroup.lesson.createdById !== user.id && 
      user.role !== 'ADMIN'
    ) {
      throw new Error('Access denied')
    }

    await prisma.milestone.delete({
      where: { id: milestoneId }
    })

    return true
  }

  static async addQuestionToMilestone(data: CreateQuestionData, user: User) {
    // Check if milestone exists and user has permission
    const milestone = await prisma.milestone.findUnique({
      where: { id: data.milestoneId },
      include: {
        video: {
          include: {
            videoGroup: {
              include: {
                lesson: true
              }
            }
          }
        }
      }
    })

    if (!milestone) {
      throw new Error('Milestone not found')
    }

    // Check permissions - only lesson creator or admin can add questions
    if (
      milestone.video.videoGroup.lesson.createdById !== user.id && 
      user.role !== 'ADMIN'
    ) {
      throw new Error('Access denied')
    }

    // Create question
    const question = await prisma.question.create({
      data: {
        milestoneId: data.milestoneId,
        type: data.type,
        text: data.text,
        explanation: data.explanation || null,
        hints: data.hints || [],
        difficulty: data.difficulty || null,
        questionData: data.questionData,
        points: data.points || 1,
        passThreshold: data.passThreshold || 0.7,
        createdById: user.id,
        status: 'DRAFT' // Default to draft status for manual creation
      }
    })

    return question
  }
}
</file>

<file path="src/services/VideoSessionService.ts">
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

interface UpdateProgressData {
  currentPosition: number
  totalWatchTime?: number
}

interface SubmitAnswerData {
  questionId: string
  answer: string
  milestoneId: string
}

interface CompleteSessionData {
  finalTime: number
  totalWatchTime: number
}

interface GetUserSessionsOptions {
  studentId: string
  page: number
  limit: number
  status?: string
}

export class VideoSessionService {
  static async startSession(videoId: string, studentId: string) {
    // Check if video exists and user has access
    const video = await prisma.video.findFirst({
      where: {
        id: videoId,
        videoGroup: {
          lesson: {
            OR: [
              { createdById: studentId },
              {
                studentProgress: {
                  some: {
                    studentId: studentId
                  }
                }
              }
            ]
          }
        }
      }
    })

    console.log('Video found:', video ? 'Yes' : 'No')
    if (!video) {
      console.log('User does not have access to video:', videoId)
      throw new Error('Video not found')
    }

    // Get user's session for this video
    const session = await prisma.studentSession.findFirst({
      where: {
        videoId,
        studentId
      },
      include: {
        video: {
          include: {
            milestones: {
              orderBy: { timestamp: 'asc' },
              include: {
                questions: {
                  select: { 
                    id: true, 
                    type: true, 
                    text: true, 
                    questionData: true,
                    status: true
                  }
                }
              }
            }
          }
        },
        milestoneProgress: {
          orderBy: { reachedAt: 'asc' }
        },
        questionAttempts: true
      }
    })

    if (!session) {
      return null
    }

    return session
  }

  static async getSessionByVideo(videoId: string, studentId: string) {
    // First try to find any existing session for this video and student
    let session = await prisma.studentSession.findFirst({
      where: {
        videoId,
        studentId
      },
      include: {
        video: {
          include: {
            videoGroup: {
              select: {
                id: true,
                title: true
              }
            }
          }
        }
      }
    })

    // If no session exists, create a new one
    if (!session) {
      session = await prisma.studentSession.create({
        data: {
          videoId,
          studentId,
          status: 'ACTIVE',
          lastSeenAt: new Date(),
          currentPosition: 0
        },
        include: {
          video: {
            include: {
              videoGroup: {
                select: {
                  id: true,
                  title: true
                }
              }
            }
          }
        }
      })
    }

    return session
  }

  static async updateProgress(
    sessionId: string,
    progressData: UpdateProgressData,
    studentId: string
  ) {
    // Verify session exists and belongs to student
    const session = await prisma.studentSession.findFirst({
      where: {
        id: sessionId,
        studentId
      }
    })

    if (!session) {
      throw new Error('Session not found')
    }

    // Update session progress
    const updatedSession = await prisma.studentSession.update({
      where: { id: sessionId },
      data: {
        currentPosition: progressData.currentPosition,
        lastSeenAt: new Date()
      },
      include: {
        video: true,
        milestoneProgress: true
      }
    })

    return updatedSession
  }

  static async completeSession(
    sessionId: string,
    completionData: CompleteSessionData,
    studentId: string
  ) {
    // Verify session exists and belongs to student
    const session = await prisma.studentSession.findFirst({
      where: {
        id: sessionId,
        studentId
      }
    })

    if (!session) {
      throw new Error('Session not found')
    }

    // Update session as completed
    const updatedSession = await prisma.studentSession.update({
      where: { id: sessionId },
      data: {
        status: 'COMPLETED',
        currentPosition: completionData.finalTime,
        completedAt: new Date(),
        lastSeenAt: new Date()
      },
      include: {
        video: true,
        milestoneProgress: true,
        questionAttempts: true
      }
    })

    // Update student progress for the lesson
    const video = await prisma.video.findUnique({
      where: { id: session.videoId },
      include: {
        videoGroup: {
          include: {
            lesson: true
          }
        }
      }
    })

    if (video?.videoGroup?.lesson) {
      // Update or create student progress for the lesson
      await prisma.studentProgress.upsert({
        where: {
          studentId_lessonId: {
            studentId,
            lessonId: video.videoGroup.lesson.id
          }
        },
        update: {
          completedMilestones: {
            increment: updatedSession.milestoneProgress.length
          },
          totalTimeSpent: {
            increment: completionData.totalWatchTime
          },
          updatedAt: new Date()
        },
        create: {
          studentId,
          lessonId: video.videoGroup.lesson.id,
          completedMilestones: updatedSession.milestoneProgress.length,
          totalTimeSpent: completionData.totalWatchTime,
          startedAt: new Date()
        }
      })
    }

    return updatedSession
  }

  static async markMilestoneReached(
    sessionId: string,
    milestoneId: string,
    timestamp: number,
    studentId: string
  ) {
    // Verify session exists and belongs to student
    const session = await prisma.studentSession.findFirst({
      where: {
        id: sessionId,
        studentId
      }
    })

    if (!session) {
      throw new Error('Session not found')
    }

    // Verify milestone exists for this video
    const milestone = await prisma.milestone.findFirst({
      where: {
        id: milestoneId,
        videoId: session.videoId
      }
    })

    if (!milestone) {
      throw new Error('Milestone not found')
    }

    // Check if milestone already reached
    const existing = await prisma.milestoneProgress.findFirst({
      where: {
        sessionId,
        milestoneId
      }
    })

    if (existing) {
      return existing
    }

    // Create milestone progress record
    const milestoneProgress = await prisma.milestoneProgress.create({
      data: {
        sessionId,
        milestoneId,
        reachedAt: new Date()
      },
      include: {
        milestone: true
      }
    })

    // Update session's completed milestones
    await prisma.studentSession.update({
      where: { id: sessionId },
      data: {
        lastMilestoneId: milestoneId,
        completedMilestones: {
          push: milestoneId
        },
        currentPosition: timestamp,
        lastSeenAt: new Date()
      }
    })

    return milestoneProgress
  }

  static async submitAnswer(
    sessionId: string,
    answerData: SubmitAnswerData,
    studentId: string
  ) {
    // Verify session exists and belongs to student
    const session = await prisma.studentSession.findFirst({
      where: {
        id: sessionId,
        studentId
      }
    })

    if (!session) {
      throw new Error('Session not found')
    }

    // Verify question exists
    const question = await prisma.question.findFirst({
      where: {
        id: answerData.questionId,
        milestoneId: answerData.milestoneId
      }
    })

    if (!question) {
      throw new Error('Question not found')
    }

    // Check answer correctness based on question type
    let isCorrect = false
    let score = 0
    let explanation = ''

    const questionData = question.questionData as any

    switch (question.type) {
      case 'MULTIPLE_CHOICE':
        isCorrect = questionData.correctAnswer === answerData.answer
        score = isCorrect ? 100 : 0
        explanation = questionData.explanation || ''
        break
        
      case 'TRUE_FALSE':
        isCorrect = questionData.correctAnswer === answerData.answer
        score = isCorrect ? 100 : 0
        explanation = questionData.explanation || ''
        break
        
      case 'SHORT_ANSWER':
        // For short answer, check if answer contains key terms
        const keyTerms = questionData.keyTerms || []
        const answerLower = answerData.answer.toLowerCase()
        const matchedTerms = keyTerms.filter((term: string) => 
          answerLower.includes(term.toLowerCase())
        )
        score = keyTerms.length > 0 
          ? Math.round((matchedTerms.length / keyTerms.length) * 100)
          : 50 // Default partial credit for short answers
        isCorrect = score >= 70
        explanation = questionData.explanation || ''
        break
        
      case 'FILL_IN_BLANK':
        const acceptableAnswers = questionData.acceptableAnswers || []
        isCorrect = acceptableAnswers.some((acceptable: string) => 
          acceptable.toLowerCase() === answerData.answer.toLowerCase()
        )
        score = isCorrect ? 100 : 0
        explanation = questionData.explanation || ''
        break
    }

    // Create question attempt record
    const attempt = await prisma.questionAttempt.create({
      data: {
        sessionId,
        studentId,
        questionId: answerData.questionId,
        studentAnswer: answerData.answer, // This is the correct field name for the answer
        status: isCorrect ? 'CORRECT' : 'INCORRECT',
        isCorrect,
        score,
        attemptNumber: 1, // TODO: Track multiple attempts
        timeSpent: 0,
        hintsUsed: [],
        feedback: explanation
      },
      include: {
        question: true
      }
    })

    return {
      answer: attempt,
      isCorrect,
      score,
      explanation
    }
  }

  static async getUserSessions(options: GetUserSessionsOptions) {
    const { studentId, page, limit, status } = options
    const offset = (page - 1) * limit

    // Build where clause
    const whereClause: any = {
      studentId
    }

    if (status) {
      whereClause.status = status
    }

    const [sessions, total] = await Promise.all([
      prisma.studentSession.findMany({
        where: whereClause,
        include: {
          video: {
            include: {
              videoGroup: {
                select: {
                  id: true,
                  title: true
                }
              }
            }
          },
          // Remove _count from StudentSessionInclude as it's not supported
        },
        orderBy: { lastSeenAt: 'desc' },
        skip: offset,
        take: limit
      }),
      prisma.studentSession.count({ where: whereClause })
    ])

    return {
      sessions,
      total
    }
  }
}
</file>

<file path="README.md">
# Interactive Learning Platform - Business Analysis

## Project Overview
An interactive video-based learning system that pauses at key milestones to present AI-generated questions. Students must answer correctly to continue, creating an engaging and validated learning experience.

## Business Requirements

### 1. System Purpose
- Deliver general education content through interactive video learning
- Ensure comprehension through milestone-based assessments
- Provide progress tracking and analytics for all stakeholders
- Support multi-tenant architecture with role-based access

### 2. User Roles & Permissions

#### 2.1 Students (Learners)
- **Access**: Enrolled lessons and videos
- **Capabilities**:
  - Watch interactive videos with milestone questions
  - Answer questions to progress through content
  - View personal progress and grades
  - Resume sessions across devices
- **Restrictions**: Cannot access unpublished content or admin features

#### 2.2 Teachers (Content Creators)
- **Access**: Content creation and management tools
- **Capabilities**:
  - Create and manage lessons with metadata (title, description, difficulty, tags, estimated time)
  - Save lessons as drafts for iterative development
  - Upload videos to Google database with automatic video group creation
  - Annotate videos with milestone markers and timestamps
  - Request AI-generated questions for milestones
  - Review and approve AI-generated questions before publication
  - Set retry limits and grading criteria for questions
  - Publish/unpublish lessons when content is ready
  - View and manage personal lesson library with status filtering (Draft/Published/Archived)
  - Access comprehensive student progress analytics for their content
  - Search and organize lesson content efficiently
- **Restrictions**: Can only manage their own content, cannot access other teachers' drafts

#### 2.3 Administrators
- **Access**: Full system access
- **Capabilities**:
  - Manage all users (students, teachers)
  - System configuration and settings
  - Global analytics and reporting
  - Content moderation and approval
  - AI API configuration and management
- **Restrictions**: None

### 3. Content Structure

#### 3.1 Hierarchical Organization
1. Lessons
2. Groups of Videos
3. Groups of Questions per Video
4. Individual Questions at Milestones

#### 3.2 Content Lifecycle
1. **Lesson Creation**: Teacher creates lesson with metadata (title, description, difficulty, estimated time, tags)
2. **Draft Storage**: Lesson saved as DRAFT status for iterative development
3. **Video Upload**: Teacher uploads videos with automatic video group creation
4. **Annotation**: Teacher marks milestone timestamps on videos
5. **Question Generation**: AI generates questions based on milestone annotations
6. **Review & Approval**: Teacher reviews, edits, and approves AI-generated questions
7. **Configuration**: Teacher sets retry limits, grading criteria, and question parameters
8. **Publication**: Teacher publishes lesson (DRAFT → PUBLISHED), making it available to students
9. **Analytics**: System tracks student engagement, progress, and performance metrics
10. **Management**: Teachers can archive, update, or unpublish lessons as needed

### 4. Core Functionality

#### 4.1 Interactive Video Player
- **Video Playback**: Standard controls with milestone integration
- **Milestone Detection**: Automatic pause at annotated timestamps
- **Question Display**: Modal/overlay presentation of questions
- **Progress Blocking**: Video cannot advance without correct answers
- **Session Persistence**: Resume from last position across devices

#### 4.2 Question Management
- **AI Generation**: Multiple question types determined by AI
- **Question Types**: Multiple choice, short answer, true/false, etc.
- **Retry Logic**: Configurable retry limits per milestone
- **Grading System**: Point-based scoring with pass/fail thresholds
- **Adaptive Content**: Same difficulty for all users (no personalization)

#### 4.3 Progress Tracking
- **Individual Progress**: Per-student completion and scoring
- **Session Management**: Cross-session progress persistence
- **Analytics Dashboard**: Performance metrics for teachers and admins
- **Reporting**: Detailed progress reports and learning analytics

### 5. Technical Requirements

#### 5.1 Technology Stack
- **Frontend**: React.js with TypeScript
- **Backend**: Node.js with TypeScript
- **Database**: PostgreSQL for structured data
- **Video Storage**: Google Cloud Storage
- **AI Integration**: Configurable AI APIs (OpenAI, Claude, etc.)
- **Authentication**: JWT-based with role management

#### 5.2 Integration Requirements
- **AI Services**: Flexible API integration for question generation
- **Video Services**: Google Cloud Storage integration
- **Analytics**: Real-time progress tracking and reporting
- **Cross-Platform**: Web-based responsive design

### 6. User Experience Requirements

#### 6.1 Student Experience
- Seamless video viewing with minimal interruption
- Clear question presentation with intuitive UI
- Immediate feedback on answers
- Visual progress indicators
- Mobile-responsive design

#### 6.2 Teacher Experience
- **Lesson Creation Workflow**: Streamlined lesson creation with comprehensive metadata fields
- **Draft Management**: Save and resume work on lessons with DRAFT status
- **Content Organization**: Personal lesson library with filtering (All/Draft/Published/Archived)
- **Search & Discovery**: Efficient lesson search and organization tools
- **Video Upload**: Simple video upload with automatic video group creation
- **Intuitive Annotation Tools**: Easy milestone marker placement and timestamp management
- **AI Integration**: Seamless AI question generation with review and approval workflow
- **Publishing Control**: One-click publishing when lessons are ready for students
- **Analytics Dashboard**: Comprehensive student progress and engagement analytics
- **Status Management**: Clear visual indicators for lesson status (Draft/Published/Archived)

#### 6.3 Admin Experience
- System-wide visibility and control
- User management interface
- Configuration management
- Global reporting and analytics
- System health monitoring

### 7. Data Requirements

#### 7.1 User Data
- Authentication credentials and profiles
- Role assignments and permissions
- Progress tracking and session state
- Performance analytics and grades

#### 7.2 Content Data
- Video metadata and storage references
- Milestone annotations and timestamps
- Generated questions and answer keys
- Lesson structure and relationships

#### 7.3 System Data
- AI API configurations and usage metrics
- System logs and audit trails
- Performance metrics and analytics
- Configuration settings and preferences

### 8. Security & Compliance

#### 8.1 Data Protection
- Secure user authentication and authorization
- Encrypted data storage and transmission
- GDPR compliance for user data
- Regular security audits and updates

#### 8.2 Access Control
- Role-based permission system
- Content access restrictions
- API security and rate limiting
- Audit logging for all actions

### 9. Performance Requirements

#### 9.1 System Performance
- Video streaming with minimal buffering
- Fast question generation and loading
- Responsive UI across all devices
- Scalable architecture for growth

#### 9.2 Availability
- 99.9% uptime target
- Graceful error handling
- Backup and disaster recovery
- Load balancing and scaling

### 10. Teacher Lesson Management Workflow

#### 10.1 Lesson Creation Process
1. **Initial Setup**:
   - Teacher navigates to "Create New Lesson" from dashboard or "My Lessons" page
   - Fills out lesson metadata:
     - **Title**: Descriptive lesson name
     - **Description**: Learning objectives and overview
     - **Difficulty**: Beginner/Intermediate/Advanced
     - **Estimated Time**: Duration in minutes
     - **Tags**: Searchable keywords for organization

2. **Draft Storage**:
   - Lesson automatically saved as DRAFT status
   - Teacher can return to work on lesson iteratively
   - Draft lessons only visible to creator

3. **Content Development**:
   - **Video Upload**: Teacher uploads videos with automatic video group creation
   - **Milestone Annotation**: Place markers at key learning points
   - **AI Question Generation**: Generate questions for each milestone
   - **Content Review**: Review and approve AI-generated questions

4. **Publishing**:
   - Teacher reviews complete lesson
   - One-click publish converts DRAFT → PUBLISHED
   - Published lessons become available to students

#### 10.2 Lesson Management Features
- **Personal Library**: Dedicated "My Lessons" page for teachers
- **Status Filtering**: Filter by All/Draft/Published/Archived
- **Search Functionality**: Find lessons by title, description, or tags
- **Status Indicators**: Color-coded badges (yellow=draft, green=published)
- **Bulk Actions**: Publish, archive, or delete multiple lessons
- **Progress Tracking**: View student engagement metrics per lesson

#### 10.3 Navigation & Access
- **Teacher Dashboard**: Quick access to lesson creation and management
- **Sidebar Navigation**: "My Lessons" menu item for teachers
- **Role-Based Access**: Teachers see only their own content
- **Security**: Draft lessons protected from unauthorized access

#### 10.4 Technical Implementation
- **Backend**: Role-based filtering with `createdById` parameter
- **Frontend**: Dedicated React components for teacher workflow
- **Database**: Lesson status tracking (DRAFT/PUBLISHED/ARCHIVED)
- **API Integration**: RESTful endpoints for CRUD operations
- **Real-time Updates**: Lesson status changes reflected immediately

### 11. Success Criteria

#### 11.1 Educational Outcomes
- Improved learning retention through interactive engagement
- Measurable progress tracking and assessment
- Positive user feedback and adoption rates
- Demonstrated learning effectiveness

#### 11.2 Technical Success
- Stable, scalable platform performance
- Successful AI integration and question generation
- Seamless user experience across all roles
- Comprehensive analytics and reporting capabilities

## 12. Next Steps
1. Detailed technical architecture design
2. Database schema development
3. UI/UX wireframes and prototypes
4. Development sprint planning
5. Testing strategy and quality assurance
6. Deployment and launch planning


## 🚀 Quick Start for Developers

See [QUICK_START.md](./QUICK_START.md) for the development setup guide.

```bash
# Get started in 2 commands:
./dev.sh install
./dev.sh start
```
</file>

<file path="frontend/src/pages/lessons/LessonsPage.tsx">
import React, { useState, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import { lessonService } from '../../services/lesson'
import type { Lesson } from '../../services/lesson'

export default function LessonsPage() {
  const navigate = useNavigate()
  const [lessons, setLessons] = useState<Lesson[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [searchTerm, setSearchTerm] = useState('')

  useEffect(() => {
    loadLessons()
  }, [])

  const loadLessons = async () => {
    setLoading(true)
    setError(null)

    try {
      const params: any = {
        page: 1,
        limit: 20,
        status: 'PUBLISHED' // Only show published lessons to students
      }
      
      // Only include search if it's not empty
      if (searchTerm && searchTerm.trim()) {
        params.search = searchTerm.trim()
      }
      
      const response = await lessonService.getLessons(params)
      setLessons(response?.items || [])
    } catch (err: any) {
      console.error('Error loading lessons:', err)
      setError(err.message || 'Failed to load lessons')
      setLessons([]) // Ensure lessons is always an array
    } finally {
      setLoading(false)
    }
  }

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault()
    loadLessons()
  }

  const handleLessonClick = (lessonId: string) => {
    navigate(`/lessons/${lessonId}`)
  }

  // const formatDuration = (seconds: number | null) => {
  //   if (!seconds) return 'Unknown'
  //   const mins = Math.floor(seconds / 60)
  //   const secs = seconds % 60
  //   return `${mins}:${secs.toString().padStart(2, '0')}`
  // }

  if (loading) {
    return (
      <div className="p-6">
        <h1 className="text-2xl font-bold text-gray-900 mb-6">
          Lessons
        </h1>
        <div className="flex items-center justify-center h-64">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading lessons...</p>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="p-6">
      <div className="mb-6">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-2xl font-bold text-gray-900">
              Available Lessons
            </h1>
            <p className="text-gray-600 mt-1">
              Browse and start published interactive video lessons
            </p>
          </div>
          
          {/* Search */}
          <form onSubmit={handleSearch} className="flex items-center space-x-2">
          <input
            type="text"
            placeholder="Search lessons..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          />
          <button
            type="submit"
            className="btn-primary"
          >
            Search
          </button>
          </form>
        </div>
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-md p-4 mb-6">
          <div className="flex">
            <svg className="w-5 h-5 text-red-400 mt-0.5 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
            </svg>
            <p className="text-red-700">{error}</p>
          </div>
        </div>
      )}

      {lessons && lessons.length === 0 && !loading && !error ? (
        <div className="text-center py-12">
          <svg className="w-12 h-12 text-gray-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
          </svg>
          <h3 className="text-lg font-semibold text-gray-900 mb-2">No Published Lessons Available</h3>
          <p className="text-gray-600 mb-4">
            {searchTerm ? 'No published lessons found matching your search.' : 'There are no published lessons available yet. Check back later or contact your instructor.'}
          </p>
          {searchTerm && (
            <button
              onClick={() => {
                setSearchTerm('')
                loadLessons()
              }}
              className="btn-secondary"
            >
              Clear Search
            </button>
          )}
        </div>
      ) : (
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {lessons && lessons.map((lesson) => (
            <div key={lesson.id} className="card" onClick={() => handleLessonClick(lesson.id)} style={{cursor: 'pointer'}}>
              <div className="mb-4">
                <h3 className="text-xl font-semibold text-gray-900 mb-2">
                  {lesson.title}
                </h3>
                {lesson.description && (
                  <p className="text-gray-600 mb-3">
                    {lesson.description}
                  </p>
                )}
                
                {/* Tags */}
                {lesson.tags && lesson.tags.length > 0 && (
                  <div className="flex flex-wrap gap-2 mb-3">
                    {lesson.tags.map((tag, index) => (
                      <span
                        key={index}
                        className="px-2 py-1 bg-blue-100 text-blue-700 text-sm rounded-full"
                      >
                        {tag}
                      </span>
                    ))}
                  </div>
                )}

                {/* Stats */}
                <div className="text-sm text-gray-500 mb-4 flex items-center gap-2">
                  {lesson.difficulty && (
                    <span className="capitalize">{lesson.difficulty}</span>
                  )}
                  {lesson.estimatedTime && (
                    <span> • {lesson.estimatedTime} min</span>
                  )}
                </div>
              </div>

              {/* Lesson Content Preview */}
              <div className="text-center py-4">
                <div className="inline-flex items-center px-4 py-2 bg-blue-50 text-blue-700 rounded-lg hover:bg-blue-100 transition-colors">
                  <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1.01M15 10h1.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                  Click to start learning
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}
</file>

<file path="frontend/src/services/api.ts">
import axios from 'axios'
import type { AxiosInstance, AxiosRequestConfig, AxiosError } from 'axios'
import TokenManager from './tokenManager'
import { debug } from '../utils/debug'

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000/api/v1'

class ApiService {
  private api: AxiosInstance
  private isRefreshing = false
  private failedQueue: Array<{
    resolve: (token: string) => void
    reject: (error: any) => void
  }> = []

  constructor() {
    this.api = axios.create({
      baseURL: API_BASE_URL,
      headers: {
        'Content-Type': 'application/json',
      },
      timeout: 30000, // 30 second timeout
    })

    this.setupInterceptors()
  }

  private processQueue(error: any, token: string | null = null) {
    this.failedQueue.forEach(prom => {
      if (error) {
        prom.reject(error)
      } else {
        prom.resolve(token!)
      }
    })
    
    this.failedQueue = []
  }

  private setupInterceptors() {
    // Request interceptor - add auth token
    this.api.interceptors.request.use(
      async (config) => {
        // Check if token needs refresh before making request
        if (TokenManager.shouldRefreshToken() && !this.isRefreshing) {
          debug.auth('Token needs refresh before request')
          window.dispatchEvent(new CustomEvent('auth:token-refresh-needed'))
        }

        // Get current token (might be refreshed by now)
        const token = TokenManager.getAccessToken()
        if (token) {
          config.headers.Authorization = `Bearer ${token}`
        }
        
        // Handle FormData - don't set Content-Type, let axios handle it
        if (config.data instanceof FormData) {
          delete config.headers['Content-Type']
        }
        
        // Add request timestamp for debugging
        (config as any).metadata = { startTime: new Date() }
        
        return config
      },
      (error) => {
        return Promise.reject(error)
      }
    )

    // Response interceptor - handle errors and token refresh
    this.api.interceptors.response.use(
      (response) => {
        // Log request duration in development
        if ((response.config as any).metadata) {
          const duration = new Date().getTime() - (response.config as any).metadata.startTime.getTime()
          debug.api(response.config.method?.toUpperCase() || 'GET', response.config.url || '', duration)
        }
        
        return response
      },
      async (error: AxiosError) => {
        const originalRequest = error.config as any
        
        // Log error details
        debug.error('API Error:', {
          status: error.response?.status,
          url: originalRequest?.url,
          method: originalRequest?.method,
          data: error.response?.data,
        })

        // Handle 401 Unauthorized
        if (error.response?.status === 401 && originalRequest) {
          // Skip refresh for auth endpoints
          if (originalRequest.url?.includes('/auth/')) {
            return Promise.reject(error)
          }

          if (originalRequest._retry) {
            // Already tried to refresh, give up
            TokenManager.clearTokens()
            window.dispatchEvent(new CustomEvent('auth:expired'))
            return Promise.reject(error)
          }

          originalRequest._retry = true

          // If not already refreshing, start refresh
          if (!this.isRefreshing) {
            this.isRefreshing = true
            const refreshToken = TokenManager.getRefreshToken()

            if (!refreshToken) {
              this.isRefreshing = false
              TokenManager.clearTokens()
              window.dispatchEvent(new CustomEvent('auth:expired'))
              return Promise.reject(error)
            }

            try {
              const response = await axios.post(`${API_BASE_URL}/auth/refresh`, {
                refreshToken,
              })

              const { accessToken, refreshToken: newRefreshToken } = response.data.data.tokens
              
              // Store new tokens
              TokenManager.setTokens(accessToken, newRefreshToken)
              
              // Process queued requests
              this.processQueue(null, accessToken)
              
              // Retry original request
              originalRequest.headers.Authorization = `Bearer ${accessToken}`
              return this.api(originalRequest)
            } catch (refreshError) {
              // Refresh failed
              this.processQueue(refreshError, null)
              TokenManager.clearTokens()
              window.dispatchEvent(new CustomEvent('auth:expired'))
              return Promise.reject(refreshError)
            } finally {
              this.isRefreshing = false
            }
          }

          // If already refreshing, queue this request
          return new Promise((resolve, reject) => {
            this.failedQueue.push({
              resolve: (token: string) => {
                originalRequest.headers.Authorization = `Bearer ${token}`
                resolve(this.api(originalRequest))
              },
              reject: (err: any) => {
                reject(err)
              }
            })
          })
        }

        // Handle network errors
        if (!error.response) {
          debug.error('Network error - no response received')
          error.message = 'Network error - please check your connection'
        }

        // Handle timeout
        if (error.code === 'ECONNABORTED') {
          error.message = 'Request timeout - please try again'
        }

        return Promise.reject(error)
      }
    )
  }

  /**
   * Generic request method
   */
  private async request<T>(config: AxiosRequestConfig): Promise<T> {
    try {
      const response = await this.api.request<T>(config)
      return response.data
    } catch (error: any) {
      // Transform axios error to a more user-friendly format
      const errorMessage = error.response?.data?.error || 
                          error.response?.data?.message || 
                          error.message || 
                          'An unexpected error occurred'
      
      throw {
        ...error,
        message: errorMessage,
        status: error.response?.status,
        data: error.response?.data
      }
    }
  }

  /**
   * GET request
   */
  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    return this.request<T>({ ...config, method: 'GET', url })
  }

  /**
   * POST request
   */
  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    // Debug: Log video upload attempts
    if (url.includes('/videos/groups/') && url.includes('/videos')) {
      console.warn('[ApiService] Video upload POST request:', {
        url,
        data,
        isFormData: data instanceof FormData,
        dataKeys: data instanceof FormData ? 
          Array.from((data as FormData).keys()) : 
          (data ? Object.keys(data) : []),
        hasVideo: data && 'video' in data,
        hasVideoUrl: data && 'videoUrl' in data,
        contentType: config?.headers?.['Content-Type'],
        stack: new Error().stack?.split('\n').slice(2, 7).join('\n')
      })
    }
    
    return this.request<T>({ ...config, method: 'POST', url, data })
  }

  /**
   * PUT request
   */
  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    return this.request<T>({ ...config, method: 'PUT', url, data })
  }

  /**
   * DELETE request
   */
  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    return this.request<T>({ ...config, method: 'DELETE', url })
  }

  /**
   * PATCH request
   */
  async patch<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    return this.request<T>({ ...config, method: 'PATCH', url, data })
  }

  /**
   * Set auth token manually (used after login)
   */
  setAuthToken(token: string) {
    this.api.defaults.headers.common['Authorization'] = `Bearer ${token}`
  }

  /**
   * Remove auth token
   */
  removeAuthToken() {
    delete this.api.defaults.headers.common['Authorization']
  }

  /**
   * Cancel all pending requests
   */
  cancelAllRequests(message = 'Request cancelled') {
    // This would require implementing AbortController
    debug.log('Cancelling all requests:', message)
  }
}

export const apiService = new ApiService()
export default apiService
</file>

<file path="src/routes/milestoneRoutes.ts">
import { Router, Response } from 'express'
import { body } from 'express-validator'
import { validationResult } from 'express-validator'
import { validateCUIDParam, validateCUIDBody } from '../utils/validators'
import { authenticate } from '../middleware/auth/authMiddleware'
// import { roleMiddleware } from '../middleware/role' // TODO: Create this middleware
import { MilestoneService } from '../services/MilestoneService'
import { AuthenticatedRequest } from '../middleware/auth/authMiddleware'

const router = Router()

// Apply authentication middleware to all routes
router.use(authenticate)

// POST /api/milestones - Create milestone for video (teachers only)
router.post('/',
  // roleMiddleware(['TEACHER', 'ADMIN']), // TODO: Create this middleware
  validateCUIDBody('videoId', 'Valid video ID is required'),
  body('timestamp').isNumeric().withMessage('Timestamp must be a number'),
  body('title').notEmpty().trim().withMessage('Title is required'),
  body('description').optional().trim(),
  body('isRequired').optional().isBoolean().withMessage('isRequired must be boolean'),
  body('retryLimit').optional().isInt({ min: 1 }).withMessage('Retry limit must be a positive integer'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const milestoneData = {
        videoId: req.body.videoId,
        timestamp: Number(req.body.timestamp),
        title: req.body.title,
        description: req.body.description || null,
        isRequired: req.body.isRequired,
        retryLimit: req.body.retryLimit
      }

      const milestone = await MilestoneService.createMilestone(milestoneData, req.user!)

      return res.status(201).json({
        success: true,
        data: milestone,
        message: 'Milestone created successfully'
      })

    } catch (error: any) {
      console.error('Error creating milestone:', error)
      
      if (error.message === 'Video not found') {
        return res.status(404).json({
          success: false,
          error: 'Video not found'
        })
      }
      
      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      if (error.message.includes('Milestone already exists')) {
        return res.status(409).json({
          success: false,
          error: error.message
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to create milestone'
      })
    }
  }
)

// GET /api/milestones/video/:videoId - Get all milestones for a video
router.get('/video/:videoId',
  validateCUIDParam('videoId', 'Invalid video ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const milestones = await MilestoneService.getMilestonesByVideo(req.params.videoId, req.user!.id)

      return res.json({
        success: true,
        data: milestones
      })

    } catch (error: any) {
      console.error('Error fetching milestones:', error)
      
      if (error.message === 'Video not found') {
        return res.status(404).json({
          success: false,
          error: 'Video not found'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to fetch milestones'
      })
    }
  }
)

// PUT /api/milestones/:id - Update milestone (creator or admin only)
router.put('/:id',
  validateCUIDParam('id', 'Invalid milestone ID'),
  body('timestamp').optional().isNumeric().withMessage('Timestamp must be a number'),
  body('title').optional().notEmpty().trim().withMessage('Title cannot be empty'),
  body('description').optional().trim(),
  body('isRequired').optional().isBoolean().withMessage('isRequired must be boolean'),
  body('retryLimit').optional().isInt({ min: 1 }).withMessage('Retry limit must be a positive integer'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const updateData = {
        timestamp: req.body.timestamp ? Number(req.body.timestamp) : undefined,
        title: req.body.title,
        description: req.body.description,
        isRequired: req.body.isRequired,
        retryLimit: req.body.retryLimit
      }

      const milestone = await MilestoneService.updateMilestone(
        req.params.id,
        updateData,
        req.user!
      )

      return res.json({
        success: true,
        data: milestone,
        message: 'Milestone updated successfully'
      })

    } catch (error: any) {
      console.error('Error updating milestone:', error)
      
      if (error.message === 'Milestone not found') {
        return res.status(404).json({
          success: false,
          error: 'Milestone not found'
        })
      }
      
      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      if (error.message.includes('Milestone already exists')) {
        return res.status(409).json({
          success: false,
          error: error.message
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to update milestone'
      })
    }
  }
)

// DELETE /api/milestones/:id - Delete milestone (creator or admin only)
router.delete('/:id',
  validateCUIDParam('id', 'Invalid milestone ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      await MilestoneService.deleteMilestone(req.params.id, req.user!)

      return res.json({
        success: true,
        message: 'Milestone deleted successfully'
      })

    } catch (error: any) {
      console.error('Error deleting milestone:', error)
      
      if (error.message === 'Milestone not found') {
        return res.status(404).json({
          success: false,
          error: 'Milestone not found'
        })
      }
      
      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to delete milestone'
      })
    }
  }
)

// POST /api/milestones/:id/questions - Add question to milestone (creator or admin only)
router.post('/:id/questions',
  // roleMiddleware(['TEACHER', 'ADMIN']), // TODO: Create this middleware
  validateCUIDParam('id', 'Invalid milestone ID'),
  body('type').isIn(['MULTIPLE_CHOICE', 'TRUE_FALSE', 'SHORT_ANSWER', 'FILL_IN_BLANK']).withMessage('Invalid question type'),
  body('text').notEmpty().trim().withMessage('Question text is required'),
  body('explanation').optional().trim(),
  body('hints').optional().isArray().withMessage('Hints must be an array'),
  body('difficulty').optional().isIn(['easy', 'medium', 'hard']).withMessage('Invalid difficulty level'),
  body('questionData').notEmpty().withMessage('Question data is required'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const questionData = {
        milestoneId: req.params.id,
        type: req.body.type,
        text: req.body.text,
        explanation: req.body.explanation || null,
        hints: req.body.hints || [],
        difficulty: req.body.difficulty || null,
        questionData: req.body.questionData
      }

      const question = await MilestoneService.addQuestionToMilestone(questionData, req.user!)

      return res.status(201).json({
        success: true,
        data: question,
        message: 'Question added successfully'
      })

    } catch (error: any) {
      console.error('Error adding question:', error)
      
      if (error.message === 'Milestone not found') {
        return res.status(404).json({
          success: false,
          error: 'Milestone not found'
        })
      }
      
      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to add question'
      })
    }
  }
)

export default router
</file>

<file path="frontend/src/components/video/QuestionOverlay.tsx">
import { useState } from 'react'
import type { Milestone } from '../../services/video'
import { debug } from '../../utils/debug'

interface QuestionOverlayProps {
  milestone: Milestone
  onAnswerSubmit: (questionId: string, answer: string) => Promise<{ isCorrect: boolean; explanation?: string }>
  onComplete: () => void
}

export function QuestionOverlay({
  milestone,
  onAnswerSubmit,
  onComplete
}: QuestionOverlayProps) {
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0)
  const [selectedAnswer, setSelectedAnswer] = useState('')
  const [selectedAnswerText, setSelectedAnswerText] = useState('') // For display purposes
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [feedback, setFeedback] = useState<{
    isCorrect: boolean
    explanation?: string
    shown: boolean
  } | null>(null)
  const [completedQuestions, setCompletedQuestions] = useState<Set<number>>(new Set())
  const [showCorrectAnswer, setShowCorrectAnswer] = useState(false)
  
  const questions = milestone.questions || []
  const currentQuestion = questions[currentQuestionIndex]

  if (!currentQuestion) {
    return null
  }

  const handleSubmitAnswer = async () => {
    if (!selectedAnswer.trim() || isSubmitting) return

    setIsSubmitting(true)
    try {
      const result = await onAnswerSubmit(currentQuestion.id, selectedAnswer)
      setFeedback({
        isCorrect: result.isCorrect,
        explanation: result.explanation,
        shown: true
      })
      setCompletedQuestions(prev => new Set(prev).add(currentQuestionIndex))
    } catch (error) {
      debug.error('Failed to submit answer:', error)
    } finally {
      setIsSubmitting(false)
    }
  }

  const handleNext = () => {
    if (currentQuestionIndex < questions.length - 1) {
      setCurrentQuestionIndex(prev => prev + 1)
      setSelectedAnswer('')
      setSelectedAnswerText('')
      setFeedback(null)
    } else {
      onComplete()
    }
  }

  const handleOptionSelect = (option: string, index?: number) => {
    if (feedback?.shown) return
    // For multiple choice, store both the option text and index
    if (currentQuestion.type === 'MULTIPLE_CHOICE' && index !== undefined) {
      setSelectedAnswer(index.toString())
      setSelectedAnswerText(option)
    } else {
      setSelectedAnswer(option)
      setSelectedAnswerText(option)
    }
  }

  const renderQuestionContent = () => {
    switch (currentQuestion.type) {
      case 'MULTIPLE_CHOICE': {
        // Questions from backend have questionData with options array
        const options = currentQuestion.questionData?.options || []
        const correctIndex = currentQuestion.questionData?.correctAnswerIndex || 0
        
        return (
          <div className="space-y-3">
            {options.map((option: string, index: number) => (
              <button
                key={index}
                onClick={() => handleOptionSelect(option, index)}
                disabled={feedback?.shown}
                className={`w-full p-4 text-left rounded-lg border-2 transition-all ${
                  selectedAnswer === index.toString()
                    ? feedback?.shown
                      ? index === correctIndex
                        ? 'border-green-500 bg-green-50'
                        : 'border-red-500 bg-red-50'
                      : 'border-blue-500 bg-blue-50'
                    : feedback?.shown && index === correctIndex
                      ? 'border-green-500 bg-green-50'
                      : 'border-gray-300 hover:border-gray-400'
                } ${feedback?.shown ? 'cursor-default' : 'cursor-pointer hover:bg-gray-50'}`}
              >
                <div className="flex items-center">
                  <div className={`w-4 h-4 rounded-full border-2 mr-3 ${
                    selectedAnswer === index.toString()
                      ? feedback?.shown
                        ? index === correctIndex
                          ? 'border-green-500 bg-green-500'
                          : 'border-red-500 bg-red-500'
                        : 'border-blue-500 bg-blue-500'
                      : feedback?.shown && index === correctIndex
                        ? 'border-green-500 bg-green-500'
                        : 'border-gray-300'
                  }`}>
                    {(selectedAnswer === index.toString() || (feedback?.shown && index === correctIndex)) && (
                      <div className="w-full h-full rounded-full bg-white scale-50"></div>
                    )}
                  </div>
                  <span className="text-gray-800">{option}</span>
                </div>
              </button>
            ))}
          </div>
        )
      }

      case 'TRUE_FALSE': {
        const correctAnswer = currentQuestion.questionData?.correctAnswer
        
        return (
          <div className="space-y-3">
            {['True', 'False'].map((option) => (
              <button
                key={option}
                onClick={() => handleOptionSelect(option)}
                disabled={feedback?.shown}
                className={`w-full p-4 text-left rounded-lg border-2 transition-all ${
                  selectedAnswer === option
                    ? feedback?.shown
                      ? (option === 'True' && correctAnswer === true) || (option === 'False' && correctAnswer === false)
                        ? 'border-green-500 bg-green-50'
                        : 'border-red-500 bg-red-50'
                      : 'border-blue-500 bg-blue-50'
                    : feedback?.shown && ((option === 'True' && correctAnswer === true) || (option === 'False' && correctAnswer === false))
                      ? 'border-green-500 bg-green-50'
                      : 'border-gray-300 hover:border-gray-400'
                } ${feedback?.shown ? 'cursor-default' : 'cursor-pointer hover:bg-gray-50'}`}
              >
                <div className="flex items-center">
                  <div className={`w-4 h-4 rounded-full border-2 mr-3 ${
                    selectedAnswer === option
                      ? feedback?.shown
                        ? (option === 'True' && correctAnswer === true) || (option === 'False' && correctAnswer === false)
                          ? 'border-green-500 bg-green-500'
                          : 'border-red-500 bg-red-500'
                        : 'border-blue-500 bg-blue-500'
                      : feedback?.shown && ((option === 'True' && correctAnswer === true) || (option === 'False' && correctAnswer === false))
                        ? 'border-green-500 bg-green-500'
                        : 'border-gray-300'
                  }`}>
                    {(selectedAnswer === option || (feedback?.shown && ((option === 'True' && correctAnswer === true) || (option === 'False' && correctAnswer === false)))) && (
                      <div className="w-full h-full rounded-full bg-white scale-50"></div>
                    )}
                  </div>
                  <span className="text-gray-800">{option}</span>
                </div>
              </button>
            ))}
          </div>
        )
      }

      case 'SHORT_ANSWER':
        return (
          <div>
            <textarea
              value={selectedAnswer}
              onChange={(e) => {
                setSelectedAnswer(e.target.value)
                setSelectedAnswerText(e.target.value)
              }}
              disabled={feedback?.shown}
              placeholder="Type your answer here..."
              className={`w-full p-3 border rounded-lg resize-none h-24 focus:outline-none focus:ring-2 ${
                feedback?.shown
                  ? feedback.isCorrect
                    ? 'border-green-500 bg-green-50 focus:ring-green-500'
                    : 'border-red-500 bg-red-50 focus:ring-red-500'
                  : 'focus:ring-blue-500'
              }`}
            />
            {feedback?.shown && (
              <div className="mt-2 text-sm text-gray-600">
                <strong>Your answer:</strong> {selectedAnswer}
              </div>
            )}
          </div>
        )

      default:
        return null
    }
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[100]">
      <div className="bg-white rounded-lg max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto">
        <div className="p-6">
          {/* Header */}
          <div className="flex items-center justify-between mb-6">
            <div>
              <h2 className="text-xl font-bold text-gray-900">{milestone.title}</h2>
              <p className="text-sm text-gray-600 mt-1">
                Question {currentQuestionIndex + 1} of {questions.length}
              </p>
            </div>
            <div className="flex space-x-1">
              {questions.map((_, index) => (
                <div
                  key={index}
                  className={`w-3 h-3 rounded-full ${
                    index === currentQuestionIndex
                      ? 'bg-blue-500'
                      : completedQuestions.has(index)
                      ? 'bg-green-500'
                      : 'bg-gray-300'
                  }`}
                />
              ))}
            </div>
          </div>

          {/* Question */}
          <div className="mb-6">
            <h3 className="text-lg font-semibold text-gray-800 mb-4">
              {currentQuestion.text || (currentQuestion as unknown as {question: string}).question}
            </h3>
            {renderQuestionContent()}
          </div>

          {/* Feedback */}
          {feedback?.shown && (
            <div className={`p-4 rounded-lg mb-6 ${
              feedback.isCorrect ? 'bg-green-50 border border-green-200' : 'bg-red-50 border border-red-200'
            }`}>
              <div className="flex items-center justify-between mb-2">
                <div className="flex items-center">
                  {feedback.isCorrect ? (
                    <svg className="w-5 h-5 text-green-600 mr-2" fill="currentColor" viewBox="0 0 20 20">
                      <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                    </svg>
                  ) : (
                    <svg className="w-5 h-5 text-red-600 mr-2" fill="currentColor" viewBox="0 0 20 20">
                      <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                    </svg>
                  )}
                  <span className={`font-semibold ${
                    feedback.isCorrect ? 'text-green-800' : 'text-red-800'
                  }`}>
                    {feedback.isCorrect ? 'Correct!' : 'Incorrect'}
                  </span>
                </div>
                {!feedback.isCorrect && (
                  <button
                    onClick={() => setShowCorrectAnswer(!showCorrectAnswer)}
                    className="text-sm px-2 py-1 text-red-600 hover:text-red-800 underline"
                  >
                    {showCorrectAnswer ? 'Hide' : 'Show'} Correct Answer
                  </button>
                )}
              </div>
              
              {!feedback.isCorrect && showCorrectAnswer && (
                <div className="mb-3 p-2 bg-green-50 border border-green-200 rounded">
                  <p className="text-sm text-green-800">
                    <strong>Correct answer:</strong> {
                      currentQuestion.type === 'MULTIPLE_CHOICE' 
                        ? currentQuestion.questionData?.options?.[currentQuestion.questionData?.correctAnswerIndex]
                        : currentQuestion.type === 'TRUE_FALSE'
                        ? currentQuestion.questionData?.correctAnswer ? 'True' : 'False'
                        : currentQuestion.questionData?.correctAnswers?.[0] || 'N/A'
                    }
                  </p>
                </div>
              )}
              
              {feedback.explanation && (
                <p className={`text-sm ${
                  feedback.isCorrect ? 'text-green-700' : 'text-red-700'
                }`}>
                  <strong>Explanation:</strong> {feedback.explanation}
                </p>
              )}
            </div>
          )}

          {/* Actions */}
          <div className="flex justify-between">
            <div className="text-sm text-gray-500">
              {milestone.description}
            </div>
            
            <div className="flex space-x-3">
              {!feedback?.shown ? (
                <button
                  onClick={handleSubmitAnswer}
                  disabled={!selectedAnswer.trim() || isSubmitting}
                  className={`px-6 py-2 rounded-lg font-medium transition-colors ${
                    selectedAnswer.trim() && !isSubmitting
                      ? 'bg-blue-600 text-white hover:bg-blue-700'
                      : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                  }`}
                >
                  {isSubmitting ? 'Submitting...' : 'Submit Answer'}
                </button>
              ) : (
                <button
                  onClick={handleNext}
                  className="px-6 py-2 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 transition-colors"
                >
                  {currentQuestionIndex < questions.length - 1 ? 'Next Question' : 'Continue Video'}
                </button>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/pages/video/VideoPlayerPage.tsx">
import { useState, useEffect } from 'react'
import { useParams, useNavigate } from 'react-router-dom'
import { VideoPlayer } from '../../components/video/VideoPlayer'
import { sessionService } from '../../services/video'
import type { VideoSession } from '../../services/video'
import { useVideoState, useSessionState } from '../../hooks/useVideoState'
import { useVideoStateManager } from '../../contexts/VideoStateContext'
import { ProgressCalculator } from '../../utils/progressCalculator'

export default function VideoPlayerPage() {
  const { videoId } = useParams<{ videoId: string }>()
  const navigate = useNavigate()
  const manager = useVideoStateManager()
  
  // Use unified state
  const { video, loading: videoLoading, error: videoError } = useVideoState(videoId)
  console.log('🎬 VideoPlayerPage - video state:', { video: video?.id, loading: videoLoading, error: videoError, duration: video?.duration })
  console.log('🎬 Full video object:', video)
  const [sessionId, setSessionId] = useState<string | null>(null)
  const { session, metadata: sessionMeta } = useSessionState(sessionId || undefined)
  console.log('📊 Session data:', { sessionId, session: session?.id, status: session?.status, currentPosition: session?.currentPosition, milestones: session?.milestoneProgress?.length, attempts: session?.questionAttempts?.length, sessionMeta })
  
  // Track when component re-renders
  console.log('🔄 VideoPlayerPage re-render:', { 
    videoId, 
    videoLoaded: !!video, 
    videoDuration: video?.duration,
    sessionLoaded: !!session, 
    sessionPosition: session?.currentPosition,
    sessionStatus: session?.status,
    timestamp: new Date().toISOString() 
  })
  
  // Debug what we're passing to ProgressCalculator
  console.log('🔍 About to call ProgressCalculator with:', {
    video: video ? { id: video.id, duration: video.duration } : null,
    session: session ? { id: session.id, currentPosition: session.currentPosition, status: session.status } : null,
    sessionMeta
  })
  
  // Let's also see what progress is being calculated each time
  if (video || session) {
    const progressData = ProgressCalculator.calculateAllProgress(session, video, sessionMeta)
    console.log('📊 Calculated progress data:', progressData)
  }
  
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [completionMessage, setCompletionMessage] = useState<string | null>(null)

  useEffect(() => {
    if (!videoId) {
      navigate('/lessons')
      return
    }

    loadVideo()
    loadSession()
  }, [videoId])

  const loadSession = async () => {
    if (!videoId) return

    try {
      console.log('🔍 Loading existing session for video:', videoId)
      const sessionResponse = await sessionService.getSessionByVideo(videoId)
      if (sessionResponse) {
        console.log('📊 Found existing session:', sessionResponse.id, sessionResponse)
        setSessionId(sessionResponse.id)
        
        // Trigger session state in VideoStateManager by calling startOrResumeSession
        // This will load the session data properly into the state manager
        await manager.startOrResumeSession(videoId)
      } else {
        console.log('❌ No existing session found')
      }
    } catch (sessionError) {
      console.log('❌ Error loading session:', sessionError)
    }
  }

  const loadVideo = async () => {
    if (!videoId) return

    setLoading(true)
    setError(null)

    try {
      // Load video through VideoStateManager
      await manager.loadVideo(videoId)
    } catch (err: any) {
      console.error('Error loading video:', err)
      setError(err.message || 'Failed to load video')
    } finally {
      setLoading(false)
    }
  }

  const handleSessionStart = async (videoId: string): Promise<VideoSession> => {
    const sessionState = await manager.startOrResumeSession(videoId)
    setSessionId(sessionState.session.id)
    return sessionState.session
  }

  const handleProgressUpdate = async (sessionId: string, currentTime: number, totalWatchTime: number) => {
    await manager.updateSessionProgress(sessionId, currentTime, totalWatchTime)
  }

  const handleMilestoneReached = async (sessionId: string, milestoneId: string, timestamp: number) => {
    await manager.markMilestoneReached(sessionId, milestoneId, timestamp)
  }

  const handleAnswerSubmit = async (sessionId: string, questionId: string, answer: string, milestoneId: string) => {
    return await manager.submitAnswer(sessionId, questionId, answer, milestoneId)
  }

  const handleSessionComplete = async (sessionId: string, finalTime: number, totalWatchTime: number) => {
    const response = await sessionService.completeSession(sessionId, {
      finalTime,
      totalWatchTime
    })
    
    // Show completion message
    if (response.status === 'COMPLETED') {
      setCompletionMessage(`Congratulations! You've completed ${video?.title || 'this video'}.`)
      
      // Auto-hide after 5 seconds
      setTimeout(() => setCompletionMessage(null), 5000)
    }
  }

  if (loading || videoLoading) {
    return (
      <div className="p-6">
        <div className="flex items-center justify-center h-64">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading video...</p>
          </div>
        </div>
      </div>
    )
  }

  if (error || videoError) {
    return (
      <div className="p-6">
        <div className="card">
          <div className="text-center py-8">
            <svg className="w-12 h-12 text-red-500 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <h3 className="text-lg font-semibold text-gray-900 mb-2">Failed to Load Video</h3>
            <p className="text-gray-600 mb-4">{error || videoError}</p>
            <button
              onClick={() => navigate('/lessons')}
              className="btn-primary"
            >
              Back to Lessons
            </button>
          </div>
        </div>
      </div>
    )
  }

  if (!video) {
    return (
      <div className="p-6">
        <div className="card">
          <div className="text-center py-8">
            <h3 className="text-lg font-semibold text-gray-900 mb-2">Video Not Found</h3>
            <p className="text-gray-600 mb-4">The requested video could not be found.</p>
            <button
              onClick={() => navigate('/lessons')}
              className="btn-primary"
            >
              Back to Lessons
            </button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="p-6">
      {/* Back Navigation */}
      <div className="mb-6">
        <button
          onClick={() => navigate('/lessons')}
          className="flex items-center text-blue-600 hover:text-blue-700 transition-colors"
        >
          <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
          </svg>
          Back to Lessons
        </button>
      </div>

      {/* Video Group Context */}
      {video.videoGroup && (
        <div className="mb-4">
          <nav className="text-sm text-gray-500">
            <span>{video.videoGroup.title}</span>
            <span className="mx-2">›</span>
            <span className="text-gray-900">{video.title}</span>
          </nav>
        </div>
      )}

      {/* Completion Message */}
      {completionMessage && (
        <div className="mb-4 p-4 bg-green-50 border border-green-200 rounded-lg">
          <div className="flex items-center">
            <svg className="w-6 h-6 text-green-600 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
            </svg>
            <div className="flex-1">
              <p className="text-green-800 font-medium">{completionMessage}</p>
              <div className="flex items-center space-x-4 mt-2">
                <button
                  onClick={() => navigate('/lessons')}
                  className="text-sm text-green-600 hover:text-green-700 underline"
                >
                  Back to Lessons
                </button>
                {video?.videoGroup && (
                  <button
                    onClick={() => navigate(`/lessons/${video.videoGroup?.id}`)}
                    className="text-sm text-green-600 hover:text-green-700 underline"
                  >
                    Continue Lesson Series
                  </button>
                )}
              </div>
            </div>
            <button
              onClick={() => setCompletionMessage(null)}
              className="text-green-600 hover:text-green-800"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>
      )}
      
      {/* Learning Progress - Always show, even with no session */}
      {(() => {
        const progressData = ProgressCalculator.calculateAllProgress(session, video, sessionMeta)
        
        return (
          <div className="mb-6 grid grid-cols-1 md:grid-cols-3 gap-4">
            <div className="card text-center">
              <div className="text-2xl font-bold text-blue-600">
                {progressData.completionPercentage}%
              </div>
              <div className="text-sm text-gray-600 mt-1">Progress</div>
            </div>
            
            <div className="card text-center">
              <div className="text-2xl font-bold text-green-600">
                {progressData.milestonesReached}
              </div>
              <div className="text-sm text-gray-600 mt-1">Milestones Reached</div>
            </div>
            
            <div className="card text-center">
              <div className="text-2xl font-bold text-purple-600">
                {progressData.correctAnswers}
                <span className="text-sm text-gray-500">/{progressData.totalAnswers}</span>
              </div>
              <div className="text-sm text-gray-600 mt-1">Correct Answers</div>
            </div>
          </div>
        )
      })()}

      {/* Interactive Video Player */}
      <VideoPlayer
        video={video}
        session={session}
        onSessionStart={handleSessionStart}
        onProgressUpdate={handleProgressUpdate}
        onMilestoneReached={handleMilestoneReached}
        onAnswerSubmit={handleAnswerSubmit}
        onSessionComplete={handleSessionComplete}
      />
      
      {/* Related Videos */}
      {/* TODO: Load related videos from the same video group */}
      {false && (
        <div className="mt-8">
          <h3 className="text-lg font-semibold text-gray-900 mb-4">More from this Lesson</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {[].map((relatedVideo: any) => (
                <div
                  key={relatedVideo.id}
                  onClick={() => navigate(`/video/${relatedVideo.id}`)}
                  className="card cursor-pointer hover:shadow-md transition-shadow"
                >
                  <div className="aspect-video bg-gray-200 rounded-lg mb-3 flex items-center justify-center">
                    {relatedVideo.thumbnailUrl ? (
                      <img
                        src={relatedVideo.thumbnailUrl}
                        alt={relatedVideo.title}
                        className="w-full h-full object-cover rounded-lg"
                      />
                    ) : (
                      <svg className="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                      </svg>
                    )}
                  </div>
                  <h4 className="font-medium text-gray-900 truncate">{relatedVideo.title}</h4>
                  <p className="text-sm text-gray-500 mt-1">
                    {relatedVideo.duration ? `${Math.floor(relatedVideo.duration / 60)}:${(relatedVideo.duration % 60).toFixed(0).padStart(2, '0')}` : 'Unknown duration'}
                  </p>
                </div>
              ))
            }
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/routes/sessionRoutes.ts">
import { Router, Response } from 'express'
import { body, query } from 'express-validator'
import { validationResult } from 'express-validator'
import { validateCUIDParam, validateCUIDBody } from '../utils/validators'
import { authenticate } from '../middleware/auth/authMiddleware'
import { VideoSessionService } from '../services/VideoSessionService'
import { AuthenticatedRequest } from '../middleware/auth/authMiddleware'

const router = Router()

// Apply authentication middleware to all routes
router.use(authenticate)

// POST /api/sessions/start - Start or resume video session
router.post('/start',
  validateCUIDBody('videoId', 'Valid video ID is required'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const session = await VideoSessionService.startSession(
        req.body.videoId,
        req.user!.id
      )

      // Convert BigInt fields to strings for JSON serialization
      const serializedSession = session ? {
        ...session,
        video: session.video ? {
          ...session.video,
          size: session.video.size ? session.video.size.toString() : null
        } : undefined
      } : null

      return res.json({
        success: true,
        data: serializedSession,
        message: 'Video session started'
      })

    } catch (error: any) {
      console.error('Error starting session:', error)
      
      if (error.message === 'Video not found') {
        return res.status(404).json({
          success: false,
          error: 'Video not found'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to start video session'
      })
    }
  }
)

// PUT /api/sessions/:sessionId/progress - Update session progress
router.put('/:sessionId/progress',
  validateCUIDParam('sessionId', 'Invalid session ID'),
  body('currentTime').isNumeric().withMessage('Current time must be a number'),
  body('totalWatchTime').optional().isNumeric().withMessage('Total watch time must be a number'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const progressData = {
        currentPosition: Math.floor(Number(req.body.currentTime)),
        totalWatchTime: req.body.totalWatchTime ? Math.floor(Number(req.body.totalWatchTime)) : undefined
      }

      const session = await VideoSessionService.updateProgress(
        req.params.sessionId,
        progressData,
        req.user!.id
      )

      // Convert BigInt fields to strings for JSON serialization
      const serializedSession = session ? {
        ...session,
        video: session.video ? {
          ...session.video,
          size: session.video.size ? session.video.size.toString() : null
        } : undefined
      } : null

      return res.json({
        success: true,
        data: serializedSession,
        message: 'Progress updated'
      })

    } catch (error: any) {
      console.error('Error updating progress:', error)
      
      if (error.message === 'Session not found') {
        return res.status(404).json({
          success: false,
          error: 'Session not found'
        })
      }

      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to update progress'
      })
    }
  }
)

// POST /api/sessions/:sessionId/milestone - Mark milestone as reached
router.post('/:sessionId/milestone',
  validateCUIDParam('sessionId', 'Invalid session ID'),
  validateCUIDBody('milestoneId', 'Valid milestone ID is required'),
  body('timestamp').isNumeric().withMessage('Timestamp must be a number'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const result = await VideoSessionService.markMilestoneReached(
        req.params.sessionId,
        req.body.milestoneId,
        Math.floor(Number(req.body.timestamp)),
        req.user!.id
      )

      return res.json({
        success: true,
        data: result,
        message: 'Milestone marked as reached'
      })

    } catch (error: any) {
      console.error('Error marking milestone:', error)
      
      if (error.message === 'Session not found') {
        return res.status(404).json({
          success: false,
          error: 'Session not found'
        })
      }

      if (error.message === 'Milestone not found') {
        return res.status(404).json({
          success: false,
          error: 'Milestone not found'
        })
      }

      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to mark milestone'
      })
    }
  }
)

// POST /api/sessions/:sessionId/question - Submit question answer
router.post('/:sessionId/question',
  validateCUIDParam('sessionId', 'Invalid session ID'),
  validateCUIDBody('questionId', 'Valid question ID is required'),
  body('answer').notEmpty().trim().withMessage('Answer is required'),
  validateCUIDBody('milestoneId', 'Valid milestone ID is required'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const answerData = {
        questionId: req.body.questionId,
        answer: req.body.answer,
        milestoneId: req.body.milestoneId
      }

      const result = await VideoSessionService.submitAnswer(
        req.params.sessionId,
        answerData,
        req.user!.id
      )

      return res.json({
        success: true,
        data: result,
        message: 'Answer submitted successfully'
      })

    } catch (error: any) {
      console.error('Error submitting answer:', error)
      
      if (error.message === 'Session not found') {
        return res.status(404).json({
          success: false,
          error: 'Session not found'
        })
      }

      if (error.message === 'Question not found') {
        return res.status(404).json({
          success: false,
          error: 'Question not found'
        })
      }

      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to submit answer'
      })
    }
  }
)

// PUT /api/sessions/:sessionId/complete - Mark session as completed
router.put('/:sessionId/complete',
  validateCUIDParam('sessionId', 'Invalid session ID'),
  body('finalTime').isNumeric().withMessage('Final time must be a number'),
  body('totalWatchTime').isNumeric().withMessage('Total watch time must be a number'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const completionData = {
        finalTime: Math.floor(Number(req.body.finalTime)),
        totalWatchTime: Math.floor(Number(req.body.totalWatchTime))
      }

      const session = await VideoSessionService.completeSession(
        req.params.sessionId,
        completionData,
        req.user!.id
      )

      // Convert BigInt fields to strings for JSON serialization
      const serializedSession = session ? {
        ...session,
        video: session.video ? {
          ...session.video,
          size: session.video.size ? session.video.size.toString() : null
        } : undefined
      } : null

      return res.json({
        success: true,
        data: serializedSession,
        message: 'Session completed successfully'
      })

    } catch (error: any) {
      console.error('Error completing session:', error)
      
      if (error.message === 'Session not found') {
        return res.status(404).json({
          success: false,
          error: 'Session not found'
        })
      }

      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to complete session'
      })
    }
  }
)

// GET /api/sessions/video/:videoId - Get user's session for a specific video
router.get('/video/:videoId',
  validateCUIDParam('videoId', 'Invalid video ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      console.log('Fetching session for video:', req.params.videoId, 'user:', req.user!.id)
      const session = await VideoSessionService.getSessionByVideo(
        req.params.videoId,
        req.user!.id
      )

      // Convert BigInt fields to strings for JSON serialization
      const serializedSession = session ? {
        ...session,
        video: session.video ? {
          ...session.video,
          size: session.video.size ? session.video.size.toString() : null
        } : undefined
      } : null
      
      return res.json({
        success: true,
        data: serializedSession
      })

    } catch (error: any) {
      console.error('Error fetching session:', error)
      
      if (error.message === 'Video not found') {
        return res.status(404).json({
          success: false,
          error: 'Video not found'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to fetch session'
      })
    }
  }
)

// GET /api/sessions/user - Get user's video sessions (paginated)
router.get('/user',
  query('page').optional().isInt({ min: 1 }).withMessage('Page must be a positive integer'),
  query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('Limit must be between 1 and 100'),
  query('status').optional().isIn(['ACTIVE', 'COMPLETED', 'PAUSED']).withMessage('Invalid status'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const page = parseInt(req.query.page as string) || 1
      const limit = parseInt(req.query.limit as string) || 10
      const status = req.query.status as string

      const result = await VideoSessionService.getUserSessions({
        studentId: req.user!.id,
        page,
        limit,
        status
      })

      return res.json({
        success: true,
        data: result.sessions,
        meta: {
          total: result.total,
          page,
          limit,
          totalPages: Math.ceil(result.total / limit)
        }
      })

    } catch (error) {
      console.error('Error fetching user sessions:', error)
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch sessions'
      })
    }
  }
)

export default router
</file>

<file path="PRODUCT_ROADMAP.md">
# Phase 1: targeting teacher - student basic flow
1. Teacher:
   - [ ] Upload videos to local SQL database
   - [ ] Annotate videos with milestone markers
   - [ ] Mock questions (with no AI feature yet)

2. Student:
   - [ ] Watch interactive videos with milestone questions
   - [ ] Answer questions to progress through content

3. Errors
   - [ ] Upon completed the video, the video preview reverts to old states with 0 correct answers and no question states
   - [ ] Need a plan to refactor video preview: at least the state is centralized, but the preview video still has a bunch of problems.

## Problem 1: AI keeps overwriting working components
As AI keep overwriting working components, I need to understand which components it is intended to change based on [](./docs/arch).
* The AI is very GRIT, it will slowly build the entire testing system to fix bugs. However, it needs architectural and coding principles guidance when it is too focused on one specific components and not the whole picture. 
* The AI is prone to tunnel-vision, requiring human aid in pointing out larger relevant context window
* The AI is easy to mis-align with original plan and architecture, requiring human to remind them to stick with the plan.

1. Confirm affected components? ask why?
2. Asking iteratively until a clear picture is provided (may 2-3 times)
3. Ensure alignment with reported architecture, need to constantly remind AI of alignment with initial plan
4. Proceed with the plan
5. After code change, demand second check to ensure that non-relevant logic is not changed
</file>

<file path="src/services/VideoService.ts">
import { PrismaClient } from '@prisma/client'
import { User } from '../types/auth'
import { VideoProcessingService } from './VideoProcessingService'
import { getVideoFilePath, getThumbnailFilePath, deleteVideoFile, deleteThumbnailFile } from '../middleware/upload/videoUploadMiddleware'

const prisma = new PrismaClient()

interface CreateVideoGroupData {
  title: string
  description: string | null
  tags: string[]
  isPublic: boolean
  createdBy: string
}

interface UpdateVideoGroupData {
  title?: string
  description?: string
  tags?: string[]
  isPublic?: boolean
}

interface CreateVideoData {
  title: string
  description: string | null
  videoGroupId: string
  // uploadedBy field removed - using uploadedAt timestamp instead
  // File upload data
  filename?: string
  originalName?: string
  filePath?: string
  mimeType?: string
}

interface UpdateVideoData {
  title?: string
  description?: string
  filename?: string
  filePath?: string
  mimeType?: string
  duration?: number
  thumbnailPath?: string
}

interface GetVideoGroupsOptions {
  page: number
  limit: number
  search: string
  userId: string
  lessonId?: string
}

export class VideoService {
  static async getVideoGroups(options: GetVideoGroupsOptions) {
    const { page, limit, search, userId, lessonId } = options
    const offset = (page - 1) * limit

    // Build where clause for search and access control
    const whereClause = {
      AND: [
        // Filter by lessonId if provided
        lessonId ? { lessonId } : {},
        // Access control through lesson relationship
        {
          lesson: {
            OR: [
              { createdById: userId },
              {
                studentProgress: {
                  some: {
                    studentId: userId
                  }
                }
              }
            ]
          }
        },
        // Search filter
        search ? {
          OR: [
            { title: { contains: search, mode: 'insensitive' as any } },
            { description: { contains: search, mode: 'insensitive' as any } }
          ]
        } : {}
      ]
    }

    const [videoGroups, total] = await Promise.all([
      prisma.videoGroup.findMany({
        where: whereClause,
        include: {
          videos: {
            orderBy: { order: 'asc' },
            include: {
              _count: {
                select: { milestones: true }
              }
            }
          },
          lesson: {
            select: {
              id: true,
              title: true,
              createdById: true
            }
          },
          _count: {
            select: { videos: true }
          }
        },
        orderBy: { createdAt: 'desc' },
        skip: offset,
        take: limit
      }),
      prisma.videoGroup.count({ where: whereClause })
    ])

    return {
      videoGroups,
      total
    }
  }

  static async getVideoGroupById(groupId: string, userId: string) {
    try {
      const videoGroup = await prisma.videoGroup.findFirst({
        where: {
          id: groupId,
          lesson: {
            OR: [
              { createdById: userId },
              {
                studentProgress: {
                  some: {
                    studentId: userId
                  }
                }
              }
            ]
          }
        },
        include: {
          videos: {
            orderBy: { order: 'asc' },
            include: {
              // Include milestones with their questions
              milestones: {
                orderBy: { timestamp: 'asc' },
                include: {
                  questions: {
                    orderBy: { createdAt: 'asc' }
                  },
                  _count: {
                    select: { questions: true }
                  }
                }
              },
              _count: {
                select: { 
                  milestones: true,
                  studentSessions: true 
                }
              }
            }
          },
          lesson: {
            select: {
              id: true,
              title: true,
              createdById: true
            }
          },
          _count: {
            select: { videos: true }
          }
        }
      })

      return videoGroup
    } catch (error: any) {
      console.error('Error in getVideoGroupById:', error)
      throw new Error(`Failed to fetch video group: ${error.message}`)
    }
  }

  static async createVideoGroup(data: CreateVideoGroupData, lessonId: string) {
    // Get the next order number for this lesson
    const maxOrder = await prisma.videoGroup.aggregate({
      where: { lessonId },
      _max: { order: true }
    })

    const nextOrder = (maxOrder._max.order || 0) + 1

    const videoGroup = await prisma.videoGroup.create({
      data: {
        title: data.title,
        description: data.description,
        lessonId,
        order: nextOrder
      },
      include: {
        videos: {
          orderBy: { order: 'asc' }
        },
        lesson: {
          select: {
            id: true,
            title: true
          }
        },
        _count: {
          select: { videos: true }
        }
      }
    })

    return videoGroup
  }

  static async updateVideoGroup(groupId: string, data: UpdateVideoGroupData, user: User) {
    // Check if video group exists and user has permission
    const existingGroup = await prisma.videoGroup.findUnique({
      where: { id: groupId },
      include: {
        lesson: true
      }
    })

    if (!existingGroup) {
      throw new Error('Video group not found')
    }

    // Check permissions - only lesson creator or admin can update
    if (existingGroup.lesson.createdById !== user.id && user.role !== 'ADMIN') {
      throw new Error('Access denied')
    }

    // Filter out undefined values
    const updateData: any = {}
    if (data.title !== undefined) updateData.title = data.title
    if (data.description !== undefined) updateData.description = data.description

    const videoGroup = await prisma.videoGroup.update({
      where: { id: groupId },
      data: updateData,
      include: {
        videos: {
          orderBy: { order: 'asc' }
        },
        lesson: {
          select: {
            id: true,
            title: true
          }
        },
        _count: {
          select: { videos: true }
        }
      }
    })

    return videoGroup
  }

  static async createVideo(data: CreateVideoData, user: User) {
    try {
      // Check if video group exists and user has permission
      const videoGroup = await prisma.videoGroup.findUnique({
        where: { id: data.videoGroupId },
        include: {
          lesson: true
        }
      })

      if (!videoGroup) {
        throw new Error('Video group not found')
      }

      // Check permissions - only lesson creator or admin can add videos
      if (videoGroup.lesson.createdById !== user.id && user.role !== 'ADMIN') {
        throw new Error('Access denied')
      }

      // Get the next order number
      const maxOrder = await prisma.video.aggregate({
        where: { videoGroupId: data.videoGroupId },
        _max: { order: true }
      })

      const nextOrder = (maxOrder._max.order || 0) + 1

      // Process video to extract metadata
      let duration: number | null = null
      let size: number | null = null
      let thumbnailPath: string | null = null

      if (data.filePath) {
        try {
          console.log('📹 Processing video metadata for:', data.filePath)
          
          // Get full file path for processing
          const fullVideoPath = getVideoFilePath(data.filePath)
          console.log('📂 Full video path:', fullVideoPath)
          
          // Extract video metadata (duration, dimensions, etc.)
          const metadata = await VideoProcessingService.getVideoMetadata(fullVideoPath)
          duration = metadata.duration
          console.log('📊 Extracted video duration:', duration)
          
          // Get file size
          size = await VideoProcessingService.getFileSize(fullVideoPath)
          console.log('📏 Extracted video size:', size)
          
          // Generate thumbnail (optional - don't fail if this doesn't work)
          if (data.originalName || data.filename) {
            thumbnailPath = await VideoProcessingService.generateThumbnail(fullVideoPath, (data.originalName || data.filename)!)
            console.log('🖼️ Generated thumbnail:', thumbnailPath)
          }
        } catch (processingError) {
          console.warn('⚠️ Video processing failed, creating video without metadata:', processingError)
          // Continue without metadata rather than failing completely
        }
      }

      // Create video with extracted metadata
      const video = await prisma.video.create({
        data: {
          title: data.title,
          description: data.description,
          videoGroupId: data.videoGroupId,
          order: nextOrder,
          filePath: data.filePath,
          fileName: data.originalName || data.filename,
          mimeType: data.mimeType,
          duration: duration,
          size: size,
          thumbnailPath: thumbnailPath,
          uploadedAt: new Date(),
          processedAt: duration ? new Date() : null, // Mark as processed if we got metadata
          processingStatus: duration ? 'COMPLETED' : 'FAILED',
          status: 'READY'
        }
      })

      console.log('✅ Video created successfully with metadata:', {
        id: video.id,
        duration: video.duration,
        size: video.size,
        processingStatus: video.processingStatus
      })

      return video

    } catch (error: any) {
      console.error('Error in createVideo:', error)
      
      // Re-throw known errors
      if (error.message === 'Video group not found' || error.message === 'Access denied') {
        throw error
      }
      
      // Handle Prisma errors
      if (error.code && error.code.startsWith('P')) {
        throw new Error(`Database error: ${error.message}`)
      }
      
      // Other errors
      throw new Error(`Failed to create video: ${error.message}`)
    }
  }

  /**
   * Process existing video to extract missing metadata
   */
  static async processVideoMetadata(videoId: string) {
    try {
      const video = await prisma.video.findUnique({
        where: { id: videoId }
      })

      if (!video) {
        throw new Error('Video not found')
      }

      if (!video.filePath) {
        throw new Error('Video file path not found')
      }

      console.log('📹 Processing existing video metadata for:', video.id)

      // Get full file path using the helper function
      const fullVideoPath = getVideoFilePath(video.filePath)
      console.log('📂 Full video path:', fullVideoPath)

      // Extract video metadata
      const metadata = await VideoProcessingService.getVideoMetadata(fullVideoPath)
      const size = await VideoProcessingService.getFileSize(fullVideoPath)
      
      // Generate thumbnail if missing
      let thumbnailPath = video.thumbnailPath
      if (!thumbnailPath && video.fileName) {
        thumbnailPath = await VideoProcessingService.generateThumbnail(fullVideoPath, video.fileName)
      }

      // Update video with extracted metadata
      const updatedVideo = await prisma.video.update({
        where: { id: videoId },
        data: {
          duration: metadata.duration,
          size: size,
          thumbnailPath: thumbnailPath,
          processedAt: new Date(),
          processingStatus: metadata.duration ? 'COMPLETED' : 'FAILED',
          metadata: {
            width: metadata.width,
            height: metadata.height,
            bitrate: metadata.bitrate,
            fps: metadata.fps,
            codec: metadata.codec
          }
        }
      })

      console.log('✅ Video metadata processed successfully:', {
        id: updatedVideo.id,
        duration: updatedVideo.duration,
        size: updatedVideo.size,
        processingStatus: updatedVideo.processingStatus
      })

      return updatedVideo

    } catch (error: any) {
      console.error('Error processing video metadata:', error)
      
      // Update processing status to failed
      await prisma.video.update({
        where: { id: videoId },
        data: {
          processingStatus: 'FAILED',
          processedAt: new Date()
        }
      }).catch(() => {}) // Ignore update errors
      
      throw error
    }
  }

  static async getVideoById(videoId: string, userId: string) {
    try {
      const video = await prisma.video.findFirst({
        where: {
          id: videoId,
          videoGroup: {
            lesson: {
              OR: [
                { createdById: userId },
                {
                  studentProgress: {
                    some: {
                      studentId: userId
                    }
                  }
                }
              ]
            }
          }
        },
        include: {
          // Include milestones with their questions
          milestones: {
            orderBy: { timestamp: 'asc' },
            include: {
              questions: {
                orderBy: { createdAt: 'asc' }
              },
              _count: {
                select: { questions: true }
              }
            }
          },
          videoGroup: {
            select: {
              id: true,
              title: true,
              description: true
            }
          },
          _count: {
            select: { 
              milestones: true,
              studentSessions: true 
            }
          }
        }
      })

      return video
    } catch (error: any) {
      console.error('Error in getVideoById:', error)
      throw new Error(`Failed to fetch video: ${error.message}`)
    }
  }

  static async updateVideo(videoId: string, data: UpdateVideoData, user: User) {
    try {
      // Check if video exists and user has permission
      const existingVideo = await prisma.video.findUnique({
        where: { id: videoId },
        include: {
          videoGroup: {
            include: {
              lesson: true
            }
          }
        }
      })

      if (!existingVideo) {
        throw new Error('Video not found')
      }

      // Check permissions - only lesson creator or admin can update
      if (
        existingVideo.videoGroup.lesson.createdById !== user.id && 
        user.role !== 'ADMIN'
      ) {
        throw new Error('Access denied')
      }

      // Filter out undefined values
      const updateData: any = {}
      if (data.title !== undefined) updateData.title = data.title
      if (data.description !== undefined) updateData.description = data.description
      if (data.filePath !== undefined) updateData.filePath = data.filePath
      if (data.mimeType !== undefined) updateData.mimeType = data.mimeType
      if (data.duration !== undefined) updateData.duration = data.duration
      if (data.thumbnailPath !== undefined) updateData.thumbnailPath = data.thumbnailPath

      const video = await prisma.video.update({
        where: { id: videoId },
        data: updateData,
        include: {
          // Include milestones with their questions
          milestones: {
            orderBy: { timestamp: 'asc' },
            include: {
              questions: {
                orderBy: { createdAt: 'asc' }
              },
              _count: {
                select: { questions: true }
              }
            }
          },
          videoGroup: {
            select: {
              id: true,
              title: true,
              description: true
            }
          },
          _count: {
            select: { 
              milestones: true,
              studentSessions: true 
            }
          }
        }
      })

      return video
    } catch (error: any) {
      console.error('Error in updateVideo:', error)
      
      // Re-throw known errors
      if (error.message === 'Video not found' || error.message === 'Access denied') {
        throw error
      }
      
      // Handle Prisma errors
      if (error.code && error.code.startsWith('P')) {
        throw new Error(`Database error: ${error.message}`)
      }
      
      // Other errors
      throw new Error(`Failed to update video: ${error.message}`)
    }
  }

  static async deleteVideo(videoId: string, user: User) {
    // Check if video exists and user has permission
    const existingVideo = await prisma.video.findUnique({
      where: { id: videoId },
      include: {
        videoGroup: {
          include: {
            lesson: true
          }
        }
      }
    })

    if (!existingVideo) {
      throw new Error('Video not found')
    }

    // Check permissions - only lesson creator or admin can delete
    if (
      existingVideo.videoGroup.lesson.createdById !== user.id && 
      user.role !== 'ADMIN'
    ) {
      throw new Error('Access denied')
    }

    // Delete associated files before deleting from database
    if (existingVideo.fileName) {
      await deleteVideoFile(existingVideo.fileName)
    }
    
    if (existingVideo.thumbnailPath) {
      await deleteThumbnailFile(existingVideo.thumbnailPath)
    }

    await prisma.video.delete({
      where: { id: videoId }
    })

    return true
  }

  /**
   * Get video file serving path for streaming
   */
  static async getVideoStreamPath(videoId: string, userId: string): Promise<string | null> {
    const video = await this.getVideoById(videoId, userId)
    
    if (!video || !video.filePath) {
      return null
    }

    return getVideoFilePath(video.filePath)
  }

  /**
   * Get thumbnail serving path
   */
  static async getThumbnailStreamPath(videoId: string, userId: string): Promise<string | null> {
    const video = await this.getVideoById(videoId, userId)
    
    if (!video || !video.thumbnailPath) {
      return null
    }

    return getThumbnailFilePath(video.thumbnailPath)
  }
}
</file>

<file path="frontend/src/components/video/VideoPlayer.tsx">
import { useState, useRef, useEffect } from 'react'
import type { Video, VideoSession, Milestone } from '../../services/video'
import { videoService } from '../../services/video'
import { QuestionOverlay } from './QuestionOverlay'
import { MilestoneMarkers } from './MilestoneMarkers'
import { VideoControls } from './VideoControls'
import { useVideoState } from '../../hooks/useVideoState'
import { debug } from '../../utils/debug'
// import { useVideoStateManager } from '../../contexts/VideoStateContext'

interface VideoPlayerProps {
  video: Video
  session?: VideoSession | null
  onSessionStart: (videoId: string) => Promise<VideoSession>
  onProgressUpdate: (sessionId: string, currentTime: number, totalWatchTime: number) => Promise<void>
  onMilestoneReached: (sessionId: string, milestoneId: string, timestamp: number) => Promise<void>
  onAnswerSubmit: (sessionId: string, questionId: string, answer: string, milestoneId: string) => Promise<{ isCorrect: boolean; explanation?: string }>
  onSessionComplete: (sessionId: string, finalTime: number, totalWatchTime: number) => Promise<void>
}

export function VideoPlayer({
  video,
  session,
  onSessionStart,
  onProgressUpdate,
  onMilestoneReached,
  onAnswerSubmit,
  onSessionComplete
}: VideoPlayerProps) {
  debug.video('Player initialized', {
    videoId: video.id,
    milestones: video.milestones?.length || 0
  })
  const videoRef = useRef<HTMLVideoElement>(null)
  // const manager = useVideoStateManager() // Not currently used
  const { milestones: stateMilestones, metadata } = useVideoState(video.id)
  debug.video('State loaded', {
    milestones: stateMilestones?.length || 0,
    hasMetadata: !!metadata
  })
  const [currentSession, setCurrentSession] = useState<VideoSession | null>(session || null)
  const [isPlaying, setIsPlaying] = useState(false)
  const [currentTime, setCurrentTime] = useState(0)
  const [duration, setDuration] = useState(0)
  const [watchStartTime, setWatchStartTime] = useState<number | null>(null)
  const [totalWatchTime, setTotalWatchTime] = useState(0)
  const [currentMilestone, setCurrentMilestone] = useState<Milestone | null>(null)
  const [showQuestionOverlay, setShowQuestionOverlay] = useState(false)
  const [locallyReachedMilestones, setLocallyReachedMilestones] = useState<string[]>([])
  const [volume, setVolume] = useState(1)
  const [isMuted, setIsMuted] = useState(false)
  const [isFullscreen, setIsFullscreen] = useState(false)
  const [loading, setLoading] = useState(false)

  // Progress tracking
  const progressUpdateInterval = useRef<NodeJS.Timeout | undefined>(undefined)
  const lastProgressUpdate = useRef<number>(0)

  useEffect(() => {
    if (session) {
      setCurrentSession(session)
      // Calculate total watch time from session data if available
      const watchTime = session.sessionData?.totalWatchTime || 0
      setTotalWatchTime(watchTime)
      
      // Resume video from last position
      if (videoRef.current && session.currentPosition > 0) {
        videoRef.current.currentTime = session.currentPosition
      }
    }
  }, [session])

  useEffect(() => {
    const video = videoRef.current
    if (!video) return

    const handleLoadedMetadata = () => {
      debug.video('Metadata loaded', { duration: video.duration })
      setDuration(video.duration)
      
      // Resume from session position
      if (currentSession?.currentPosition) {
        debug.video('Resuming playback', { position: currentSession.currentPosition })
        video.currentTime = currentSession.currentPosition
        setCurrentTime(currentSession.currentPosition)
      }
    }

    const handleTimeUpdate = () => {
      const time = video.currentTime
      setCurrentTime(time)
      
      // Check for milestones
      checkForMilestones(time)
    }

    const handlePlay = () => {
      setIsPlaying(true)
      setWatchStartTime(Date.now())
      startProgressTracking()
    }

    const handlePause = () => {
      setIsPlaying(false)
      updateWatchTime()
      stopProgressTracking()
    }

    const handleEnded = () => {
      setIsPlaying(false)
      updateWatchTime()
      stopProgressTracking()
      handleVideoComplete()
    }

    const handleVolumeChange = () => {
      setVolume(video.volume)
      setIsMuted(video.muted)
    }

    video.addEventListener('loadedmetadata', handleLoadedMetadata)
    video.addEventListener('timeupdate', handleTimeUpdate)
    video.addEventListener('play', handlePlay)
    video.addEventListener('pause', handlePause)
    video.addEventListener('ended', handleEnded)
    video.addEventListener('volumechange', handleVolumeChange)

    return () => {
      video.removeEventListener('loadedmetadata', handleLoadedMetadata)
      video.removeEventListener('timeupdate', handleTimeUpdate)
      video.removeEventListener('play', handlePlay)
      video.removeEventListener('pause', handlePause)
      video.removeEventListener('ended', handleEnded)
      video.removeEventListener('volumechange', handleVolumeChange)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentSession])

  const startProgressTracking = () => {
    if (progressUpdateInterval.current) {
      clearInterval(progressUpdateInterval.current)
    }

    progressUpdateInterval.current = setInterval(() => {
      if (currentSession && videoRef.current) {
        const now = Date.now()
        const currentTime = videoRef.current.currentTime
        
        // Only update if significant time has passed or position changed significantly
        if (now - lastProgressUpdate.current > 5000 || 
            Math.abs(currentTime - lastProgressUpdate.current) > 5) {
          
          updateProgress(currentTime)
          lastProgressUpdate.current = now
        }
      }
    }, 5000) // Update every 5 seconds
  }

  const stopProgressTracking = () => {
    if (progressUpdateInterval.current) {
      clearInterval(progressUpdateInterval.current)
      progressUpdateInterval.current = undefined
    }
  }

  const updateWatchTime = () => {
    if (watchStartTime) {
      const additionalTime = Date.now() - watchStartTime
      setTotalWatchTime(prev => prev + additionalTime)
      setWatchStartTime(null)
    }
  }

  const updateProgress = async (currentTime: number) => {
    if (!currentSession) return

    const currentWatchTime = totalWatchTime + (watchStartTime ? Date.now() - watchStartTime : 0)
    
    try {
      await onProgressUpdate(currentSession.id, currentTime, Math.floor(currentWatchTime / 1000))
    } catch (error) {
      debug.error('Failed to update progress:', error)
    }
  }

  const checkForMilestones = (currentTime: number) => {
    // Use milestones from unified state instead of video prop
    const milestones = stateMilestones || video.milestones || []
    
    if (milestones.length === 0 || showQuestionOverlay) {
      debug.video('Skipping milestone check', { reason: 'No milestones or overlay showing' })
      return
    }

    const reachedMilestones = currentSession?.milestoneProgress?.map(mp => mp.milestoneId) || []
    const allReachedMilestones = [...reachedMilestones, ...locallyReachedMilestones]
    // Track reached milestones
    
    const milestone = milestones.find(m => {
      const timeDiff = Math.abs(currentTime - m.timestamp)
      const isInRange = timeDiff <= 2
      const notReached = !allReachedMilestones.includes(m.id)
      return isInRange && notReached
    })

    if (milestone) {
      debug.video('Milestone triggered', { id: milestone.id, time: currentTime })
      handleMilestoneReached(milestone)
    }
    
  }

  const handleMilestoneReached = async (milestone: Milestone) => {
    debug.video('Milestone reached', {
      id: milestone.id,
      timestamp: milestone.timestamp,
      type: milestone.type,
      questions: milestone.questions?.length || 0
    })
    
    if (!currentSession) {
      debug.warn('No current session for milestone handling')
      return
    }

    // Immediately add to local tracking to prevent re-triggering
    setLocallyReachedMilestones(prev => 
      prev.includes(milestone.id) ? prev : [...prev, milestone.id]
    )

    try {
      // Pause video for milestones with questions
      if (milestone.questions && milestone.questions.length > 0 && videoRef.current) {
        debug.video('Pausing for questions')
        videoRef.current.pause()
      }

      // Mark milestone as reached
      await onMilestoneReached(currentSession.id, milestone.id, milestone.timestamp)
      
      setCurrentMilestone(milestone)
      
      // Show question overlay for any milestone with questions
      if (milestone.questions && milestone.questions.length > 0) {
        setShowQuestionOverlay(true)
      }
    } catch (error) {
      debug.error('Failed to mark milestone:', error)
    }
  }

  const handleAnswerSubmit = async (questionId: string, answer: string): Promise<{ isCorrect: boolean; explanation?: string }> => {
    if (!currentSession || !currentMilestone) {
      throw new Error('No active session or milestone')
    }

    try {
      const result = await onAnswerSubmit(currentSession.id, questionId, answer, currentMilestone.id)
      return result
    } catch (error) {
      debug.error('Failed to submit answer:', error)
      throw error
    }
  }

  const handleQuestionComplete = () => {
    setShowQuestionOverlay(false)
    setCurrentMilestone(null)
    
    // Resume video
    if (videoRef.current) {
      videoRef.current.play()
    }
  }

  const handleVideoComplete = async () => {
    if (!currentSession) return

    updateWatchTime()
    const finalWatchTime = totalWatchTime + (watchStartTime ? Date.now() - watchStartTime : 0)

    try {
      await onSessionComplete(
        currentSession.id,
        duration,
        Math.floor(finalWatchTime / 1000)
      )
    } catch (error) {
      debug.error('Failed to complete session:', error)
    }
  }

  const handlePlay = async () => {
    if (!currentSession) {
      // Start new session
      setLoading(true)
      try {
        const newSession = await onSessionStart(video.id)
        setCurrentSession(newSession)
        const watchTime = newSession.sessionData?.totalWatchTime || 0
        setTotalWatchTime(watchTime)
      } catch (error) {
        debug.error('Failed to start session:', error)
        setLoading(false)
        return
      }
      setLoading(false)
    }

    if (videoRef.current) {
      videoRef.current.play()
    }
  }

  const handlePause = () => {
    if (videoRef.current) {
      videoRef.current.pause()
    }
  }

  const handleSeek = (time: number) => {
    if (videoRef.current) {
      videoRef.current.currentTime = time
      setCurrentTime(time)
    }
  }

  const handleVolumeChange = (newVolume: number) => {
    if (videoRef.current) {
      videoRef.current.volume = newVolume
      setVolume(newVolume)
    }
  }

  const handleMute = () => {
    if (videoRef.current) {
      videoRef.current.muted = !videoRef.current.muted
    }
  }

  const handleFullscreen = () => {
    const container = videoRef.current?.parentElement
    if (!container) return

    if (!isFullscreen) {
      if (container.requestFullscreen) {
        container.requestFullscreen()
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen()
      }
    }
    setIsFullscreen(!isFullscreen)
  }

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60)
    const secs = Math.floor(seconds % 60)
    return `${mins}:${secs.toString().padStart(2, '0')}`
  }

  return (
    <div className="relative bg-black rounded-lg overflow-hidden">
      {loading && (
        <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="text-white">Starting session...</div>
        </div>
      )}
      
      <video
        ref={videoRef}
        className="w-full h-auto"
        src={videoService.getStreamingUrl(video.id)}
        poster={video.thumbnailUrl ? videoService.getThumbnailUrl(video.id) : undefined}
        playsInline
        crossOrigin="anonymous"
      />

      {/* Milestone Markers - Use milestones from unified state */}
      {(stateMilestones || video.milestones) && (
        <MilestoneMarkers
          milestones={stateMilestones || video.milestones || []}
          duration={duration}
          currentTime={currentTime}
          reachedMilestones={currentSession?.milestoneProgress?.map(mp => mp.milestoneId) || []}
        />
      )}

      {/* Video Controls */}
      <VideoControls
        isPlaying={isPlaying}
        currentTime={currentTime}
        duration={duration}
        volume={volume}
        isMuted={isMuted}
        isFullscreen={isFullscreen}
        onPlay={handlePlay}
        onPause={handlePause}
        onSeek={handleSeek}
        onVolumeChange={handleVolumeChange}
        onMute={handleMute}
        onFullscreen={handleFullscreen}
      />

      {/* Question Overlay */}
      {showQuestionOverlay && currentMilestone && (
        <QuestionOverlay
          milestone={currentMilestone}
          onAnswerSubmit={handleAnswerSubmit}
          onComplete={handleQuestionComplete}
        />
      )}

      {/* Video Info */}
      <div className="p-4 bg-gray-50">
        <h2 className="text-xl font-semibold text-gray-900">{video.title}</h2>
        {video.description && (
          <p className="mt-2 text-gray-600">{video.description}</p>
        )}
        
        <div className="mt-4 flex items-center justify-between text-sm text-gray-500">
          <div>
            {currentSession ? (
              <span>
                Progress: {formatTime(currentTime)} / {formatTime(duration)}
                {currentSession.status === 'COMPLETED' && (
                  <span className="ml-2 px-2 py-1 bg-green-100 text-green-800 rounded-full text-xs">
                    Completed
                  </span>
                )}
              </span>
            ) : (
              <span>Duration: {formatTime(duration)}</span>
            )}
          </div>
          
          <div>
            {/* Use metadata from unified state for accurate counts */}
            {metadata ? (
              <span>
                {metadata.totalMilestones} milestones, {metadata.totalQuestions} questions
              </span>
            ) : (
              video._count && (
                <span>{video._count.milestones} interactive moments</span>
              )
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/pages/teacher/LessonManagementPage.tsx">
import { useState, useEffect } from 'react'
import { useParams, useNavigate } from 'react-router-dom'
import { videoService } from '../../services/video'
import { type LessonWithVideos, type VideoGroup, type Video } from '../../services/lesson'
import { debug } from '../../utils/debug'
import type { Milestone } from '../../services/video'
import { BaseLessonPage } from '../../components/lessons/BaseLessonPage'
import { VideoList } from '../../components/lessons/VideoList'
import { useAuth } from '../../hooks/useAuth'
import { useVideoState } from '../../hooks/useVideoState'
import { useVideoStateManager } from '../../contexts/VideoStateContext'
import { VideoUploadForm } from '../../components/teacher/VideoUploadForm'
import { MilestoneEditor } from '../../components/teacher/MilestoneEditor'
import { QuestionEditor } from '../../components/teacher/QuestionEditor'
import { AIQuestionGenerator } from '../../components/teacher/AIQuestionGenerator'

// Wrapper component to handle VideoGroup creation
interface VideoUploadFormWrapperProps {
  lesson: LessonWithVideos | null
  videoGroups: VideoGroup[]
  onVideoUploaded: () => void
  onClose: () => void
  getOrCreateVideoGroup: () => Promise<string>
}

function VideoUploadFormWrapper({ onVideoUploaded, onClose, getOrCreateVideoGroup }: VideoUploadFormWrapperProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [groupId, setGroupId] = useState<string | null>(null)

  useEffect(() => {
    const initializeVideoGroup = async () => {
      setLoading(true)
      setError(null)
      
      try {
        const id = await getOrCreateVideoGroup()
        setGroupId(id)
      } catch (err: any) {
        debug.error('Error getting video group:', err)
        setError(err.message || 'Failed to initialize video group')
      } finally {
        setLoading(false)
      }
    }

    initializeVideoGroup()
  }, [getOrCreateVideoGroup])

  if (loading) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div className="bg-white rounded-lg p-6 max-w-sm w-full text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
          <p className="text-gray-600">Preparing video upload...</p>
        </div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div className="bg-white rounded-lg p-6 max-w-sm w-full text-center">
          <div className="text-red-500 mb-4">
            <svg className="w-12 h-12 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <h3 className="text-lg font-semibold text-gray-900 mb-2">Error</h3>
          <p className="text-gray-600 mb-4">{error}</p>
          <button onClick={onClose} className="btn-primary">
            Close
          </button>
        </div>
      </div>
    )
  }

  if (!groupId) {
    return null
  }

  return (
    <VideoUploadForm
      groupId={groupId}
      onVideoUploaded={onVideoUploaded}
      onClose={onClose}
    />
  )
}

export default function LessonManagementPage() {
  const { lessonId } = useParams<{ lessonId: string }>()
  const navigate = useNavigate()
  const { user } = useAuth()
  const manager = useVideoStateManager()
  
  const [selectedVideoId, setSelectedVideoId] = useState<string | null>(null)
  const [selectedMilestone, setSelectedMilestone] = useState<Milestone | null>(null)
  
  // Use unified video state
  const { state: videoState, milestones, metadata } = useVideoState(selectedVideoId || undefined)
  
  const [showVideoUpload, setShowVideoUpload] = useState(false)
  const [showMilestoneEditor, setShowMilestoneEditor] = useState(false)
  const [showQuestionEditor, setShowQuestionEditor] = useState(false)
  const [showAIGenerator, setShowAIGenerator] = useState(false)

  useEffect(() => {
    if (!lessonId) {
      navigate('/dashboard')
      return
    }
  }, [lessonId])

  // Check if user has permission
  if (!user || (user.role !== 'TEACHER' && user.role !== 'ADMIN')) {
    return (
      <div className="p-6">
        <div className="card text-center py-8">
          <h3 className="text-lg font-semibold text-gray-900 mb-2">Access Denied</h3>
          <p className="text-gray-600 mb-4">Only teachers and administrators can manage lessons.</p>
          <button onClick={() => navigate('/dashboard')} className="btn-primary">
            Back to Dashboard
          </button>
        </div>
      </div>
    )
  }

  if (!lessonId) {
    return null
  }

  // Wrap with BaseLessonPage for unified data loading
  return (
    <BaseLessonPage lessonId={lessonId} role={user?.role as 'TEACHER' | 'ADMIN'}>
      {({ lesson, videoGroups, loading, error, onVideoSelect, refreshLesson }) => {
        // Check ownership inside the render function
        if (lesson && lesson.createdById !== user?.id && user?.role !== 'ADMIN') {
          return (
            <div className="p-6">
              <div className="card text-center py-8">
                <h3 className="text-lg font-semibold text-gray-900 mb-2">Access Denied</h3>
                <p className="text-gray-600 mb-4">You do not have permission to manage this lesson</p>
                <button onClick={() => navigate('/dashboard')} className="btn-primary">
                  Back to Dashboard
                </button>
              </div>
            </div>
          )
        }

        const handleVideoAdded = () => {
          refreshLesson()
          setShowVideoUpload(false)
        }

        const getOrCreateVideoGroup = async (): Promise<string> => {
          if (!lesson) throw new Error('No lesson available')
          
          // If lesson already has video groups, use the first one
          if (videoGroups.length > 0) {
            return videoGroups[0].id
          }
          
          // Create a default video group for this lesson
          try {
            const videoGroup = await videoService.createVideoGroup({
              title: `${lesson.title} - Videos`,
              description: `Video group for lesson: ${lesson.title}`,
              lessonId: lesson.id
            })
            return videoGroup.id
          } catch (error) {
            debug.error('Error creating video group:', error)
            throw error
          }
        }

        const handleMilestoneAdded = async (milestone: Milestone) => {
          if (selectedVideoId) {
            // Add milestone through VideoStateManager - will update all subscribers
            await manager.addMilestone(selectedVideoId, milestone)
          }
          setShowMilestoneEditor(false)
        }

        const handleVideoSelect = async (video: Video) => {
          try {
            // Set selected video ID - useVideoState hook will handle loading
            setSelectedVideoId(video.id)
            // Load video into state manager
            await manager.loadVideo(video.id)
            // Also update the base component's selection
            onVideoSelect(video)
          } catch (error) {
            debug.error('Error loading video details:', error)
          }
        }

        const handleMilestoneSelect = (milestone: Milestone) => {
          setSelectedMilestone(milestone)
          setShowQuestionEditor(true)
        }

        const handleAIQuestionsGenerated = () => {
          setShowAIGenerator(false)
          // No need to reload - VideoStateManager will notify all subscribers
        }

        const handlePreviewLesson = () => {
          const allVideos = videoGroups.flatMap(group => group.videos || [])
          if (allVideos.length > 0) {
            navigate(`/video/${allVideos[0].id}`)
          }
        }

        const formatDuration = (seconds: number | null) => {
          if (!seconds) return 'Unknown'
          const mins = Math.floor(seconds / 60)
          const secs = seconds % 60
          return `${mins}:${secs.toString().padStart(2, '0')}`
        }

        if (loading) {
          return (
            <div className="p-6">
              <div className="flex items-center justify-center h-64">
                <div className="text-center">
                  <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
                  <p className="text-gray-600">Loading lesson...</p>
                </div>
              </div>
            </div>
          )
        }

        if (error) {
          return (
            <div className="p-6">
              <div className="card text-center py-8">
                <h3 className="text-lg font-semibold text-gray-900 mb-2">Error Loading Lesson</h3>
                <p className="text-gray-600 mb-4">{error}</p>
                <button onClick={() => navigate('/dashboard')} className="btn-primary">
                  Back to Dashboard
                </button>
              </div>
            </div>
          )
        }

        if (!lesson) return null

        return (
          <div className="p-6">
            {/* Header */}
            <div className="mb-6">
              <button
          onClick={() => navigate('/dashboard')}
          className="flex items-center text-blue-600 hover:text-blue-700 transition-colors mb-4"
        >
          <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
          </svg>
          Back to Dashboard
        </button>
        
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-2xl font-bold text-gray-900">{lesson.title}</h1>
            <p className="text-gray-600 mt-1">{lesson.description}</p>
          </div>
          
          <div className="flex space-x-3">
            <button
              onClick={handlePreviewLesson}
              disabled={videoGroups.flatMap(g => g.videos || []).length === 0}
              className={`btn-secondary ${
                videoGroups.flatMap(g => g.videos || []).length === 0
                  ? 'opacity-50 cursor-not-allowed' 
                  : ''
              }`}
            >
              Preview Lesson
            </button>
            <button
              onClick={() => setShowVideoUpload(true)}
              className="btn-primary"
            >
              Add Video
            </button>
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Video List */}
        <div className="lg:col-span-1">
          <div className="card">
            <h2 className="text-lg font-semibold text-gray-900 mb-4">Videos</h2>
            
            <VideoList
              videoGroups={videoGroups}
              selectedVideoId={selectedVideoId}
              onVideoSelect={handleVideoSelect}
              showManageButtons={true}
              onUploadClick={() => setShowVideoUpload(true)}
            />
          </div>
        </div>

        {/* Video Details & Milestones */}
        <div className="lg:col-span-2">
          {videoState ? (
            <div className="space-y-6">
              {/* Video Details */}
              <div className="card">
                <h2 className="text-lg font-semibold text-gray-900 mb-4">Video Details</h2>
                <div className="space-y-3">
                  <div>
                    <h3 className="font-medium text-gray-900">{videoState.video.title}</h3>
                    {videoState.video.description && (
                      <p className="text-gray-600 mt-1">{videoState.video.description}</p>
                    )}
                  </div>
                  <div className="flex items-center justify-between">
                    <div className="text-sm text-gray-500">
                      Duration: {formatDuration(videoState.video.duration)}
                    </div>
                    <button
                      onClick={() => navigate(`/video/${videoState.video.id}`)}
                      className="btn-secondary"
                    >
                      Preview Video
                    </button>
                  </div>
                </div>
              </div>

              {/* Milestones */}
              <div className="card">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-lg font-semibold text-gray-900">Interactive Milestones</h2>
                  <div className="flex space-x-2">
                    <button
                      onClick={() => setShowAIGenerator(true)}
                      className="btn-secondary"
                    >
                      AI Generate
                    </button>
                    <button
                      onClick={() => {
                        setSelectedMilestone(null)
                        setShowMilestoneEditor(true)
                      }}
                      className="btn-primary"
                    >
                      Add Milestone
                    </button>
                  </div>
                </div>

                {milestones && milestones.length > 0 ? (
                  <div className="space-y-3">
                    {milestones
                      .sort((a, b) => a.timestamp - b.timestamp)
                      .map((milestone) => (
                        <div
                          key={milestone.id}
                          className="p-4 border rounded-lg hover:bg-gray-50 cursor-pointer"
                          onClick={() => handleMilestoneSelect(milestone)}
                        >
                          <div className="flex items-center justify-between">
                            <div>
                              <div className="flex items-center space-x-3">
                                <span className={`px-2 py-1 rounded-full text-xs font-medium ${
                                  milestone.type === 'QUIZ' 
                                    ? 'bg-red-100 text-red-700'
                                    : milestone.type === 'CHECKPOINT'
                                    ? 'bg-blue-100 text-blue-700'
                                    : 'bg-gray-100 text-gray-700'
                                }`}>
                                  {milestone.type}
                                </span>
                                <span className="text-sm text-gray-500">
                                  {Math.floor(milestone.timestamp / 60)}:
                                  {(milestone.timestamp % 60).toFixed(0).padStart(2, '0')}
                                </span>
                              </div>
                              <h4 className="font-medium text-gray-900 mt-1">
                                {milestone.title}
                              </h4>
                              {milestone.description && (
                                <p className="text-sm text-gray-600 mt-1">
                                  {milestone.description}
                                </p>
                              )}
                            </div>
                            <div className="text-sm text-gray-500">
                              {metadata?.questionsPerMilestone.get(milestone.id) || 0} questions
                            </div>
                          </div>
                        </div>
                      ))
                    }
                  </div>
                ) : (
                  <div className="text-center py-8">
                    <svg className="w-12 h-12 text-gray-400 mx-auto mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <p className="text-gray-500 mb-4">No milestones added yet</p>
                    <button
                      onClick={() => {
                        setSelectedMilestone(null)
                        setShowMilestoneEditor(true)
                      }}
                      className="btn-primary"
                    >
                      Add First Milestone
                    </button>
                  </div>
                )}
              </div>
            </div>
          ) : (
            <div className="card">
              <div className="text-center py-12">
                <svg className="w-16 h-16 text-gray-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                </svg>
                <h3 className="text-lg font-semibold text-gray-900 mb-2">Select a Video</h3>
                <p className="text-gray-600">
                  Choose a video from the list to manage its milestones and interactive elements.
                </p>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Modals */}
      {showVideoUpload && lessonId && (
        <VideoUploadFormWrapper
          lesson={lesson}
          videoGroups={videoGroups}
          onVideoUploaded={handleVideoAdded}
          onClose={() => setShowVideoUpload(false)}
          getOrCreateVideoGroup={getOrCreateVideoGroup}
        />
      )}

      {showMilestoneEditor && videoState && (
        <MilestoneEditor
          video={videoState.video}
          milestone={selectedMilestone}
          onMilestoneAdded={handleMilestoneAdded}
          onClose={() => setShowMilestoneEditor(false)}
        />
      )}

      {showQuestionEditor && selectedMilestone && (
        <QuestionEditor
          milestone={selectedMilestone}
          videoId={selectedVideoId || undefined}
          onClose={() => setShowQuestionEditor(false)}
        />
      )}

      {showAIGenerator && videoState && (
        <AIQuestionGenerator
          video={videoState.video}
          milestone={selectedMilestone || undefined}
          onQuestionsGenerated={handleAIQuestionsGenerated}
          onClose={() => setShowAIGenerator(false)}
        />
      )}
          </div>
        )
      }}
    </BaseLessonPage>
  )
}
</file>

<file path="frontend/src/services/video.ts">
import { apiService } from './api'
import { debug } from '../utils/debug'

// Standard API response wrapper
export interface ApiResponse<T> {
  success: boolean
  data: T
  error?: string
}

// Paginated response wrapper
export interface PaginatedResponse<T> {
  items: T[]
  total: number
  page: number
  limit: number
  totalPages: number
}

// Types for API responses
export interface VideoGroup {
  id: string
  title: string
  description: string | null
  lessonId?: string
  order?: number
  tags?: string[]
  isPublic?: boolean
  createdBy?: string
  createdAt: string
  updatedAt?: string
  videos: Video[]
  lesson?: {
    id: string
    title: string
    createdById: string
  }
  creator?: {
    id: string
    firstName: string
    lastName: string
    email: string
  }
  _count?: {
    videos: number
  }
}

export interface Video {
  id: string
  title: string
  description: string | null
  videoUrl?: string
  filePath?: string
  fileName?: string
  duration: number | null
  thumbnailUrl?: string | null
  thumbnailPath?: string | null
  order: number
  videoGroupId: string
  uploadedBy?: string
  status?: string
  size?: string | null
  mimeType?: string | null
  processingStatus?: string
  metadata?: any
  createdAt: string
  updatedAt?: string
  uploadedAt?: string
  processedAt?: string | null
  milestones?: Milestone[]
  videoGroup?: {
    id: string
    title: string
    description: string | null
  }
  uploader?: {
    id: string
    firstName: string
    lastName: string
    email: string
  }
  _count?: {
    milestones: number
    studentSessions?: number
    videoSessions?: number
  }
}

export interface Milestone {
  id: string
  videoId: string
  timestamp: number
  title: string
  description: string | null
  type: 'PAUSE' | 'QUIZ' | 'CHECKPOINT'
  createdAt: string
  questions?: Question[]
  _count?: {
    questions: number
  }
}

export interface Question {
  id: string
  milestoneId: string
  type: 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'SHORT_ANSWER' | 'FILL_IN_BLANK'
  text: string  // Backend returns 'text', not 'question'
  explanation: string | null
  questionData: any  // Contains correctAnswer, options, etc. based on type
  points?: number
  passThreshold?: number
  createdAt: string
  createdById?: string
  status?: 'DRAFT' | 'PUBLISHED' | 'ARCHIVED'
}

export interface QuestionOption {
  id: string
  questionId: string
  text: string
  isCorrect: boolean
  order: number
}

export interface VideoSession {
  id: string
  videoId: string
  studentId: string
  currentPosition: number
  status: 'ACTIVE' | 'PAUSED' | 'COMPLETED'
  completedAt: string | null
  createdAt: string
  lastSeenAt: string
  startedAt: string
  updatedAt: string
  lastMilestoneId?: string | null
  completedMilestones?: string[]
  sessionData?: any
  video?: Video
  milestoneProgress?: MilestoneProgress[]
  questionAttempts?: QuestionAttempt[]
}

export interface MilestoneProgress {
  id: string
  sessionId: string
  milestoneId: string
  timestamp: number
  reachedAt: string
  milestone?: Milestone
}

export interface QuestionAttempt {
  id: string
  studentId: string
  questionId: string
  sessionId?: string | null
  status: 'IN_PROGRESS' | 'CORRECT' | 'INCORRECT' | 'PARTIAL' | 'TIMEOUT'
  attemptNumber: number
  studentAnswer: any
  isCorrect?: boolean | null
  score: number
  timeSpent: number
  hintsUsed: string[]
  feedback?: string | null
  attemptData?: any
  createdAt: string
  updatedAt: string
  submittedAt?: string | null
  question?: Question
}

// Video Groups API
export const videoService = {
  // Get all video groups (paginated)
  async getVideoGroups(params: {
    page?: number
    limit?: number
    search?: string
    lessonId?: string
  } = {}) {
    const searchParams = new URLSearchParams()
    if (params.page) searchParams.append('page', params.page.toString())
    if (params.limit) searchParams.append('limit', params.limit.toString())
    if (params.search) searchParams.append('search', params.search)
    if (params.lessonId) searchParams.append('lessonId', params.lessonId)

    const response = await apiService.get<ApiResponse<PaginatedResponse<VideoGroup>>>(`/videos?${searchParams}`)
    return response.data
  },

  // Get video groups for a specific lesson
  async getVideoGroupsByLesson(lessonId: string) {
    const response = await apiService.get<ApiResponse<VideoGroup[] | PaginatedResponse<VideoGroup>>>(`/videos?lessonId=${lessonId}`)
    // Handle both array and paginated response formats
    if (Array.isArray(response.data)) {
      return { items: response.data, total: response.data.length, page: 1, limit: 100, totalPages: 1 }
    }
    return response.data as PaginatedResponse<VideoGroup>
  },

  // Get specific video group
  async getVideoGroup(groupId: string) {
    const response = await apiService.get<ApiResponse<VideoGroup>>(`/videos/groups/${groupId}`)
    return response.data
  },

  // Create video group (teachers only)
  async createVideoGroup(data: {
    title: string
    description?: string
    tags?: string[]
    isPublic?: boolean
    lessonId?: string
  }) {
    const response = await apiService.post<ApiResponse<VideoGroup>>('/videos/groups', data)
    return response.data
  },

  // Update video group
  async updateVideoGroup(groupId: string, data: {
    title?: string
    description?: string
    tags?: string[]
    isPublic?: boolean
  }) {
    const response = await apiService.put<ApiResponse<VideoGroup>>(`/videos/groups/${groupId}`, data)
    return response.data
  },

  // Add video to group (DEPRECATED - use uploadVideoFile for file uploads)
  async addVideoToGroup(groupId: string, data: {
    title: string
    description?: string
    videoUrl: string
    duration?: number
    thumbnailUrl?: string
  }) {
    // Note: This method is for URL-based videos, NOT file uploads
    // Use uploadVideoFile() for actual file uploads to avoid "Video file is required" errors
    
    // Debug: Log the actual data being sent
    console.warn('[VideoService] addVideoToGroup called with:', {
      groupId,
      data,
      hasVideoUrl: !!data.videoUrl,
      stack: new Error().stack
    })
    
    // Validate videoUrl is present
    if (!data.videoUrl) {
      throw new Error('videoUrl is required for URL-based video uploads')
    }
    
    const response = await apiService.post<ApiResponse<Video>>(`/videos/groups/${groupId}/videos`, data)
    return response.data
  },

  // Upload video file with progress tracking
  async uploadVideoFile(groupId: string, file: File, data: {
    title: string
    description?: string
  }, onProgress?: (progress: number) => void) {
    const formData = new FormData()
    formData.append('video', file)
    formData.append('title', data.title)
    if (data.description) {
      formData.append('description', data.description)
    }

    const response = await apiService.post<ApiResponse<Video>>(
      `/videos/groups/${groupId}/videos`,
      formData,
      {
        // Don't set Content-Type header - it will be handled by axios/interceptor for FormData
        onUploadProgress: (progressEvent) => {
          if (onProgress && progressEvent.total) {
            const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total)
            onProgress(progress)
          }
        }
      }
    )
    return response.data
  },

  // Get video streaming URL with authentication token
  getStreamingUrl(videoId: string) {
    const baseUrl = `${import.meta.env.VITE_API_URL || 'http://localhost:3000/api/v1'}/videos/${videoId}/stream`
    const token = localStorage.getItem('accessToken')
    
    if (token) {
      return `${baseUrl}?token=${encodeURIComponent(token)}`
    }
    
    return baseUrl
  },

  // Get video thumbnail URL
  getThumbnailUrl(videoId: string) {
    return `${import.meta.env.VITE_API_URL || 'http://localhost:3000/api/v1'}/videos/${videoId}/thumbnail`
  },

  // Get specific video
  async getVideo(videoId: string) {
    const response = await apiService.get<ApiResponse<Video>>(`/videos/${videoId}`)
    // The response is already unwrapped by apiService, but it's wrapped in success/data structure
    return (response as any).data || response
  },

  // Update video
  async updateVideo(videoId: string, data: {
    title?: string
    description?: string
    videoUrl?: string
    duration?: number
    thumbnailUrl?: string
  }) {
    const response = await apiService.put<ApiResponse<Video>>(`/videos/${videoId}`, data)
    return response.data
  },

  // Delete video
  async deleteVideo(videoId: string) {
    const response = await apiService.delete<ApiResponse<{ message: string }>>(`/videos/${videoId}`)
    return response.data
  }
}

// Question API
export const questionService = {
  // Create question
  async createQuestion(data: {
    milestoneId: string
    type: 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'SHORT_ANSWER'
    question: string
    correctAnswer: string
    explanation?: string
    options?: string[]
  }) {
    // Transform frontend data to match backend expectations
    let questionData: any = {}
    
    switch (data.type) {
      case 'MULTIPLE_CHOICE':
        // Find the index of the correct answer in options
        const correctIndex = data.options ? data.options.indexOf(data.correctAnswer) : -1
        questionData = {
          options: data.options || [],
          correctAnswerIndex: correctIndex >= 0 ? correctIndex : 0
        }
        break
      case 'TRUE_FALSE':
        // Convert string to boolean
        questionData = {
          correctAnswer: data.correctAnswer.toLowerCase() === 'true'
        }
        break
      case 'SHORT_ANSWER':
        // Store as array of acceptable answers
        questionData = {
          correctAnswers: [data.correctAnswer],
          caseSensitive: false
        }
        break
    }
    
    const requestData = {
      milestoneId: data.milestoneId,
      type: data.type,
      text: data.question, // Backend expects 'text' not 'question'
      explanation: data.explanation,
      questionData
    }
    
    const response = await apiService.post<ApiResponse<Question>>('/questions', requestData)
    return (response as any).data
  },

  // Get questions for milestone
  async getQuestionsByMilestone(milestoneId: string) {
    const response = await apiService.get<ApiResponse<Question[]>>(`/questions/milestone/${milestoneId}`)
    return (response as any).data
  },

  // Update question
  async updateQuestion(questionId: string, data: {
    type?: 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'SHORT_ANSWER'
    question?: string
    correctAnswer?: string
    explanation?: string
    options?: string[]
  }) {
    // Transform frontend data to match backend expectations
    const requestData: any = {}
    if (data.type !== undefined) requestData.type = data.type
    if (data.question !== undefined) requestData.text = data.question // Backend expects 'text' not 'question'
    if (data.explanation !== undefined) requestData.explanation = data.explanation
    
    // Only set questionData if we have relevant data to update
    if ((data.correctAnswer !== undefined || data.options !== undefined) && data.type) {
      let questionData: any = {}
      
      switch (data.type) {
        case 'MULTIPLE_CHOICE':
          const correctIndex = data.options && data.correctAnswer ? 
            data.options.indexOf(data.correctAnswer) : -1
          questionData = {
            options: data.options || [],
            correctAnswerIndex: correctIndex >= 0 ? correctIndex : 0
          }
          break
        case 'TRUE_FALSE':
          questionData = {
            correctAnswer: data.correctAnswer ? data.correctAnswer.toLowerCase() === 'true' : false
          }
          break
        case 'SHORT_ANSWER':
          questionData = {
            correctAnswers: data.correctAnswer ? [data.correctAnswer] : [],
            caseSensitive: false
          }
          break
      }
      
      requestData.questionData = questionData
    }
    
    const response = await apiService.put<ApiResponse<Question>>(`/questions/${questionId}`, requestData)
    return (response as any).data
  },

  // Delete question
  async deleteQuestion(questionId: string) {
    const response = await apiService.delete<ApiResponse<{ message: string }>>(`/questions/${questionId}`)
    return (response as any).data
  }
}

// Milestone API
export const milestoneService = {
  // Create milestone
  async createMilestone(data: {
    videoId: string
    timestamp: number
    title: string
    description?: string
    type: 'PAUSE' | 'QUIZ' | 'CHECKPOINT'
  }) {
    const response = await apiService.post<ApiResponse<Milestone>>('/milestones', data)
    return response.data
  },

  // Get milestones for video
  async getMilestonesByVideo(videoId: string) {
    const response = await apiService.get<ApiResponse<Milestone[]>>(`/milestones/video/${videoId}`)
    return response.data
  },

  // Update milestone
  async updateMilestone(milestoneId: string, data: {
    timestamp?: number
    title?: string
    description?: string
    type?: 'PAUSE' | 'QUIZ' | 'CHECKPOINT'
  }) {
    const response = await apiService.put<ApiResponse<Milestone>>(`/milestones/${milestoneId}`, data)
    return response.data
  },

  // Delete milestone
  async deleteMilestone(milestoneId: string) {
    const response = await apiService.delete<ApiResponse<{ message: string }>>(`/milestones/${milestoneId}`)
    return response.data
  },

  // Add question to milestone
  async addQuestion(milestoneId: string, data: {
    type: 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'SHORT_ANSWER'
    question: string
    explanation?: string
    options?: string[]
    correctAnswer: string
  }) {
    const response = await apiService.post<ApiResponse<Question>>(`/milestones/${milestoneId}/questions`, data)
    return response.data
  }
}

// Session API
export const sessionService = {
  // Start or resume session
  async startSession(videoId: string) {
    const response = await apiService.post<ApiResponse<VideoSession>>('/sessions/start', { videoId })
    // apiService already unwraps, so response is the ApiResponse object
    return (response as any).data
  },

  // Update progress
  async updateProgress(sessionId: string, data: {
    currentTime: number
    totalWatchTime?: number
  }) {
    const response = await apiService.put<ApiResponse<VideoSession>>(`/sessions/${sessionId}/progress`, data)
    // apiService already unwraps, so response is the ApiResponse object
    return (response as any).data
  },

  // Mark milestone reached
  async markMilestoneReached(sessionId: string, data: {
    milestoneId: string
    timestamp: number
  }) {
    const response = await apiService.post<ApiResponse<MilestoneProgress>>(`/sessions/${sessionId}/milestone`, data)
    return (response as any).data
  },

  // Submit question answer
  async submitAnswer(sessionId: string, data: {
    questionId: string
    answer: string
    milestoneId: string
  }) {
    const response = await apiService.post<ApiResponse<{
      answer: QuestionAttempt
      isCorrect: boolean
      score: number
      explanation?: string
    }>>(`/sessions/${sessionId}/question`, data)
    return (response as any).data
  },

  // Complete session
  async completeSession(sessionId: string, data: {
    finalTime: number
    totalWatchTime: number
  }) {
    const response = await apiService.put<ApiResponse<VideoSession>>(`/sessions/${sessionId}/complete`, data)
    return (response as any).data
  },

  // Get session for video
  async getSessionByVideo(videoId: string) {
    try {
      const response = await apiService.get<ApiResponse<VideoSession | null>>(`/sessions/video/${videoId}`)
      return response.data
    } catch (error) {
      debug.video('No existing session for video', { videoId })
      return null
    }
  },

  // Get user sessions
  async getUserSessions(params: {
    page?: number
    limit?: number
    status?: 'ACTIVE' | 'COMPLETED' | 'PAUSED'
  } = {}) {
    const searchParams = new URLSearchParams()
    if (params.page) searchParams.append('page', params.page.toString())
    if (params.limit) searchParams.append('limit', params.limit.toString())
    if (params.status) searchParams.append('status', params.status)

    const response = await apiService.get<ApiResponse<PaginatedResponse<VideoSession>>>(`/sessions/user?${searchParams}`)
    return response.data
  }
}
</file>

<file path="src/routes/videoRoutes.ts">
import { Router, Response } from 'express'
import { body, query } from 'express-validator'
import { validationResult } from 'express-validator'
import { validateCUIDParam, validateCUIDBody } from '../utils/validators'
import { authenticate } from '../middleware/auth/authMiddleware'
// import { roleMiddleware } from '../middleware/role' // TODO: Create this middleware
import { VideoService } from '../services/VideoService'
import { AuthenticatedRequest } from '../middleware/auth/authMiddleware'
import { uploadVideoMiddleware, handleUploadErrors } from '../middleware/upload/videoUploadMiddleware'
import { VideoProcessingService } from '../services/VideoProcessingService'
import fs from 'fs'
import path from 'path'
import jwt from 'jsonwebtoken'

const router = Router()

// Custom authentication middleware for video streaming that supports query params
const streamingAuthenticate = async (req: AuthenticatedRequest, res: any, next: any) => {
  // Try header authentication first
  const authHeader = req.headers.authorization
  if (authHeader && authHeader.startsWith('Bearer ')) {
    const token = authHeader.substring(7)
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any
      // Map userId to id for consistency with regular auth
      req.user = {
        id: decoded.userId || decoded.id,
        email: decoded.email,
        firstName: decoded.firstName || '',
        lastName: decoded.lastName || '',
        role: decoded.role,
        status: 'ACTIVE',
        createdAt: new Date()
      }
      return next()
    } catch (error) {
      // Fall through to query param auth
    }
  }
  
  // Try query parameter authentication for video streaming
  const token = req.query.token as string
  if (token) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any
      // Map userId to id for consistency with regular auth
      req.user = {
        id: decoded.userId || decoded.id,
        email: decoded.email,
        firstName: decoded.firstName || '',
        lastName: decoded.lastName || '',
        role: decoded.role,
        status: 'ACTIVE',
        createdAt: new Date()
      }
      console.log('Streaming auth successful:', req.user)
      return next()
    } catch (error) {
      return res.status(401).json({
        success: false,
        error: 'Invalid authentication token'
      })
    }
  }
  
  // No valid authentication found
  return res.status(401).json({
    success: false,
    error: 'Authentication required'
  })
}

// Apply authentication middleware to all routes except streaming
router.use((req, res, next) => {
  // Skip authentication middleware for streaming endpoint
  if (req.path.match(/\/[^\/]+\/stream$/)) {
    return next()
  }
  return authenticate(req, res, next)
})

// GET /api/videos - Get all video groups with videos (paginated)
router.get('/',
  query('page').optional().isInt({ min: 1 }).withMessage('Page must be a positive integer'),
  query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('Limit must be between 1 and 100'),
  query('search').optional().isString().trim().withMessage('Search must be a string'),
  query('lessonId').optional().isString().trim().withMessage('Lesson ID must be a string'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const page = parseInt(req.query.page as string) || 1
      const limit = parseInt(req.query.limit as string) || 10
      const search = req.query.search as string || ''
      const lessonId = req.query.lessonId as string | undefined

      const result = await VideoService.getVideoGroups({
        page,
        limit,
        search,
        userId: req.user!.id,
        lessonId
      })

      // Serialize BigInt fields (video.size) to strings
      const serializedGroups = result.videoGroups.map(group => ({
        ...group,
        videos: group.videos?.map(video => ({
          ...video,
          size: video.size ? video.size.toString() : null
        })) || []
      }))

      return res.json({
        success: true,
        data: serializedGroups,
        meta: {
          total: result.total,
          page,
          limit,
          totalPages: Math.ceil(result.total / limit)
        }
      })

    } catch (error) {
      console.error('Error fetching video groups:', error)
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch video groups'
      })
    }
  }
)

// GET /api/videos/groups/:id - Get specific video group with videos
router.get('/groups/:id',
  validateCUIDParam('id', 'Invalid group ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const videoGroup = await VideoService.getVideoGroupById(req.params.id, req.user!.id)

      if (!videoGroup) {
        return res.status(404).json({
          success: false,
          error: 'Video group not found'
        })
      }

      return res.json({
        success: true,
        data: videoGroup
      })

    } catch (error) {
      console.error('Error fetching video group:', error)
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch video group'
      })
    }
  }
)

// POST /api/videos/groups - Create new video group (teachers only)
router.post('/groups',
  // roleMiddleware(['TEACHER', 'ADMIN']), // TODO: Implement role middleware
  body('title').notEmpty().trim().withMessage('Title is required'),
  body('description').optional().trim(),
  validateCUIDBody('lessonId', 'Valid lesson ID is required'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const videoGroupData = {
        title: req.body.title,
        description: req.body.description || null,
        tags: req.body.tags || [],
        isPublic: req.body.isPublic || false,
        createdBy: req.user!.id
      }

      const videoGroup = await VideoService.createVideoGroup(videoGroupData, req.body.lessonId)

      return res.status(201).json({
        success: true,
        data: videoGroup,
        message: 'Video group created successfully'
      })

    } catch (error) {
      console.error('Error creating video group:', error)
      return res.status(500).json({
        success: false,
        error: 'Failed to create video group'
      })
    }
  }
)

// PUT /api/videos/groups/:id - Update video group (creator or admin only)
router.put('/groups/:id',
  validateCUIDParam('id', 'Invalid group ID'),
  body('title').optional().notEmpty().trim().withMessage('Title cannot be empty'),
  body('description').optional().trim(),
  body('tags').optional().isArray().withMessage('Tags must be an array'),
  body('isPublic').optional().isBoolean().withMessage('isPublic must be boolean'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const updateData = {
        title: req.body.title,
        description: req.body.description,
        tags: req.body.tags,
        isPublic: req.body.isPublic
      }

      const videoGroup = await VideoService.updateVideoGroup(
        req.params.id,
        updateData,
        req.user!
      )

      return res.json({
        success: true,
        data: videoGroup,
        message: 'Video group updated successfully'
      })

    } catch (error: any) {
      console.error('Error updating video group:', error)
      
      if (error.message === 'Video group not found') {
        return res.status(404).json({
          success: false,
          error: 'Video group not found'
        })
      }
      
      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to update video group'
      })
    }
  }
)

// POST /api/videos/groups/:groupId/videos - Upload video to group or add video URL
router.post('/groups/:groupId/videos',
  // Conditionally apply upload middleware only for multipart requests
  (req, res, next) => {
    if (req.headers['content-type']?.startsWith('multipart/form-data')) {
      uploadVideoMiddleware(req, res, (err) => {
        if (err) {
          return handleUploadErrors(err, req, res, next)
        }
        next()
      })
    } else {
      next()
    }
  },
  validateCUIDParam('groupId', 'Invalid group ID'),
  body('title').notEmpty().trim().withMessage('Title is required'),
  body('description').optional().trim(),
  // Conditional validation based on content type
  body('videoUrl').optional().isURL().withMessage('Video URL must be valid'),
  body('duration').optional().isInt({ min: 1 }).withMessage('Duration must be positive'),
  body('thumbnailUrl').optional().isURL().withMessage('Thumbnail URL must be valid'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const isFileUpload = req.file !== undefined
      const isUrlVideo = req.body.videoUrl !== undefined

      // Check if we have either a file or URL
      if (!isFileUpload && !isUrlVideo) {
        // Provide helpful debugging info
        const debugInfo = {
          hasFile: !!req.file,
          hasVideoUrl: !!req.body.videoUrl,
          bodyKeys: Object.keys(req.body),
          contentType: req.headers['content-type']
        }
        
        return res.status(400).json({
          success: false,
          error: 'Either video file or video URL is required',
          debug: debugInfo
        })
      }

      let videoData: any = {
        title: req.body.title,
        description: req.body.description || null,
        videoGroupId: req.params.groupId,
        uploadedBy: req.user!.id,
      }

      if (isFileUpload) {
        // File upload case
        videoData = {
          ...videoData,
          filename: req.file!.filename,
          originalName: req.file!.originalname,
          filePath: req.file!.filename, // Store just the filename
          mimeType: req.file!.mimetype
        }
      } else if (isUrlVideo) {
        // URL-based video case
        videoData = {
          ...videoData,
          videoUrl: req.body.videoUrl,
          duration: req.body.duration || null,
          thumbnailUrl: req.body.thumbnailUrl || null
        }
      }

      const video = await VideoService.createVideo(videoData, req.user!)

      // Convert BigInt values to strings to avoid serialization issues
      const processedVideo = JSON.parse(JSON.stringify(video, (key, value) =>
        typeof value === 'bigint' ? value.toString() : value
      ))

      return res.status(201).json({
        success: true,
        data: processedVideo,
        message: 'Video added successfully'
      })

    } catch (error: any) {
      console.error('Error creating video:', error)
      
      if (error.message === 'Video group not found') {
        return res.status(404).json({
          success: false,
          error: 'Video group not found'
        })
      }
      
      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to create video'
      })
    }
  }
)

// GET /api/videos/:id - Get specific video with milestones
router.get('/:id',
  validateCUIDParam('id', 'Invalid video ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const video = await VideoService.getVideoById(req.params.id, req.user!.id)

      if (!video) {
        return res.status(404).json({
          success: false,
          error: 'Video not found'
        })
      }

      // Convert BigInt fields to strings for JSON serialization
      const serializedVideo = {
        ...video,
        size: video.size ? video.size.toString() : null,
        milestones: video.milestones ? video.milestones.map(milestone => ({
          ...milestone,
          timestamp: milestone.timestamp ? milestone.timestamp.toString() : '0'
        })) : []
      }

      return res.json({
        success: true,
        data: serializedVideo
      })

    } catch (error) {
      console.error('Error fetching video:', error)
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch video'
      })
    }
  }
)

// PUT /api/videos/:id - Update video metadata (uploader or admin only)
router.put('/:id',
  validateCUIDParam('id', 'Invalid video ID'),
  body('title').optional().notEmpty().trim().withMessage('Title cannot be empty'),
  body('description').optional().trim(),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const updateData = {
        title: req.body.title,
        description: req.body.description
      }

      const video = await VideoService.updateVideo(
        req.params.id,
        updateData,
        req.user!
      )

      return res.json({
        success: true,
        data: video,
        message: 'Video updated successfully'
      })

    } catch (error: any) {
      console.error('Error updating video:', error)
      
      if (error.message === 'Video not found') {
        return res.status(404).json({
          success: false,
          error: 'Video not found'
        })
      }
      
      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to update video'
      })
    }
  }
)

// POST /api/videos/:id/process - Process video to extract metadata (uploader or admin only)
router.post('/:id/process',
  validateCUIDParam('id', 'Invalid video ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const video = await VideoService.processVideoMetadata(req.params.id)

      return res.json({
        success: true,
        data: video,
        message: 'Video metadata processed successfully'
      })

    } catch (error: any) {
      console.error('Error processing video metadata:', error)
      
      if (error.message === 'Video not found') {
        return res.status(404).json({
          success: false,
          error: 'Video not found'
        })
      }
      
      return res.status(500).json({
        success: false,
        error: 'Failed to process video metadata'
      })
    }
  }
)

// DELETE /api/videos/:id - Delete video (uploader or admin only)
router.delete('/:id',
  validateCUIDParam('id', 'Invalid video ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      await VideoService.deleteVideo(req.params.id, req.user!)

      return res.json({
        success: true,
        message: 'Video deleted successfully'
      })

    } catch (error: any) {
      console.error('Error deleting video:', error)
      
      if (error.message === 'Video not found') {
        return res.status(404).json({
          success: false,
          error: 'Video not found'
        })
      }
      
      if (error.message === 'Access denied') {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        })
      }

      return res.status(500).json({
        success: false,
        error: 'Failed to delete video'
      })
    }
  }
)

// GET /api/videos/:id/stream - Stream video file (authenticated users with access)
router.get('/:id/stream',
  streamingAuthenticate, // Use custom auth middleware for streaming
  validateCUIDParam('id', 'Invalid video ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    // Set CORS headers specifically for video streaming
    res.setHeader('Access-Control-Allow-Origin', req.headers.origin || 'http://localhost:3002');
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    res.setHeader('Cross-Origin-Resource-Policy', 'cross-origin');
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const videoPath = await VideoService.getVideoStreamPath(req.params.id, req.user!.id)
      console.log('Video streaming request:', {
        videoId: req.params.id,
        userId: req.user!.id,
        videoPath
      })

      if (!videoPath) {
        console.error('Video not found in database or access denied')
        return res.status(404).json({
          success: false,
          error: 'Video not found or access denied'
        })
      }

      // Check if file exists
      if (!fs.existsSync(videoPath)) {
        console.error('Video file not found on disk:', videoPath)
        return res.status(404).json({
          success: false,
          error: 'Video file not found'
        })
      }

      const stat = fs.statSync(videoPath)
      const fileSize = stat.size
      const range = req.headers.range

      if (range) {
        // Handle range requests for video streaming
        const parts = range.replace(/bytes=/, "").split("-")
        const start = parseInt(parts[0], 10)
        const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1
        const chunkSize = (end - start) + 1
        const file = fs.createReadStream(videoPath, { start, end })

        const head = {
          'Content-Range': `bytes ${start}-${end}/${fileSize}`,
          'Accept-Ranges': 'bytes',
          'Content-Length': chunkSize,
          'Content-Type': 'video/mp4'
        }

        res.writeHead(206, head)
        return file.pipe(res)
      } else {
        // Send entire file
        const head = {
          'Content-Length': fileSize,
          'Content-Type': VideoProcessingService.getMimeType(videoPath)
        }

        res.writeHead(200, head)
        return fs.createReadStream(videoPath).pipe(res)
      }

    } catch (error) {
      console.error('Error streaming video:', error)
      return res.status(500).json({
        success: false,
        error: 'Failed to stream video'
      })
    }
  }
)

// GET /api/videos/:id/thumbnail - Serve video thumbnail (authenticated users with access)
router.get('/:id/thumbnail',
  validateCUIDParam('id', 'Invalid video ID'),
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        })
      }

      const thumbnailPath = await VideoService.getThumbnailStreamPath(req.params.id, req.user!.id)

      if (!thumbnailPath) {
        return res.status(404).json({
          success: false,
          error: 'Thumbnail not found or access denied'
        })
      }

      // Check if file exists
      if (!fs.existsSync(thumbnailPath)) {
        return res.status(404).json({
          success: false,
          error: 'Thumbnail file not found'
        })
      }

      // Send thumbnail file
      return res.sendFile(path.resolve(thumbnailPath))

    } catch (error) {
      console.error('Error serving thumbnail:', error)
      return res.status(500).json({
        success: false,
        error: 'Failed to serve thumbnail'
      })
    }
  }
)

export default router
</file>

<file path="frontend/src/components/teacher/QuestionEditor.tsx">
import React, { useState, useEffect } from 'react'
import { questionService } from '../../services/video'
import { debug } from '../../utils/debug'
import type { Milestone } from '../../services/video'
import { useVideoStateManager } from '../../contexts/VideoStateContext'
import { useVideoState } from '../../hooks/useVideoState'

interface QuestionEditorProps {
  milestone: Milestone
  videoId?: string
  onClose: () => void
  onQuestionsUpdated?: () => void  // Callback when questions are added/removed
}

export function QuestionEditor({ milestone, videoId, onClose, onQuestionsUpdated }: QuestionEditorProps) {
  const manager = useVideoStateManager()
  const { questions: allQuestions } = useVideoState(videoId)
  // Use questions from VideoStateManager, not local state
  const questions = allQuestions?.get(milestone.id) || []
  const [showAddForm, setShowAddForm] = useState(false)
  const [showPreview, setShowPreview] = useState(false)
  const [loading, setLoading] = useState(false)
  const [loadingQuestions] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [previewAnswer, setPreviewAnswer] = useState('')

  const [formData, setFormData] = useState({
    type: 'MULTIPLE_CHOICE' as 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'SHORT_ANSWER',
    question: '',
    explanation: '',
    correctAnswer: '',
    options: ['', '', '', ''] // For multiple choice
  })

  // Load video state if needed when component mounts
  useEffect(() => {
    if (videoId && !allQuestions) {
      // VideoStateManager will load the video data if not cached
      manager.loadVideo(videoId)
    }
  }, [videoId, allQuestions, manager])

  const resetForm = () => {
    setFormData({
      type: 'MULTIPLE_CHOICE',
      question: '',
      explanation: '',
      correctAnswer: '',
      options: ['', '', '', '']
    })
    setShowAddForm(false)
    setError(null)
  }

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target
    setFormData(prev => ({
      ...prev,
      [name]: value
    }))
  }

  const handleOptionChange = (index: number, value: string) => {
    setFormData(prev => ({
      ...prev,
      options: prev.options.map((option, i) => i === index ? value : option)
    }))
  }

  const handleCorrectOptionChange = (optionText: string) => {
    setFormData(prev => ({
      ...prev,
      correctAnswer: optionText
    }))
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!formData.question.trim()) {
      setError('Question text is required')
      return
    }

    if (!formData.correctAnswer.trim()) {
      setError('Correct answer is required')
      return
    }

    // Validate multiple choice
    if (formData.type === 'MULTIPLE_CHOICE') {
      const validOptions = formData.options.filter(opt => opt.trim())
      if (validOptions.length < 2) {
        setError('At least 2 options are required for multiple choice questions')
        return
      }
      if (!validOptions.includes(formData.correctAnswer)) {
        setError('Correct answer must match one of the options')
        return
      }
    }

    setLoading(true)
    setError(null)

    try {
      const response = await questionService.createQuestion({
        milestoneId: milestone.id,
        type: formData.type,
        question: formData.question,
        explanation: formData.explanation || undefined,
        correctAnswer: formData.correctAnswer,
        options: formData.type === 'MULTIPLE_CHOICE' 
          ? formData.options.filter(opt => opt.trim())
          : undefined
      })

      // Add question through VideoStateManager - will update all subscribers
      if (videoId) {
        await manager.addQuestion(videoId, milestone.id, response)
      }
      resetForm()
      // Notify parent that questions have been updated
      if (onQuestionsUpdated) {
        onQuestionsUpdated()
      }
    } catch (err) {
      debug.error('Error adding question:', err)
      const message = err instanceof Error ? err.message : 'Failed to add question'
      setError(message)
    } finally {
      setLoading(false)
    }
  }

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose()
    }
  }

  return (
    <div 
      className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
      onClick={handleBackdropClick}
    >
      <div className="bg-white rounded-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto">
        <div className="p-6">
          {/* Header */}
          <div className="flex items-center justify-between mb-6">
            <div>
              <h2 className="text-xl font-bold text-gray-900">Manage Questions</h2>
              <p className="text-sm text-gray-600 mt-1">
                Milestone: {milestone.title} 
                <span className={`ml-2 px-2 py-1 rounded-full text-xs font-medium ${
                  milestone.type === 'QUIZ' 
                    ? 'bg-red-100 text-red-700'
                    : milestone.type === 'CHECKPOINT'
                    ? 'bg-blue-100 text-blue-700'
                    : 'bg-gray-100 text-gray-700'
                }`}>
                  {milestone.type}
                </span>
              </p>
            </div>
            <button
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 transition-colors"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* Existing Questions */}
            <div>
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-semibold text-gray-900">
                  Questions ({questions.length})
                </h3>
                {!showAddForm && (
                  <button
                    onClick={() => setShowAddForm(true)}
                    className="btn-primary"
                  >
                    Add Question
                  </button>
                )}
              </div>

              {loadingQuestions ? (
                <div className="text-center py-8">
                  <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-3"></div>
                  <p className="text-gray-500">Loading questions...</p>
                </div>
              ) : questions.length === 0 ? (
                <div className="text-center py-8 border-2 border-dashed border-gray-300 rounded-lg">
                  <svg className="w-12 h-12 text-gray-400 mx-auto mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                  <p className="text-gray-500 mb-4">No questions added yet</p>
                  <button
                    onClick={() => setShowAddForm(true)}
                    className="btn-primary"
                  >
                    Add First Question
                  </button>
                </div>
              ) : (
                <div className="space-y-4">
                  {questions.map((question, index) => (
                    <div key={question.id} className="border border-gray-200 rounded-lg p-4">
                      <div className="flex items-start justify-between mb-2">
                        <div className="flex items-center space-x-2">
                          <span className="text-sm font-medium text-gray-900">Q{index + 1}</span>
                          <span className={`px-2 py-1 rounded-full text-xs font-medium ${
                            question.type === 'MULTIPLE_CHOICE' 
                              ? 'bg-blue-100 text-blue-700'
                              : question.type === 'TRUE_FALSE'
                              ? 'bg-green-100 text-green-700'
                              : 'bg-purple-100 text-purple-700'
                          }`}>
                            {question.type.replace('_', ' ')}
                          </span>
                        </div>
                      </div>
                      
                      <h4 className="font-medium text-gray-900 mb-2">
                        {question.text}
                      </h4>
                      
                      {question.type === 'MULTIPLE_CHOICE' && question.questionData?.options && (
                        <div className="space-y-1 mb-2">
                          {question.questionData.options.map((option: string, optIndex: number) => (
                            <div key={optIndex} className="flex items-center text-sm">
                              <div className={`w-2 h-2 rounded-full mr-2 ${
                                optIndex === question.questionData.correctAnswerIndex ? 'bg-green-500' : 'bg-gray-300'
                              }`}></div>
                              <span className={optIndex === question.questionData.correctAnswerIndex ? 'font-medium text-green-700' : 'text-gray-600'}>
                                {option}
                              </span>
                            </div>
                          ))}
                        </div>
                      )}
                      
                      {question.type === 'TRUE_FALSE' && (
                        <div className="text-sm text-green-700 font-medium mb-2">
                          Correct: {question.questionData?.correctAnswer ? 'True' : 'False'}
                        </div>
                      )}
                      
                      {question.type === 'SHORT_ANSWER' && question.questionData?.correctAnswers && (
                        <div className="text-sm text-green-700 font-medium mb-2">
                          Correct: {question.questionData.correctAnswers.join(', ')}
                        </div>
                      )}
                      
                      {question.explanation && (
                        <p className="text-sm text-gray-600 italic">
                          Explanation: {question.explanation}
                        </p>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>

            {/* Add Question Form */}
            <div>
              {showAddForm && (
                <div className="border border-gray-200 rounded-lg p-4">
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="text-lg font-semibold text-gray-900">Add New Question</h3>
                    <button
                      onClick={resetForm}
                      className="text-gray-400 hover:text-gray-600"
                    >
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>

                  {error && (
                    <div className="bg-red-50 border border-red-200 rounded-md p-3 mb-4">
                      <p className="text-red-700 text-sm">{error}</p>
                    </div>
                  )}

                  {/* Preview Toggle */}
                  <div className="flex items-center space-x-2 mb-4">
                    <button
                      type="button"
                      onClick={() => setShowPreview(false)}
                      className={`px-3 py-1 rounded-md text-sm transition-colors ${
                        !showPreview 
                          ? 'bg-blue-100 text-blue-700 border border-blue-200'
                          : 'text-gray-500 hover:text-gray-700'
                      }`}
                    >
                      Edit
                    </button>
                    <button
                      type="button"
                      onClick={() => setShowPreview(true)}
                      className={`px-3 py-1 rounded-md text-sm transition-colors ${
                        showPreview 
                          ? 'bg-blue-100 text-blue-700 border border-blue-200'
                          : 'text-gray-500 hover:text-gray-700'
                      }`}
                      disabled={!formData.question.trim()}
                    >
                      Preview
                    </button>
                  </div>

                  {showPreview ? (
                    /* Question Preview */
                    <div className="bg-gray-50 rounded-lg p-4">
                      <h4 className="font-medium text-gray-900 mb-4">
                        Preview: How students will see this question
                      </h4>
                      
                      <div className="bg-white rounded-lg p-4 border border-gray-200">
                        <h5 className="font-medium text-gray-900 mb-3">
                          {formData.question || 'Enter your question...'}
                        </h5>
                        
                        {formData.type === 'MULTIPLE_CHOICE' && (
                          <div className="space-y-2">
                            {formData.options.filter(opt => opt.trim()).map((option, index) => (
                              <label key={index} className="flex items-center space-x-2 cursor-pointer">
                                <input
                                  type="radio"
                                  name="preview-answer"
                                  value={option}
                                  checked={previewAnswer === option}
                                  onChange={(e) => setPreviewAnswer(e.target.value)}
                                  className="text-blue-600"
                                />
                                <span className="text-gray-700">{option}</span>
                              </label>
                            ))}
                          </div>
                        )}
                        
                        {formData.type === 'TRUE_FALSE' && (
                          <div className="space-y-2">
                            {['True', 'False'].map((option) => (
                              <label key={option} className="flex items-center space-x-2 cursor-pointer">
                                <input
                                  type="radio"
                                  name="preview-answer"
                                  value={option}
                                  checked={previewAnswer === option}
                                  onChange={(e) => setPreviewAnswer(e.target.value)}
                                  className="text-blue-600"
                                />
                                <span className="text-gray-700">{option}</span>
                              </label>
                            ))}
                          </div>
                        )}
                        
                        {formData.type === 'SHORT_ANSWER' && (
                          <input
                            type="text"
                            value={previewAnswer}
                            onChange={(e) => setPreviewAnswer(e.target.value)}
                            placeholder="Student will type their answer here..."
                            className="w-full px-3 py-2 border border-gray-300 rounded-md"
                          />
                        )}
                        
                        {/* Show feedback */}
                        {previewAnswer && (
                          <div className={`mt-3 p-3 rounded-md ${
                            previewAnswer === formData.correctAnswer
                              ? 'bg-green-50 border border-green-200'
                              : 'bg-red-50 border border-red-200'
                          }`}>
                            <div className="flex items-center space-x-2">
                              {previewAnswer === formData.correctAnswer ? (
                                <svg className="w-5 h-5 text-green-500" fill="currentColor" viewBox="0 0 20 20">
                                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                                </svg>
                              ) : (
                                <svg className="w-5 h-5 text-red-500" fill="currentColor" viewBox="0 0 20 20">
                                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L10 10.414l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                                </svg>
                              )}
                              <span className={`font-medium ${
                                previewAnswer === formData.correctAnswer ? 'text-green-700' : 'text-red-700'
                              }`}>
                                {previewAnswer === formData.correctAnswer ? 'Correct!' : 'Incorrect'}
                              </span>
                            </div>
                            {formData.explanation && (
                              <p className={`mt-2 text-sm ${
                                previewAnswer === formData.correctAnswer ? 'text-green-700' : 'text-red-700'
                              }`}>
                                {formData.explanation}
                              </p>
                            )}
                            {previewAnswer !== formData.correctAnswer && (
                              <p className="mt-2 text-sm text-red-700">
                                Correct answer: {formData.correctAnswer}
                              </p>
                            )}
                          </div>
                        )}
                      </div>
                      
                      <div className="flex justify-end space-x-2 mt-4">
                        <button
                          type="button"
                          onClick={() => setPreviewAnswer('')}
                          className="text-sm px-3 py-1 text-gray-500 hover:text-gray-700"
                        >
                          Clear Answer
                        </button>
                      </div>
                    </div>
                  ) : (
                    <form onSubmit={handleSubmit} className="space-y-4">
                    {/* Question Type */}
                    <div>
                      <label htmlFor="type" className="block text-sm font-medium text-gray-700 mb-1">
                        Question Type
                      </label>
                      <select
                        id="type"
                        name="type"
                        value={formData.type}
                        onChange={handleInputChange}
                        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                      >
                        <option value="MULTIPLE_CHOICE">Multiple Choice</option>
                        <option value="TRUE_FALSE">True/False</option>
                        <option value="SHORT_ANSWER">Short Answer</option>
                      </select>
                    </div>

                    {/* Question Text */}
                    <div>
                      <label htmlFor="question" className="block text-sm font-medium text-gray-700 mb-1">
                        Question *
                      </label>
                      <textarea
                        id="question"
                        name="question"
                        value={formData.question}
                        onChange={handleInputChange}
                        placeholder="Enter your question here"
                        rows={2}
                        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        required
                      />
                    </div>

                    {/* Options for Multiple Choice */}
                    {formData.type === 'MULTIPLE_CHOICE' && (
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                          Answer Options *
                        </label>
                        <div className="space-y-2">
                          {formData.options.map((option, index) => (
                            <div key={index} className="flex items-center space-x-2">
                              <input
                                type="radio"
                                name="correctAnswer"
                                value={option}
                                checked={formData.correctAnswer === option && option.trim() !== ''}
                                onChange={(e) => handleCorrectOptionChange(e.target.value)}
                                className="text-blue-600"
                                disabled={!option.trim()}
                              />
                              <input
                                type="text"
                                value={option}
                                onChange={(e) => handleOptionChange(index, e.target.value)}
                                placeholder={`Option ${index + 1}`}
                                className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                              />
                            </div>
                          ))}
                        </div>
                        <p className="text-xs text-gray-500 mt-1">
                          Select the radio button for the correct answer
                        </p>
                      </div>
                    )}

                    {/* Correct Answer for True/False and Short Answer */}
                    {formData.type !== 'MULTIPLE_CHOICE' && (
                      <div>
                        <label htmlFor="correctAnswer" className="block text-sm font-medium text-gray-700 mb-1">
                          Correct Answer *
                        </label>
                        {formData.type === 'TRUE_FALSE' ? (
                          <select
                            id="correctAnswer"
                            name="correctAnswer"
                            value={formData.correctAnswer}
                            onChange={handleInputChange}
                            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                            required
                          >
                            <option value="">Select correct answer</option>
                            <option value="True">True</option>
                            <option value="False">False</option>
                          </select>
                        ) : (
                          <input
                            type="text"
                            id="correctAnswer"
                            name="correctAnswer"
                            value={formData.correctAnswer}
                            onChange={handleInputChange}
                            placeholder="Enter the correct answer"
                            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                            required
                          />
                        )}
                      </div>
                    )}

                    {/* Explanation */}
                    <div>
                      <label htmlFor="explanation" className="block text-sm font-medium text-gray-700 mb-1">
                        Explanation (Optional)
                      </label>
                      <textarea
                        id="explanation"
                        name="explanation"
                        value={formData.explanation}
                        onChange={handleInputChange}
                        placeholder="Explain why this is the correct answer"
                        rows={2}
                        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                      />
                    </div>

                    {/* Actions */}
                    <div className="flex justify-end space-x-2">
                      <button
                        type="button"
                        onClick={resetForm}
                        className="btn-secondary"
                      >
                        Cancel
                      </button>
                      <button
                        type="submit"
                        disabled={loading}
                        className={`btn-primary ${loading ? 'opacity-50 cursor-not-allowed' : ''}`}
                      >
                        {loading ? 'Adding...' : 'Add Question'}
                      </button>
                    </div>
                  </form>
                  )}
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

</files>
